
\documentclass[10pt, a4paper]{article}

\input{parameters}

\usepackage{style}
\usepackage{headerfooter}

\title{\titolo}
\author{SWEetCode}

\begin{document}

% PRIMA PAGINA
\include{firstpage}

% REGISTRO DELLE VERSIONI
\include{registroversioni}
\newpage

% INDICE
\tableofcontents
\newpage

% INTRODUZIONE
\section{Introduzione}
\subsection{Scopo del documento}
Questo documento si prefigge lo scopo di normare e documentare un corretto \textit{Way of Working} che verrà seguito lungo l'intero svolgimento del progetto.\\
Tutti i membri del team sono tenuti a visionare tale documento e a seguire le norme contenute in esso. Tali norme permettono di perseguire e migliorare la coerenza ed omogeneità del lavoro e dei file prodotti.
Viene inoltre fornito uno storico delle modifiche e delle versioni del documento per seguire un approccio incrementale nella sua redazione, facilitandone i cambiamenti nel corso del tempo.

\section{Riferimenti}
    \subsection{Riferimenti normativi}
    \begin{itemize}
        \item \textit{ISO/IEC 12207:1997 Information technology — Software life cycle processes}\\
        \url{https://www.math.unipd.it/~tullio/IS-1/2009/Approfondimenti/ISO_12207-1995.pdf};
        \item \textit{SEMAT}\\
        \url{https://semat.org/documents/20181/57862/formal-18-10-02.pdf/formal-18-10-02.pdf};
        \item \textit{Regolamento del progetto didattico}
        \url{https://www.math.unipd.it/~tullio/IS-1/2023/Dispense/PD2.pdf}.
    \end{itemize}
    \subsection{Riferimenti informativi}
    \begin{itemize}
        \item \textit{Glossario};
        \item \textit{Analisi dei requisiti};
        \item \textit{Piano di progetto};
        \item \textit{Piano di qualifica};
        \item Capitolato C1: \textit{Knowledge Management AI}
            \begin{itemize}
                \item \url{https://www.math.unipd.it/~tullio/IS-1/2023/Progetto/C1.pdf};
                \item \url{https://www.math.unipd.it/~tullio/IS-1/2023/Progetto/C1p.pdf}.
            \end{itemize}
        \item Slide lezioni \textit{Ingegneria del software} 2023/2024:
            \begin{itemize}
                \item \url{https://www.math.unipd.it/~tullio/IS-1/2023/Dispense/T2.pdf};
                \item \url{https://www.math.unipd.it/~tullio/IS-1/2023/Dispense/T3.pdf};
                \item \url{https://www.math.unipd.it/~tullio/IS-1/2023/Dispense/T4.pdf};
                \item \url{https://www.math.unipd.it/~tullio/IS-1/2023/Dispense/T5.pdf};
                \item \url{https://www.math.unipd.it/~tullio/IS-1/2023/Dispense/T6.pdf};
                \item \url{https://www.math.unipd.it/~tullio/IS-1/2023/Dispense/T7.pdf};
                \item \url{https://www.math.unipd.it/~tullio/IS-1/2023/Dispense/T8.pdf};
                \item \url{https://www.math.unipd.it/~tullio/IS-1/2023/Dispense/T9.pdf};
                \item \url{https://www.math.unipd.it/~tullio/IS-1/2023/Dispense/T10.pdf};
                \item \url{https://www.math.unipd.it/~tullio/IS-1/2023/Dispense/T11.pdf}.
            \end{itemize}.
    \end{itemize}

\section{Glossario}
Per evitare ambiguità ed incomprensioni relative al linguaggio e ai termini utilizzati nella documentazione del progetto viene presentato un Glossario. 
I termini ambigui o tecnici-specifici presenti nello stesso, vengono identificati nei corrispondenti documenti con un pedice |g| e con una scrittura in corsivo.
All'interno dei documenti viene identificata con tale scrittura solo e soltanto la prima occorrenza di un termine presente nel Glossario.\\
All'interno di quest'ultimo i termini vengono ordinati in ordine alfabetico e raggruppati per lettera d'inizio del termine.\\
I documenti che sono corredati dal Glossario sono:
\begin{itemize}
    \item Analisi dei requisiti;
    \item Norme di progetto;
    \item Piano di progetto;
    \item Piano di qualifica.
\end{itemize}

% APPLICAZIONE STANDARD

\section{Applicazione standard ISO/IEC 12207:1997}
In questo documento il team si impegna ad essere conforme allo Standard textit{ISO/IEC 12207:1997 - Information technology — Software life cycle processes}. Questa sezione del documento è dedicata all'applicazione pratica degli standard e dei processi definiti nell'ambito di questo Standard Internazionale.

\subsection{Organizzazione dello Standard: processi del ciclo di vita del software}
In questa sezione viene presentata l'organizzazione dei processi secondo lo Standard textit{ISO/IEC 12207:1997 - Information technology 
— Software life cycle processes} del ciclo di vita del software. In questo documento utilizzato per normare il \textit{way of working} 
del team, viene presentata una organizzazione gerarchica in cui ogni processo è costituito da un insieme di attività, che a 
loro volta possono presentare delle procedure e un elenco di strumenti utilizzati nel loro svolgimento.

\subsubsection{Processi primari del ciclo di vita}
Sebbene lo Standard adottato presenti cinque processi primari (\textit{Acquisizione, Fornitura, Sviluppo, Operazione, Manutenzione}),
all'interno del contesto del progetto universitario in atto, il team non ritiene il processo \textit{Manutenzione} pertienente e, pertanto, 
si è deciso di escluderlo dalla presentazione nel documento.\\
I processi primari presentati nel presente documento sono:
\begin{itemize}
    \item \textit{Acquisizione}: definisce le attività dell'acquirente, l'organizzazione che acquisisce un prodotto software;
    \item \textit{Fornitura}: definisce le attività del fornitore, l'organizzazione che fornisce il prodotto software all'acquirente;
    \item \textit{Sviluppo}: definisce le attività dello sviluppatore, l'organizzazione che definisce e sviluppa il prodotto software.
\end{itemize}

\subsubsection{Processi di supporto del ciclo di vita}
I processi di supporto presentati nel presento documento sono:
\begin{itemize}
    \item \textit{Documentazione}: definisce le attività per la registrazione delle informazioni prodotte da un processo del ciclo di vita;
    \item \textit{Configuration Management}: definisce le attività di gestione della configurazione;
    \item \textit{Assicurazione della qualità}: definisce le attività per assicurare in modo oggettivo che i prodotti e i processi software
    siano conformi ai requisiti specificati e rispettino i piani stabiliti;
    \item \textit{Verifica}: definisce le attività per verificare il prodotto software;
    \item \textit{Validazione}: definisce le attività per validare il prodotto software;
    \item \textit{Revisione congiunta}: definisce le attività per valutare lo stato e i prodotti di un'attività. Questo processo può essere 
    utilizzato da qualsiasi coppia di parti, in cui una parte (la parte che esegue la revisione) valuta un'altra parte (la parte che viene revisionata)
    in un forum congiunto;
    \item \textit{Revisione}: definisce le attività per determinare la conformità ai requisiti, piani e contratti;
    \item \textit{Risoluzione dei problemi}: definisce un processo per analizzare e risolvere i problemi di qualsiasi natura o origine, scoperti
    durante l'esecuzione di processi.
\end{itemize}

\subsubsection{Processi organizzativi del ciclo di vita}
I processi organizzativi presentati nel presento documento sono:
\begin{itemize}
    \item \textit{Gestione organizzativa}: definisce le attività di management durante i processi del ciclo di vita;
    \item \textit{Infrastruttura}: definisce le attività base per stabilire una struttura in un processo del ciclo di vita;
    \item \textit{Miglioramento}: definisce le attività che il team esegue per stabilire, misurare, controllare e migliorare i processi del ciclo di vita;
    \item \textit{Formazione}: definisce le attività atte a provvedere una adeguata formazione del team.
\end{itemize}

% PROCESSI PRIMARI
\newpage

\section{Processi primari}

\subsection{Acquisizione}
Le modalità del processo di acquisizione per il progetto sono state fissate dal docente e sono reperibili all'interno della sezione 
(\S Riferimenti), in (\S Riferimenti normativi), in (\S Regolamento del progetto didattico).\\
Le fasi del processo di acquisizione stabilite sono le seguenti:
\begin{enumerate}
    \item Definizione della necessità di acquisizione di un prodotto software da parte dell'azienda proponente;
    \item Formazione dei gruppi di lavoro da parte del docente del corso Vardanega T.(2023-10-14);
    \item Presentazione dei capitolati d'appalto da parte dell'azienda proponente nei confronti dei gruppi di lavoro (2023-10-17);
    \item Presentazione delle candidature di appalto da parte dei gruppi di lavoro (2023-10-31);
    \item Aggiudicazione appalti con assegnazione svolta da parte del docente Vardanega T. in base alle candidature presentate e alle sue 
    valutazioni interne e ad una consultazione con il proponente (2023-11-06);
    \item Presentazione del \textit{Proof of Concept (PoC)} da parte del gruppo di lavoro all'azienda proponente;
    \item Accettazione da parte dell'azienda proponente del \textit{PoC} proposto dal gruppo di lavoro;
    \item Presentazione della candidatura per la revisione \textit{Requirements and Technology Baseline} da parte del gruppo di lavoro;
    \item Revisione \textit{Requirements and Technology Baseline} sottoposta dai docenti del corso Vardanega T. e Cardin R. in due parti, con 
    conseguente valutazione;
    \item Presentazione del \textit{Minimum Viable Product (MVP)} da parte del gruppo di lavoro all'azienda proponente;
    \item Accettazione da parte dell'azienda proponente del \textit{MVP} proposto dal gruppo di lavoro;
    \item Presentazione della candidatura per la revisione \textit{Product Baseline} da parte del gruppo di lavoro;
    \item Revisione \textit{Product Baseline} sottoposta dai docenti del corso Vardanega T. e Cardin R. in due parti, con 
    conseguente valutazione.
\end{enumerate}
I ruoli definiti all'interno di questo progetto didattico universitario sono:
\begin{itemize}
    \item Docente del corso: committente;
    \item Azienda proponente: cliente e mentore;
    \item Gruppo di lavoro: fornitore. 
\end{itemize}
Le stime dei tempi di consegna e del prezzo viene effettuata dal gruppo di lavoro durante la fase di presentazione della 
candidatura d'appalto.\\
La definizione del prezzo durante la fase di candidatura costituisce il limite superiore invalicabile durante lo svolgimento del progetto ed
è derivante dai costi (stabiliti dal docente del corso) di ciascun ruolo ricopribile all'interno del gruppo di lavoro.\\
Le date di consegna sono invece libere e soggette a stringenti regole di ingresso e vengono stabilite dal gruppo di lavoro assieme al proponente,
cercando di rispettare il più possibile le stime iniziali stabilite durante la fase di candidatura d'appalto.

\subsection{Fornitura}
Il processo di fornitura descrive le attività svolte dal fornitore e coinvolge pianificazione, acquisizione e gestione delle risorse 
necessarie. Il processo segue la determinazione delle procedure e delle risorse necessarie per gestire e garantire il progetto.
L'obiettivo del processo è la garanzia dell'efficienza e della conformità ai requisiti del progetto per raggiungere gli obiettivi stabiliti 
con il proponente.\\
Viene fissata con il proponente la data di consegna del prodotto finale.\\
Il processo di fornitura è formato dalle seguenti 7 fasi:
\begin{itemize}
    \item \textbf{Iniziazione}: Il fornitore effettua una revisione dei requisiti nella richiesta di proposta;
    \item \textbf{Preparazione della risposta}: Il fornitore definisce e prepara una proposta in risposta alla richiesta di proposta;
    \item \textbf{Negoziazione}: Il fornitore negozia e stipula un accordo con il proponente per fornire il prodotto finale;
    \item \textbf{Pianificazione}: Il fornitore effettua una revisione dei requisiti di acquisizione e valuta le opzioni per lo 
    sviluppo del prodotto software in base ad un'analisi dei rischi associati a ciascuna opzione per definire la struttura del piano di gestione 
    del progetto e per garantire la qualità del prodotto finale (il fornitore deve sviluppare e documentare tale piano);
    \item \textbf{Esecuzione e controllo}: Il fornitore esegue il piano di gestione del progetto e monitora e controlla il progresso e la qualità
    del prodotto durante l'intero ciclo del progetto;
    \item \textbf{Revisione e valutazione}: Il fornitore coordina le attività di comunicazione con il proponente e conduce o supporta riunioni informali,
    revisioni di accettazione, test di accettazione, revisioni congiunte. Il fornitore  esegue la verifica e la convalida del processo 
    per dimostrare che i prodotti o servizi software e i processi soddisfano appieno i rispettivi requisiti;
    \item \textbf{Consegna e completamento}: Il fornitore consegna il prodotto finale, e dovrà fornire assistenza al proponente a supporto 
    del prodotto consegnato.
\end{itemize}
\subsubsection{Gestione}
Per garantire un processo di fornitura efficace ed efficiente viene mantenuta la comunicazione con l'azienda proponente durante tutto il 
corso del progetto, mediante riunioni settimanali su \textit{Google Meet} pianificate con \textit{Google Calendar} e scambio di messaggi 
qualora fosse necessario attraverso la piattaforma \textit{Slack}. In questo modo al fornitore risulta possibile un'identificazione accurata
dei bisogni del proponente con conseguente individuazione accurata dei requisiti e dei vincoli del progetto. Il dialogo continuo con il 
proponente permette infine una valutazione continua e costante del lavoro svolto dal fornitore, in modo da permettere correzioni, 
integrazioni e miglioramenti in modo incrementale e costruttivo.  
\subsubsection{Piano di Progetto}
Il Piano di progetto viene redatto dal responsabile con l'aiuto degli amministratori. Fornisce una guida dettagliata per la pianificazione, 
l'esecuzione e il controllo del progetto e serve come base per il monitoraggio del progresso, la gestione dei rischi e la comunicazione tra
proponente e fornitore.\\ 
Il suo contenuto comprende:
\begin{itemize}
    \item Calendario di progetto;
    \item Stima dei costi di realizzazione;
    \item Rischi e mitigazione;
    \item Pianificazione e modello di sviluppo;
    \item Preventivo e consuntivo;
    \item Retrospettiva.
\end{itemize}
\subsubsection{Piano di Qualifica}
Il Piano di qualifica definisce le strategie, gli obiettivi e le attività per garantire la qualità del prodotto finale. Vengono definite in 
tale documento le metriche di valutazione e validazione del progetto e la specifica degli obiettivi di qualità del prodotto finale. 
Tali parametri vengono stabiliti in accordo ai requisiti e alle aspettative del proponente e talvolta a discrezione del team sulla base 
delle valutazioni fatte nel corso di studi. Il suo scopo è assicurare che il prodotto soddisfi gli standard di qualità definiti e che 
eventuali deviazioni vengano gestite in modo appropriato.\\
Il suo contenuto comprende:
\begin{itemize}
    \item Qualità di processo;
    \item Qualità di prodotto;
    \item Test e specifiche;
    \item Valutazioni per il miglioramento;
    \item Resoconto delle attività di verifica.
\end{itemize}
\subsubsection{Strumenti}
\begin{itemize}
    \item {\textbf{Gmail}}: servizio di posta elettronica fornito da \textit{Google}, utilizzato per le prime comunicazioni tra proponente e fornitore;
    \item {\textbf{Google Calendar}}: sistema di calendari usato per pianificare riunioni, scadenze e in generale
    eventi significativi tra proponente e gruppo;
    \item {\textbf{Google Sheet}}: parte del Google Workspace, fornisce dei fogli di calcolo utilizzati per la creazione di tabelle e grafici utili in particolare al Piano di progetto;
    \item {\textbf{Slack}}: piattaforma di messaggistica specializzata nella comunicazione e collaborazione all’interno di team aziendali. Viene utilizzata dal team per le comunicazioni asincrone con il proponente.
\end{itemize}

\subsection{Sviluppo}
Il processo di sviluppo si pone lo scopo di descrivere tutte le attività e i compiti che portano un prodotto dalla fase di ideazione a quella di realizzazione. 
Per tale motivo vengono dunque presentate le seguenti attività:
\begin{itemize}
    \item Analisi dei requisiti;
    \item Progettazione logica;
    \item Progettazione di dettaglio;
    \item Codifica;
    \item Testing;
    \item Integrazione software;
    \item Installazione software.
\end{itemize}

\subsubsection{Analisi dei requisiti}
L'attività di analisi dei requisiti, la quale viene documentata all'interno del documento (\S Analisi dei requisiti), viene svolta seguendo le seguenti fasi:
\begin{itemize}
    \item Studio accurato del capitolato e delle esigenze del committente;
    \item Individuazione dei casi d'uso (e relativa produzione dei diagrammi dei casi d'uso) e dei requisiti;
    \item Discussione con il proponente del materiale prodotto;
    \item Divisione dei requisiti nelle tre categorie individuate e applicazione degli spunti emersi dalla discussione col proponente.
\end{itemize}
(L'analisi dei requisiti, essendo una attività incrementale, prevede che alcune fasi siano svolte più volte all'interno del progetto).
Il risultato di tale processo è un documento che contiene tutti i requisiti richiesti dal proponente, con relativi casi d'uso dal punto di vista dell'utente finale.\\

\subsubsubsection{Casi d'uso: Notazione}
I casi d'uso sono indicati con la notazione seguente: \textbf{UC[Codice] - [Titolo]}\\
in cui:
\begin{itemize}
\item \textbf{UC} sta per Use Case;
\item \lbrack \textbf{Codice}] è l'identificativo del caso d'uso. È composto da un unico numero progressivo univoco se il caso d'uso non ha padre, mentre se si tratta di un sottocaso d'uso, segue il formato \textbf{[Codice\_padre].[Numero\_figlio]}; questa struttura è ricorsiva, quindi non pone un limite alla profondità della gerarchia;
\item \lbrack \textbf{Titolo}] è il titolo del caso d'uso.
\end{itemize}

\subsubsubsection{Casi d'uso: Didascalie}
Per ogni caso d'uso è presentata una breve didascalia che ne indica:
\begin{itemize}
    \item Attore principale (attore che partecipa e dialoga attivamente con il sistema nello scenario principale per raggiungere uno scopo);
    \item Attore secondario (attore esterno al sistema che, se presente, aiuta il sistema a raggiungere l'obiettivo dell'attore principale);
    \item Precondizioni (condizioni che devono essere vere affinché il caso d'uso possa essere eseguito);
    \item Postcondizioni (condizioni del sistema dopo che il caso d'uso si è concluso);
    \item Scenario principale (sequenza di passaggi che definisce un'interazione tra attore e sistema);
    \item Scenario alternativo (scenario che si verifica se si diverge dallo scenario principale);
    \item Estensioni (lista di casi d'uso che deviano il flusso principale del caso d'uso in esame, introducendo flussi alternativi);
    \item Inclusioni (lista di casi d'uso che rappresentano una parte dello scenario principale, ma estratti come casi d'uso singoli per aumentare il riuso nel caso in cui appaiono in scenari principali di più casi d'uso);
    \item Generalizzazioni (lista di casi d'uso che ereditano le caratteristiche del caso d'uso in esame aggiungendo specificità);
    \item Trigger (evento scatenante del caso d'uso).
\end{itemize}

\subsubsubsection{Requisiti: Notazione}
Ogni requisito preso in analisi sarà trattato con la sigla:
\textbf{R[Tipo].[Importanza].[Codice]}\\
nella quale:
\begin{itemize}
\item \lbrack \textbf{R}] indica la parola "requisito";
\item \lbrack \textbf{Tipo}] può essere:
    \begin{itemize}
	    \item F (Funzionale);
	    \item Q (Qualità);
	    \item V (Vincolo);
        \item V (Prestazione).
    \end{itemize}
\item \lbrack \textbf{Importanza}] classifica i requisiti in:
    \begin{itemize}
        \item O (Obbligatorio);
		\item D (Desiderabile);
		\item OP (Opzionale).
    \end{itemize}
\item \lbrack \textbf{Codice}] identifica i requisiti per ogni tipologia. È composto da un unico numero progressivo univoco se il requisito non ha padre, mentre se si tratta di un sotto-requisito, segue il formato \textbf{[Codice\_padre].[Numero\_figlio]}; questa struttura è ricorsiva, quindi non pone un limite alla profondità della gerarchia;
\end{itemize}

\subsubsubsection{Requisiti: Suddivisione}
\begin{itemize}
\item I requisiti funzionali descrivono le funzionalità del sistema, le azioni
che il sistema può compiere e le informazioni che il sistema può fornire.\\
Seguendo la notazione riportata sopra, questi si possono partizionare in:
\begin{itemize}
    \item RF.O - Requisito Funzionale Obbligatorio;
    \item RF.D - Requisito Funzionale Desiderabile;
    \item RF.OP - Requisito Funzionale Opzionale.
\end{itemize}
\end{itemize}
\begin{itemize}
\item I requisiti di qualità descrivono come un sistema deve essere, o
come il sistema deve esibirsi, per soddisfare le esigenze dell'utente.\\
Seguendo la notazione riportata sopra, questi si possono partizionare in:
\begin{itemize}
    \item RQ.O - Requisito di Qualità Obbligatorio;
    \item RQ.D - Requisito di Qualità Desiderabile;
    \item RQ.OP - Requisito di Qualità Opzionale.
\end{itemize}
\end{itemize}
\begin{itemize}
\item I requisiti di vincolo descrivono i limiti e le restrizioni normative/legislative che un sistema deve rispettare per soddisfare le esigenze dell'utente.\\
Seguendo la notazione riportata sopra, questi si possono partizionare in:
\begin{itemize}
    \item RV.O - Requisito di Vincolo Obbligatorio;
    \item RV.D - Requisito di Vincolo Desiderabile;
    \item RV.OP - Requisito di Vincolo Opzionale. 
\end{itemize}
\item I requisiti di prestazione descrivono vincoli di tempo e spazio che il prodotto deve rispettare.\\
Seguendo la notazione riportata sopra, questi si possono partizionare in:
\begin{itemize}
    \item RP.O - Requisito di Prestazione Obbligatorio;
    \item RP.D - Requisito di Prestazione Desiderabile;
    \item RP.OP - Requisito di Prestazione Opzionale. 
\end{itemize}
\end{itemize}

\subsubsubsection{Diagrammi}
I diagrammi dei casi d'uso e di attività riportati all'interno del documento (Analisi dei requisiti) devono seguire la notazione e le specifiche indicate da \textit{UML v2.5}.

\subsubsubsection{Applicazione milestone SEMAT}
SWEetCode nell'esecuzione dell'attività di analisi dei requisiti ha deciso di adottare la pianificazione in milestone presentata 
da \textit{SEMAT}: tale pianificazione viene spiegata nel dettaglio all'interno del (\S Piano di progetto).

\subsubsection{Progettazione}
\paragraph{Scopo}
L'attività di progettazione ha lo scopo di fissare un'archiettura del prodotto che soddisfi i requisiti determinati dall'attività di analisi, prima di passare alla codifica.
La progettazione serve a dominare la complessità del prodotto, decomponendolo in parti componibili e organizzate.

I progettisti del team avranno l'obbligo di considerare le seguenti proprietà durante l'attività di progettazione:
\begin{itemize}
    \item \textbf{Sufficienza}: in grado di soddisfare tutti i requisiti;
    \item \textbf{Modularità}: suddivisa in parti chiare e ben distinte, esponendo interfacce e nascondendo l'implementazione;
    \item \textbf{Robustezza}: resiliente a più tipi e quantità di input;
    \item \textbf{Flessibilità}: permette modifiche mantenendo limitati i costi per apportarle;
    \item \textbf{Riusabilità}: permette il riuso delle sue parti in applicazioni esterne;
    \item \textbf{Efficienza}: è efficiente nello spazio, nel tempo e nei consumi;
    \item \textbf{Affidabilità}: svolge bene il suo lavoro;
    \item \textbf{Semplicità}: ogni parte contiene lo stretto necessario;
    \item \textbf{Incapsulazione}: nasconde l'interno delle componenti architetturali all'esterno;
    \item \textbf{Coesione}: parti che agiscono sulle stesse unità di dati sono raccolte nello stesso componente;
    \item \textbf{Basso accoppiamento}: limita le dipendenze tra parti diverse;
\end{itemize}

Seguendo il modello a V, l'attività di progettazione si divide in due fasi: progettazione logica e progettazione di dettaglio.

\paragraph{Progettazione logica}
La progettazione logica consiste nel trasformare i requisiti software in un'architettura che descrive la struttura di alto livello del prodotto software e ne identifica i componenti.
In questa fase i progettisti devono assicurarsi che tutti i requisiti siano assegnati ai componenti e che questi siano ulteriormente dettagliati, in modo da facilitare la successiva progettazione di dettaglio.

In particolare, i progettisti devono:
\begin{itemize}
    \item Progettare le interfacce esterne al software e tra i componenti del software;
    \item Definire e progettare le strutture dati necessarie per soddisfare i requisiti;
    \item Documentare una versione preliminare del (Manuale utente);
    \item Pianificare e definire, collaborando con i verificatori, i test di integrazione tra componenti;
    \item Valutare e revisionare l'architettura definita nei passi precedenti, coinvolgendo tutti i membri del team e altre parti interessate. In particolare, il team collaborerà con dei membri dell'azienda proponente in modo da ottenere consigli e correzioni da fonti autorevoli e con esperienza.
\end{itemize}

\paragraph{Progettazione di dettaglio}
\label{sec:progettazione_di_dettaglio}
La progettazione di dettaglio consiste nel suddividere il sistema affinché ogni singola parte abbia una complessità tale da poter essere codificata da un unico individuo, in modo rapido, fattibile e verificabile.

I progettisti hanno il dovere di fermarsi quando la decomposizione diventa controproduttiva, cioè nel momento in cui il costo di coordinamento tra le parti decomposte è maggiore del beneficio prodotto decomponendo.

La progettazione di dettaglio agisce sulle unità architetturali, cioè unità funzionali ben definite, la cui codifica può essere assegnata ad un unico programmatore.
Ogni unità architetturale è formata da uno o più moduli, e più unità architetturali formano un componente, che è l'oggetto dell'architettura logica.
L'architettura di dettaglio guida la codifica e l'integrazione e semplifica il tracciamento dei requisiti.

Durante la progettazione di dettaglio, i progettisti hanno il compito di:
\begin{itemize}
    \item Definire e progettare in modo dettagliato i componenti software, lavorando a livello di unità e moduli;
    \item Aggiornare e dettagliare il (Manuale utente);
    \item Definire la specifica dei test di unità, collaborando con i verificatori;
    \item Definire la specifica dei test di integrazione, collaborando con i verificatori;
\end{itemize}

\paragraph{Specifica architetturale}
La progettazione deve essere ben documentata, affinché la codifica e la verifica del software possano essere svolte in modo autonomo e disciplinato.

Ogni parte individuata deve essere dodata di una specifica chiara e coesa, realizzabile entro i costi e le risorse disponibili.

Queste specifiche sono raccolte nel documento (Specifica architetturale), che verrà prodotto dopo il superamento della fase di revisione RTB.
Le modalità di stesura e l'organizzazione di questo documento verranno indicate in parallelo alla sua creazione.

\subsubsection{Codifica}
\subsubsubsection{Scopo}
La codifica, svolta dai programmatori, ha lo scopo di realizzare concretamente il prodotto software seguendo l'architettura definita dai progettisti.
Questa sezione ha il compito di normare il codice, in modo da:
\begin{itemize}
    \item Facilitarne la lettura, aumentarne l'uniformità e la robustezza;
    \item Facilitarne e velocizzarne la verifica;
    \item Facilitarne la manutenzione, il debugging e l'estensione;
    \item Migliorarne la qualità;
\end{itemize}

\subsubsubsection{Stile di codifica: Python}
\subsubsubsubsection{Struttura dei file}
La struttura di un sorgente Python è definita dalle seguenti parti:
\begin{itemize}
    \item Import: insieme di istruzioni di import che seguono l'ordine:
    \begin{enumerate}
        \item Librerie esterne;
        \item Librerie interne.
    \end{enumerate}
    \item Classe: rappresenta un'unità o raccoglie funzioni di utilità.
\end{itemize}
\subsubsubsubsection{Struttura delle classi}
La struttura di una classe Python è definita dalle seguenti parti, se necessarie:
\begin{enumerate}
    \item Lista di classi estese o interfaccia implementata;
    \item Costruttore;
    \item Attributi;
    \item Metodi.
\end{enumerate}
Ogni classe deve essere opportunamente documentata, seguendo il formato \textit{Google docstrings}; in particolare:
\begin{itemize}
    \item Dopo la definizione della classe, devono essere presenti, in una serie di commenti:
    \begin{itemize}
        \item Descrizione del ruolo della classe;
        \item Lista degli argomenti richiesti dal costrutture, seguiti da una breve descrizione;
        \item Lista degli attributi della classe, seguiti da una breve descrizione;
        \item Lista dei metodi della classe, seguiti da una breve descrizione.
    \end{itemize}
    \item Dopo la definizione dei metodi, devono essere presenti, in una serie di commenti:
    \begin{itemize}
        \item Descrizione del metodo;
        \item Lista di argomenti del metodo, seguiti da una breve descrizione;
        \item Lista degli eventuali return, seguiti da una breve descrizione.
    \end{itemize}
\end{itemize}
\subsubsubsubsection{Pratiche di programmazione}
\begin{itemize}
    \item \textbf{Metodi}: preferire più metodi semplici e con responsabilità singola rispetto a metodi lunghi e complessi;
    \item \textbf{Attributi}: mai accedere direttamente ad attributi di una classe. Utilizzare solo i metodi forniti per interagire con essa;
    \item \textbf{Self}: riferirsi ai parametri interni attraverso l'uso del riferimento self;
    \item \textbf{Visibilità}: usare la minima visibilità possibile per gli attributi;
    \item \textbf{Importazioni}: Importare i moduli all'inizio dello script o del modulo. Evitare importazioni con asterisco (\texttt{from module import *});
    \item \textbf{Commenti}: usare le seguenti convenzioni nei commenti:
        \begin{itemize}
            \item TODO: per indicare sezioni di codice non ancora completate;
            \item FIXME: per indicare sezioni di codice che necessitano di revisione e miglioramenti;
        \end{itemize}
\end{itemize}
\subsubsubsubsection{Formattazione del codice}
Per la formattazione del codice Python sono state adottate le convenzioni indicate dal formatter PEP8 (\url{https://peps.python.org/pep-0008/}).
Il rispetto della formattazione sopraindicata è garantito dallo strumento di formattazione incluso nell'estensione per il liguaggio Python di VSCode fornita da Microsoft (\url{https://marketplace.visualstudio.com/items?itemName=ms-python.python})
\subsubsubsubsection{Convenzioni sintattiche}
\begin{itemize}
    \item \textbf{Nomi autoesplicativi}: i nomi assegnati a qualsiasi costrutto devono essere autoesplicativi, cioè devono racchiudere il significato di ciò a cui si riferiscono;
    preferire nomi lunghi ma privi di ambiguità a nomi corti ma interpretabili;
    \item \textbf{Lingua}: usare la lingua inglese per i nomi dei costrutti e per i commenti;
    \item \textbf{Convenzioni di nomenclatura}: seguire le convenzioni di nomenclatura PEP 8;
    \item \textbf{Abbreviazioni}: usare cautelamente le abbreviazioni, solo se queste sono comunemente conosciute;
    \item \textbf{Nomi classi}: i nomi delle classi devono seguire lo stile PascalCase;
    \item \textbf{Nomi metodi e variabili}: i nomi dei metodi e delle variabili devono seguire lo stile snake\_case;
    \item \textbf{Nomi costanti}: i nomi delle costanti devono seguire lo stile UPPER\_ SNAKE\_CASE;
    \item \textbf{Nomi argomenti}: usare lo stesso nome per gli argomenti del costruttore e i rispettivi attributi della classe;
    \item \textbf{Indentazione}: utilizzare quattro spazi o un carattere di tabulazione per definire i blocchi di codice;
    \item \textbf{Spaziatura}: utilizzare uno spazio attorno agli operatori binari per una migliore leggibilità;
    \item \textbf{Parentesi}: aggiungere lo spazio prima e dopo un blocco raccolto tra parentesi;
    \item \textbf{Commenti}: utilizzare il simbolo \texttt{\#} per i commenti;
    \item \textbf{Quoting}: utilizzare singoli (\texttt{'}) apici per le stringhe;
    \item \textbf{Definizioni di funzioni e metodi}: separare le definizioni di funzioni e metodi con due linee vuote;
    \item \textbf{Lunghezza massima della linea}: limitare le linee a un massimo di 79 caratteri per il codice e 72 per docstrings;
    \item \textbf{Più istruzioni su una linea}: evitare più istruzioni sulla stessa linea;
\end{itemize}

\subsubsubsection{Stile di codifica: Javascript (React)}
\subsubsubsubsection{Struttura dei file} La struttura di un sorgente Javascript è definita dalle seguenti parti:
\begin{itemize}
    \item Import: insieme di istruzioni di import che seguono l'ordine:
    \begin{enumerate}
        \item Dipendenze esterne;
        \item Dipendenze interne.
    \end{enumerate}
    \item Funzioni: definiscono un componente o funzioni di utilità;
\end{itemize}
\subsubsubsubsection{Struttura dei componenti} La struttura di un componente React è definita dalle seguenti parti, se necessarie:
\begin{enumerate}
    \item \textbf{Arrow function}: definisce il componente;
    \item \textbf{Funzioni ausiliarie}: funzioni di supporto che aiutano a gestire casi complessi e aumentano il riuso;
    \item \textbf{Logica del componente}: definisce la struttura e il comportamento del componente;
    \item \textbf{Export}: istruzione di export che rende disponibile il componente all'utilizzo esterno.
\end{enumerate}
Ogni classe deve essere opportunamente documentata, seguendo il formato \textit{JSDoc}; in particolare:
\begin{itemize}
    \item Dopo la definizione del componente, devono essere presenti, in una serie di commenti:
    \begin{itemize}
        \item Descrizione del ruolo della classe;
        \item Lista dei props, seguiti da una breve descrizione;
        \item Lista dei metodi della classe, seguiti da una breve descrizione.
    \end{itemize}
    \item Dopo la definizione dei metodi, devono essere presenti, in una serie di commenti:
    \begin{itemize}
        \item Descrizione del metodo;
        \item Lista di argomenti del metodo, seguiti da una breve descrizione;
        \item Lista degli eventuali return, seguiti da una breve descrizione.
    \end{itemize}
\end{itemize}
\subsubsubsubsection{Pratiche di programmazione}
\begin{itemize}
    \item \textbf{Grandezza componenti}: prediligere l'uso e la creazione di componenti di taglia e responsabilità limitata. Un componente dovrebbe limitarsi a svolgere un'unica funzione;
    \item \textbf{Riutilizzo}: sfruttare il più possibile il riutilizzo dei componenti. Se due componenti hanno la stessa struttura ma si differenziano per aspetto o comportamento, usare i props per gestire queste differenze;
    \item \textbf{Funzioni di utilità}: evitare di posizionare le funzioni di utilità all'interno di componenti, ma raccoglierle in classi specifiche e mirate;
    \item \textbf{Unico component per file}: esportare un unico component per file;
    \item \textbf{Metodi iterativi}: quando si vogliono eseguire operazioni su ogni elemento di un oggetto iterabile, prediligere l'uso di metodi iterativi;
    \item \textbf{Organizzazione file}: organizzare i file dello stesso component in una apposita cartella;
    \item \textbf{Commenti}: usare le seguenti convenzioni nei commenti:
        \begin{itemize}
            \item TODO: per indicare sezioni di codice non ancora completate;
            \item FIXME: per indicare sezioni di codice che necessitano di revisione e miglioramenti;
        \end{itemize}
\end{itemize}
\subsubsubsubsection{Formattazione del codice} Per la formattazione del codice Javascript sono state adottate le convenzioni indicate dall'estensione Prettier di VSCode (\url{https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode}).
Per garantire il rispetto delle convenzioni di Prettier, tutti i componenti del gruppo hanno impostato il formatter Prettier di default e impostato il suo intervento correttivo ad ogni salvataggio dei file.

\subsubsubsubsection{Convenzioni sintattiche}
\begin{itemize}
    \item \textbf{Nomi autoesplicativi}: i nomi assegnati a qualsiasi costrutto devono essere autoesplicativi, cioè devono racchiudere il significato di ciò a cui si riferiscono;
        preferire nomi lunghi ma privi di ambiguità a nomi corti ma interpretabili;
    \item \textbf{Lingua}: usare la lingua inglese per i nomi dei costrutti e per i commenti;
    \item \textbf{Abbreviazioni}: usare cautelamente le abbreviazioni, solo se queste sono comunemente conosciute;
    \item \textbf{Indentazione}: utilizzare quattro spazi o un carattere di tabulazione per definire i blocchi di codice;
    \item \textbf{Spaziatura}: utilizzare uno spazio attorno agli operatori binari per una migliore leggibilità;
    \item \textbf{Parentesi}: aggiungere lo spazio prima e dopo un blocco raccolto tra parentesi;
    \item \textbf{Quoting}: utilizzare singoli (\texttt{'}) apici per le stringhe;
    \item \textbf{Più istruzioni su una linea}: evitare più istruzioni sulla stessa linea;
    \item \textbf{Punto e virgola}: aggiungere sempre il simbolo ';' alla fine di ogni statement;
    \item \textbf{Nomi componenti}: i nomi dei componenti devono seguire lo stile PascalCase;
    \item \textbf{Nomi file componenti}: i nomi dei file che contengono un componente devono essere uguali al nome del componente;
    \item \textbf{Nomi css componenti}: i nomi dei fogli di stile riferiti ad un unico componente devono essere uguali al nome del componente, ma scritti in camelCase;
    \item \textbf{Nomi cartelle componenti}: i nomi delle cartelle che contentengono un componente devono essere uguali al nome del componente, ma scritti in camelCase;
    \item \textbf{Nomi file ausiliari}: i nomi dei file ausiliari devono seguire lo stile camelCase;
    \item \textbf{Nomi metodi e variabili}: i nomi dei componenti devono seguire lo stile camelCase;
    \item \textbf{Nomi costanti}: i nomi delle costanti devono seguire lo stile UPPER\_SNAKE\_CASE;
    \end{itemize}

\subsubsubsection{Stile di codifica: HTML e CSS}
Per lo stile di codifica dei linguaggi HTML e CSS è stato seguito il modello indicato al seguente
indirizzo: \url{https://google.github.io/styleguide/htmlcssguide.html}.

\subsubsection{Testing}
Tale sezione sarà realizzata a seguito della versione v2.0.0 delle (\S Norme di progetto).

\subsubsection{Integrazione software}
Tale sezione sarà realizzata a seguito della versione v2.0.0 delle (\S Norme di progetto).

\subsubsection{Installazione software}
Tale sezione sarà realizzata a seguito della versione v2.0.0 delle (\S Norme di progetto).

% PROCESSI DI SUPPORTO
\newpage

\section{Processi di supporto}
Nella seguente sezione vengono presentati i processi di supporto allo sviluppo del progetto.

\subsection{Documentazione}
Tutte le attività di sviluppo sono accompagnate da una loro documentazione, con l'obiettivo di permettere una consultazione semplice e 
rapida alle informazioni inerenti al prodotto e alle attività stesse, svolgendo inoltre un ruolo di storicizzazione e di supporto alla 
manutenzione.

\subsubsection{Implementazione del processo}
In questa sezione viene documentato e implementato un piano che identifica i documenti da produrre durante il ciclo di vita del prodotto 
software. Tutti i documenti da redigere vengono presentati nella tabella che segue. Vengono inclusi solamente i documenti relativi al vero e
 proprio ciclo di vita del prodotto software e sono di conseguenza esclusi i documenti presentati per la candidatura per il progetto 
 didattico, quali "Lettera di presentazione", "Preventivo costi e impegni orari" e "Valutazione dei capitolati d'appalto".

{\renewcommand{\arraystretch}{1.5}
  \begin{xltabular}{\textwidth}{X|X|X|X|X}
    \textbf{Nome del documento} & \textbf{Scopo}  & \textbf{Redattore} &  \textbf{Destinatari} & \textbf{Consegne previste} \\
    
    \hline
    Analisi dei requisiti & Definizione requisiti utente & Analista & Azienda proponente, Docenti & RTB, PB\\
    \hline
    Norme di progetto & Definizione regolamento normativo per il team & Responsabile, Amministratore & Docenti & RTB, PB\\
    \hline
    Piano di progetto & Definizione temporale scadenze e progressi & Responsabile & Docenti & RTB, PB\\
    \hline
    Piano di qualifica & Definizione qualità e testing del prodotto finale & Amministratore & Docenti & RTB, PB\\
    \hline
    Verbali esterni & Tracciamento riunioni esterne & Responsabile & Azienda proponente, Docenti & Candidatura, RTB, PB\\
    \hline
    Verbali interni & Tracciamento riunioni interne & Responsabile & Docenti & Candidatura, RTB, PB\\

\end{xltabular}}

\subsubsection{Progettazione e sviluppo}
In questa sezione vengono presentati gli standard e le regole (nello specifico di stile) a cui i membri di SWEetCode si attengono 
relativamente alla stesura di documenti relativi al progetto. 
    
    \paragraph{Template}
    Il team ha deciso di produrre un template grafico ricorrente all'interno della documentazione.\\
    Ogni documento presenta la medesima pagina di copertina, con una grafica realizzata tramite \textit{Adobe Illustrator} ed in seguito 
    disposta nella pagina tramite \textit{Overleaf}, dove viene esposto il nostro logo, il nostro nome del team e i membri del team.\\
    Le seguenti pagine di ciascun documento presentano un:
        \begin{itemize}
            \item \textbf{\textit{Header}}: intestazione contenente il nostro logo, il nome del documento ed il nostro nome;
            \item \textbf{\textit{Footer}}: piè di pagina contenente i link alla nostra email e al nostro account \href{https://sweetcode-team.github.io/}{\textcolor{black}{\textit{GitHub}}}; 
            ed infine la numerazione di pagina.
        \end{itemize}

    \paragraph{Parametrizzazione template} Per facilitare e velocizzare la procedura di inserimento dei dati all'interno dei documenti prodotti con 
    il linguaggio di marcatura \textit{Latex}, il gruppo ha deciso di creare dei template parametrizzati, sfruttando l'uso di comandi già 
    presenti nel linguaggio, come \textit{$\backslash$def} e \textit{$\backslash$newcommand}, e l'uso di librerie esterne, come 
    \textit{ifthen} e \textit{forloop}.
    Considerando i valori dei parametri, durante la fase di compilazione la struttura dei documenti si adatterà in modo dinamico, assumendo 
    l'aspetto del tipo di documento indicato, ad esempio verbale interno, esterno o altri tipi di documenti più discorsivi. L'adozione di 
    questa pratica permette al team di mantenere coerenti struttura, formato del contenuto e presentazione, aumentando il throughput e 
    consentendo ai componenti del gruppo di concentrarsi più sul contenuto che sulla sua visualizzazione.
    
    Di seguito vengono elencati i parametri utilizzati a seconda del tipo di documento:
    \begin{itemize}
        \item Titolo;
        \item Data;
        \item Orario inizio / fine;
        \item Luogo;
        \item Tipo di verbale (esterno o interno);
        \item Nome di responsabile, verificatore, segretario ed eventuale azienda;
        \item Firma di responsabile ed eventuale azienda;
        \item Lista dei partecipanti (interni e esterni);
        \item Lista revisione delle azioni;
        \item Lista ordine del giorno;
        \item Lista discussione (interna o esterna);
        \item Lista decisioni.
    \end{itemize}
    
    \paragraph{Struttura di documento}
    Tutti i documenti prodotti da SWEetCode presentano una struttura comune:
    \begin{itemize}
        \item \textbf{Pagina di copertina}: descritta nella sezione Template precedente;
        \item \textbf{Registro delle versioni}: presente in tutti i documenti ad eccezione dei verbali. Questo registro utilizzato per 
        tenere traccia delle varie versioni permette di comprendere in modo rapido chi ha realizzato determinate sezioni della 
        documentazione, quando sono state realizzate, cosa è stato aggiunto e perché (sotto la voce "Dettaglio e motivazioni"). Il registro 
        presenta le versioni ordinate a partire dalla versione più recente; 
        \item \textbf{Indice}: presente nel caso in cui si abbia un documento di notevole dimensione, dotato di sezioni. Il suo obiettivo è 
        quello di facilitare e agevolare l'accesso ad un determinato contenuto trattato nel documento;
        \item \textbf{Contenuto}: il contenuto vero e proprio del documento.
    \end{itemize}
    
    \paragraph{Verbali}Fanno eccezione alla struttura precedentemente esposta i verbali, sia esterni che interni. Essi infatti oltre a 
    presentare nella prima pagina di copertina i ruoli inerenti alla loro produzione (al posto dell'elenco dei membri del team) ed una 
    sezione apposita per la firma del responsabile di riunione (e in caso di verbale esterno anche la firma da parte di un rappresentate 
    dell'azienda), offrono una struttura particolare.\\
    Il loro contenuto presenta le seguenti sezioni:
    \begin{itemize}
        \item \textbf{Intestazione}: sezione contenente le informazioni inerenti a data, ora e luogo della riunione;
        \item \textbf{Partecipanti}: sezione contenente l'elenco in ordine alfabetico dei partecipanti interni ed eventualmente esterni 
        alla riunione e una voce apposita per gli assenti;
        \item \textbf{Revisione delle azioni}: sezione contenente un elenco cronologico delle azioni assegnate nelle riunioni precedenti, 
        con informazioni in merito al progresso, problematiche riscontrate ed eventuale conclusione di tale azione;
        \item \textbf{Ordine del giorno}: elenco cronologico e approssimativo delle tematiche trattate all'interno della riunione;
        \item \textbf{Discussione}: sezione contente l'elenco cronologico delle tematiche affrontate, trattate con una descrizione accurata 
        delle informazioni emerse;
        \item \textbf{Decisioni}: decisioni prossime e/o future da intraprendere o intraprese a seguito della riunione affrontata;
        \item \textbf{Azioni da intraprendere}: tabella contente le azioni assegnate durante l'incontro e da svolgere nel futuro immediato. 
        Ogni voce è accompagnata dal numero del \textit{ticket} associato (se presente) nell'ITS su \textit{Jira}, un incaricato, da un 
        revisore che dovrà verificare il suo operato e da una data di scadenza entro la quale l'azione da svolgere dovrà essere ritenuta 
        completata;
        \item \textbf{Altro}: sezione contente informazioni aggiuntive quali riferimenti esterni e la data della prossima riunione 
        (nel caso in cui essa sia stata stabilita).
    \end{itemize}    
    
    \paragraph{Posta elettronica}La posta elettronica rappresenta uno strumento fondamentale di comunicazione asincrona con proponenti e 
    committente.\\ 
    Per uniformare lo stile delle mail, vengono descritti di seguito delle norme a cui attenersi nella loro stesura:
    \begin{itemize}
        \item \textbf{Oggetto}: campo da riempire obbligatoriamente in maniera breve e concisa;
        \item \textbf{Firma}: ogni mail viene conclusa con la firma digitale del gruppo collocata automaticamente;
        \item \textbf{Forma}: le informazioni e le richieste più importanti vanno posizionate all'inizio del messaggio. La lunghezza del 
        testo della mail non deve essere eccessivo, onde evitare la perdita di visibilità di informazioni preziose; qualora fosse necessario un testo complesso e denso di informazioni, ci si deve servire dell'uso di paragrafi ed elenchi per strutturarlo;
        \item \textbf{Stile}: è buona norma seguire lo stile del mittente. La mail sarà dotata di formule di saluto iniziale e finale quali 
        ad esempio: "\textit{Gentile..}", "\textit{Spettabile..}", "\textit{Cordiali saluti}" e "\textit{Distinti saluti}".
    \end{itemize}
    
    \paragraph{Norme tipografiche}
    \begin{itemize}

        \item {\textbf{Citazioni tecnologiche e strumentali}}: Ogni tecnologia e/o strumento menzionato all'interno della documentazione 
        deve essere scritta in \textit{corsivo}.
        
        \item {\textbf{Date}}: Tutte le date presenti nella documentazione prevedono il seguente formato: AAAA-MM-GG.
        
        \item {\textbf{Elenchi}}: Tutti gli elenchi presenti nella documentazione prevedono un ordine:
            \begin{itemize}
                \item \textbf{Alfabetico}: sono puntati e non presentano alcuna correlazione con l'aspetto temporale;
                \item \textbf{Cronologico}: sono  numerati e descrivono una serie di eventi o argomenti ordinati nel tempo.
            \end{itemize}
        In tutti gli elenchi ogni punto termina con il ";", fatta eccezione per l'ultimo elemento che termina con il ".".
        
        \item {\textbf{Menzioni}}: Ogni menzione di una persona, interna od esterna al team, avviene nel seguente formato: Cognome N. 
        (dove la lettera N sta per l'iniziale del nome).
        

        \item {\textbf{Nome del documento}}: I nomi dei documenti prevedono la lettera iniziale maiuscola seguiti dal resto dei caratteri 
        in case minuscolo e dalla versione del documento stesso.\\
        I verbali, sia interni che esterni, fanno eccezione e presentano un titolo composta dalla data in cui sono stati svolti nel 
        seguente formato: AAAA-MM-GG.

        \item {\textbf{Riferimenti interni}}: Menzioni e riferimenti a sezioni interne allo stesso documento a cui appartengono vengono 
        riportate seguendo la notazione (\S Nome sezione). Questi riferimenti saranno opportunamente collegati tramite link al paragrafo 
        indicato.
        
        \item {\textbf{Riferimenti esterni}}: Menzioni e riferimenti a sezioni di documenti esterni vengono riportate seguendo la notazione 
        (Nome documento, \S Nome sezione)

        \item{\textbf{Nome del gruppo}}: Il nome del gruppo presenta il seguente formato: "SWEetCode".

        \item{\textbf{Stile tipografico}}: La formattazione del testo dei documenti segue rigorosamente un unico stile tipografico: 
        \textit{Poppins}.
        
        \item {\textbf{Versioni}}: Ogni documento viene associato nel nostro \href{https://sweetcode-team.github.io/}{sito GitHub} alla 
        versione del progetto per cui risulta essere ancora in vigore.\\
        All'interno del documento, nella prima riga del registro delle versioni, viene invece presentata la versione del progetto in cui è 
        avvenuta l'ultima modifica al documento.\\
        L'incremento della versione del progetto a seguito di elaborazioni nella documentazione viene gestito attraverso la seguente norma: 
        l'aggiunta di documentazione non precedentemente presente all'interno del repository o la modifica della documentazione 
        precedentemente presente all'interno del repository porta all'incremento del solo valore "(build)".
        \end{itemize}

\subsubsection{Produzione}
\label{sec:ciclo_vita}
La produzione di ogni documento redatto da SWEetCode presenta le seguenti fasi:
\begin{enumerate}
    \item \textbf{Assegnazione}: Il documento viene assegnato ad uno o più responsabili di stesura affiancati a loro volta da uno o più revisori.
    Una volta presa la decisione per i precedenti ruoli viene aperto su \textit{Jira} un task a loro associato, relativo alla  realizzazione del 
    documento, il quale viene immediatamente inserita all'interno di una epic e ad una versione. 
    \item \textbf{Stesura}: La stesura viene realizzata dal segretario di riunione (nel caso in cui il documento in questione sia un verbale 
    interno o esterno) o dai responsabili di stesura.
    La produzione della documentazione in formato \textit{Latex} viene gestita tramite la condivisione dei sorgenti attraverso \textit{GitHub}. 
    Una volta che la stesura viene ritenuta stabile, tramite l'automazione descritta in (Norme di progetto, automazione versionamento documenti), 
    viene creata una \textit{pull request} nel repository \href{https://github.com/sweetcode-team/Knowledge_Management_AI}{\textcolor{black}{\textit{Knowledge\_Management\_AI}}} 
    su \textit{GitHub};
    \item \textbf{Verifica e Validazione}: La fase di verifica viene realizzata dal revisore del documento: in questo stadio il documento viene 
    sottoposto ad un controllo di contenuto e sintassi, tenendo conto delle linee guida definite dal team nelle (Norme di progetto, \S Documenti). 
    Se il documento è di tipo esterno, una volta passata la verifica da parte del revisore, l'atto viene condiviso con l'ente terzo in causa, 
    per essere sottoposto ad una sua ulteriore verifica e validazione.
    In caso di esito positivo la \textit{pull request} viene risolta mentre, in caso di esito negativo, essa viene rifiutata e si ritorna alla 
    fase precedente, in modo da produrre una documentazione che tiene conto delle correzioni e precisazioni presentate dal revisore e/o 
    dall'eventuale parte esterna;
    \item \textbf{Pubblicazione}: La pubblicazione costituisce l'ultima fase del ciclo di vita del documento e avviene solamente nel caso in cui 
    la fase di verifica abbia avuto un riscontro positivo: una volta risolta la \textit{pull request} il documento troverà infatti collocazione 
    all'interno del repository \href{https://github.com/sweetcode-team/Knowledge_Management_AI}{\textcolor{black}{\textit{Knowledge\_Management\_AI}}} 
    del team su \textit{GitHub}. In questo modo il repository contiene solamente documenti verificati ed eventualmente validati.
\end{enumerate}

\subsubsection{Manutenzione}
Il processo di manutenzione della documentazione è fondamentale per garantire che la stessa rimanga accurata, aggiornata ed utile nel corso del ciclo di vita del progetto. Tale processo è integrato in modo continuo in base ai progressi svolti. Il team segue le seguenti fasi per il processo di manutenzione:
\begin{itemize}
    \item \textbf{Identificazione della necessità della modifica}: Monitoraggio continuo delle esigenze di modifica della documentazione e 
    comunicazione al team della necessità di una possibile modifica;
    \item \textbf{Valutazione dell'impatto}: Discussione tra i membri che ricoprono i ruoli interessati alla modifica per valutarne l'impatto 
    sulla documentazione già esistente. Tale discussione coinvolge tutto il team se necssario;
    \item \textbf{Aggiornamento della documentazione}: Modifica e aggiornamento del documento interessato secondo le esigenze identificate, e 
    verifica dell'accuratezza delle informazioni e dell'allineamento con le  modifiche del progetto relative;
    \item \textbf{Push della modifica}: Una volta che la stesura della modifica viene ritenuta stabile, tramite l'automazione descritta in 
    (Norme di progetto, \S automazione versionamento documenti),
    viene creata una pull request nel repository \href{https://github.com/sweetcode-team/Knowledge_Management_AI}{\textcolor{black}{\textit{Knowledge\_Management\_AI}}} 
    su \textit{GitHub} per la nuova versione del documento da parte di chi ha operato la modifica;
    \item \textbf{Verifica e validazione}: A seguito della creazione della pull request, le modifiche apportate ai documenti sono sottoposte a
    verifica eseguita da parte del verificatore. Se tale operazione ha esito positivo, se necessario, il documento viene posto ad ulteriore validazione
    con l'ente esterno in questione.
    Se sia la verifica che la eventuale validazione hanno avuto esito positivo, le modifiche vengono pubblicate attraverso l'accettazione della 
    pull request da parte del revisore, in caso invece di esito negativo in anche una delle due operazioni, la pull request viene rifiutata e colui 
    che aveva realizzato le modifiche è responsabile di applicare le correzzioni emerse, ripetendo i passi precedentemente descritti.
\end{itemize}

\subsection{Configuration management}

\subsubsection{Scopo}
Nella seguente sezione vengono presentate le attività svolte dal gruppo SWEetCode che rientrano all'interno del processo "configuration management".

\subsubsection{Descrizione}
Il processo di configuration management è un processo di applicazione di procedure amministrative e tecniche lungo l'intero ciclo di vita del software al fine di:
\begin{itemize}
    \item Identificare, definire e stabilire una base per gli elementi software in un sistema;
    \item Controllare le modifiche e le release degli elementi;
    \item Registrare e riportare lo stato degli elementi e delle richieste di modifica;
    \item Garantire la completezza, la coerenza e la correttezza degli elementi.
\end{itemize}

\subsubsection{Configuration control}
\paragraph{Scopo}
L'attività di configuration control si pone i seguenti obiettivi:
\begin{itemize}
    \item Identificare e registrare le richieste di modifica;
    \item Analizzare e valutare le modifiche;
    \item Approvare o rifiutare le richieste di modifica;
    \item Tracciamento di audit.
\end{itemize}

\paragraph{Issue tracking system (ITS)} 
Per raggiungere l'obiettivo di tracciamento di audit, ovvero la registrazione sistematica e dettagliata dei task e delle modifiche, SWEetCode utilizza 
l'\textit{Issue Tracking System Jira} fornito da \textit{Atlassian}: \textit{Jira}.
\subparagraph{Ticket}
In questo sistema di tracciamento si permette la creazione di \textit{ticket} che possono essere di tre tipi:
\begin{itemize}
    \item \textit{task}: tale tipo di ticket viene utilizzato dal team per assegnate compiti atomici ai vari membri del gruppo;
    \item \textit{bug}: tale tipo di ticket viene utilizzato dal team per assegnare un compito di fix di un bug all'interno del progetto ad un membro del gruppo; 
    \item \textit{story}: tale tipo di ticket viene utilizzato per rappresentare un requisito.
\end{itemize}
Ciascun \textit{ticket} presenta (di seguito sono riportate le sole funzionalità utilizzate dal team):
\begin{itemize}
    \item Titolo: un titolo breve ma esplicativo del compito associato al \textit{ticket};
    \item Id numerico univoco: tale id viene generato in automatico dall'ITS nella forma \textit{SWE-ID};
    \item \textit{epic}: ogni \textit{ticket} può essere infatti associato ad una \textit{epic};
    \item Collegamento: \textit{Jira} mette a disposizione una funzionalità di collegamento per stabilire le dipendenze tra i vari \textit{ticket};
    \item Assegnatario: il membro del team che a cui è stata affidata la responsabilità di svolgere il \textit{ticket};
    \item Descrizione: una breve descrizione inerente al \textit{ticket} associata;
    \item Data: la data di creazione del \textit{ticket};
    \item Reporter: il membro del team che ha creato il \textit{ticket};
    \item Sviluppo: voce contenente il link ai commit, alle pull request e alle build che sono stati effettuati nel repo su \textit{GitHub} in correlazione al \textit{ticket} in questione;
    \item Stato: gli stati possibili di un \textit{ticket} sono \textit{Da fare}, \textit{In Progress}, \textit{Pronto per commit} (introdotto dagli amministratori di SWEetCode nel flusso di lavoro) ed infine \textit{Completato};
    \item \textit{Sprint}: ogni \textit{ticket} può essere associato ad uno \textit{sprint};
    \item \textit{Versione} di correlazione: ogni \textit{ticket} può essere associata ad una determinata \textit{versione}.
\end{itemize}

\subparagraph{Epic}
Un insieme di \textit{ticket} può essere raggruppato all'interno di una \textit{epic}: una \textit{epic} costituisce un'unità 
logica e strategica di lavoro più ampia, rappresentando un obiettivo o un risultato di alto livello. Questo strumento di lavoro offre
al team una panoramica di completamento generale di un particolare insieme di azioni correlate tra loro, attraverso una 
scoreboard che indica la percentuale di \textit{ticket} completati, in progresso o ancora da iniziare.
Oltre ai \textit{ticket} associati, ogni \textit{versione} presenta i medesimi field di un \textit{ticket} precedentemente descritti.

\subparagraph{Versioni}
Per rappresentare le milestone su \textit{Jira} vengono utilizzate le \textit{Versioni}, alle quali possono essere associate \textit{epic}
e i relativi \textit{ticket}, riportando come nelle \textit{epic} una scoreboard che indica la percentuale di \textit{ticket} completati, in progresso o ancora da iniziare.
Una volta che tutti i \textit{ticket} associati alla \textit{versione} sono stati completati, tale \textit{versione} può essere rilasciata.
Oltre ai \textit{ticket} associati, ogni \textit{versione} presenta una breve descrizione, una data di inizio ed una di fine.

\subparagraph{Backlog e Sprint}
\textit{Jira} offre all'interno dell'\textit{ITS} differenti funzionalità di supporto al metodo agile, seguendo il framework Scrum, in particolare
quando i \textit{ticket} vengono creati sono inseriti di default all'interno del \textit{Backlog} per essere in seguito
assegnati ai vari \textit{Sprint}. 
Ciascun \textit{Sprint} è caratterizzato da una data di inizio ed una di fine e da uno stato (\textit{Attivato/Chiuso}).

\subparagraph{Timeline}
\textit{Jira} mette a disposizione come strumento una \textit{timeline} realizzata attraverso un diagramma di Gantt all'interno del quale poter inserire i \textit{ticket}
creati associati ad una \textit{epic}.\\
Ciascun \textit{ticket} può dunque essere disposto in uno spazio temporale, facendo riferimento ad una data di inizio ed una di fine, costituendo il periodo
all'interno del quale portare a termine il compito associato. Tra i vari \textit{ticket} è inoltre possibile creare collegamenti che rappresentano graficamente 
le dipendenze presenti tra essi.\\
Ogni \textit{versione} viene rappresentata all'interno della \textit{timeline} da una linea verticale posta in corrispondenza della data di scadenza
della versione stessa.\\
Nella parte superiore della \textit{timeline} sono inoltre visualizzati i vari \textit{Sprint} presenti all'interno dell'ITS, visualizzando in opaco quelli chiusi.\\
Internamente alla \textit{timeline} è inoltre resa disponibile una ulteriore funzionalità di filtraggio dei \textit{ticket} visualizzati in base alle \textit{versioni} e/o alle \textit{epic},
permettendo di effettuare una istantanea.

\subparagraph{Automazione chiusura ticket} \textit{Jira} mette a disposizione una funzionalità di creazione di automazioni (chiamate \textit{Trigger}) configurabili dell'utente, permettendo di adattare al meglio ciascuna esigenza.
Il team ha deciso di introdurre un'automazione di chiusura automatica dei ticket presenti all'interno dell'\textit{ITS}: ogni volta che un membro del team 
effettua un commit nel repository finalizzato alla chiusura di un \textit{ticket}, il contenuto di tale commit, grazie all'esecuzione di uno script Python creato dal team (Norme di progetto, \S 3.2.2 Automazione versionamento documenti)
presenterà al suo interno l'operazione "\textit{SWE-\#id\_ticket}".\\
A seguito dell'approvazione della pull request da parte del verificatore, il \textit{ticket} associato a quel particolare \textit{ID} passerà in automatico
allo stato \textit{Completato}.

\paragraph{Pull requests} 
\label{sec:pull_request}
A seguito dell'adozione dei \textit{GitHub Teams}, SWEetCode propone l'utilizzo delle pull requests per permettere un rilascio controllato che permetta di analizzare 
e valutare le richieste di modifica effettuate: l'unico \textit{Team} dotato dei permessi necessari all'approvazione di una pull request sono i \textit{Verificatori}.\\
Una volta proposta la pull request il verificatore attuale del progetto, membro del \textit{Team Verificatori}, dovrà effettuare una verifica sulle modifiche proposte e,
a seguito delle sue valutazioni, dovrà decidere se declinare o accettare la pull request, con conseguente merge nel branch all'interno del quale la pull request è stata 
sollevata in caso di esito positivo.
Tali responsabilità vengono definite tramite l'utilizzo di \textit{Branch Protection Rules} offerte da \textit{GitHub}.
L'identificazione attraverso un titolo fornito da colui che solleva la pull request e la registrazione delle richieste di modifica e del loro esito è una conseguenza
dell'applicazione della pratica delle pull request offerta da \textit{GitHub}.

\paragraph{GitHub Teams}
SWEetCode, attraverso un profilo \textit{Organizations}, ha deciso di utilizzare una struttura interna ai membri del gruppo che usufruisce dei \textit{Teams} di 
\textit{GitHub}: ogni ruolo presente all'interno del progetto porta alla creazione di un \textit{Team} avente il medesimo nome.\\
I \textit{Teams} presentati sono dunque:
\begin{itemize}
    \item Amministratori;
    \item Analisti;
    \item Progettisti;
    \item Programmatori;
    \item Responsabili;
    \item Verificatori.
\end{itemize}
Lo strumento \textit{Teams} consente di gestire i vari ruoli nel migliore dei modi, permettendo di assegnare responsabilità e permessi specifici a determinate posizioni 
piuttosto che ai membri del gruppo. Questa mansione altrimenti risulterebbe dispendiosa e disagevole a causa della rotazione dinamica interna dei ruoli. 

\subsubsection{Configuration status accounting}
\paragraph{Scopo}
L'obiettivo che si pone il configuration status accounting è quello di mantenere una registrazione accurata e aggiornata del prodotto software e dei suoi elementi in
relazione allo stato del prodotto stesso nel corso del tempo.

\paragraph{Version control}
\label{sec:version}
Per tenere traccia dello stato e della storia degli elementi controllati, il team ha deciso di utilizzare un sistema di \textit{Version control} basato su una versione 
del prodotto che si attiene al seguente formato: vX.Y.Z(build).
\begin{itemize}
    \item v: sta per versione, rimane immutato lungo tutte le versioni;
    \item X: numero che indica la versione principale di riferimento. Viene incrementato quando viene superata una fase di revisione di avanzamento;
    \item Y: numero che viene incrementato con l'introduzione di nuove features o di miglioramenti significativi;
    \item Z:  numero che indica piccoli cambiamenti rispetto alla versione vX.Y, come il fix di bug o il caricamento di nuovi documenti all'interno del repository (ad esclusione di verbali, sia interni che esterni);
    \item (build): numero che indica le build di progetto eseguite nella versione vX.Y.Z. Tale valore viene incrementato a seguito di modifiche/aggiunte nella documentazione.
\end{itemize}
Il sistema di numerazione delle versioni ha come prima versione il valore "v0.0.1(0)".\\
Ogni volta che viene incrementato il valore X, i valori Y, Z e (build) ripartono dai loro valori iniziali, ovvero "0".\\
Ogni volta che viene incrementato il valore Y, il valore Z e (build) ripartono dal valore ”0”.\\
Ogni volta che viene incrementato il valore Z, il valore (build) riparte dal valore "0".

\subsubsection{Configuration evaluation}
\paragraph{Scopo}
L'attività di configuration evaluation si pone l'obiettivo di garantire la completezza funzionale degli elementi software realizzati rispetto ai loro
requisiti.

\paragraph{Tracciamento dei requisiti}
Per raggiungere l'obiettivo precedentemente citato, il team SWEetCode ha deciso di effettuare un tracciamento dei requisiti all'interno del prodotto software,
in modo da portare nel concreto l'evidenza della correlazione tra requisiti e codice.\\
Per effettuare il tracciamento il team apporta un commento, contenente l'identificativo del requisito, antecedente alla parte di codice che porta al soddisfacimento
del requisito menzionato.

\subsubsection{Release management}
\paragraph{Scopo}
L'attività di release management si occupa di effettuare un rilascio controllato.

\paragraph{Automazione release}
L'automazione del versionamento consente di rilasciare nuove release in modo automatico, seguendo le regole di
cambio versione indicate in (Norme di progetto, \S \nameref{sec:version}). Attraverso l'uso delle \textit{GitHub Actions}, l'accettazione di una pull request, 
eseguita seguendo le norme indicate nel paragrafo (Norme di progetto, \S \nameref{sec:pull_request}), è immediatamente seguita dalla pubblicazione della nuova versione.
Il tipo di cambio versione viene indicato dal prefisso del titolo della Pull Request.

Questa automazione si integra in modo efficace con quella citata nel paragrafo (Norme di progetto, \S \nameref{sec:automazione_docs}).
Ciò che separa l'esecuzione consecutiva delle due automazioni è la creazione della pull request e la sua accettazione.

La richiesta dell'intervento umano, in questo caso, non è un fattore limitante, ma rappresenta due ulteriori fasi di
verifica, che garantiscono la pulizia del repository remota e la correttezza del suo contenuto.

\paragraph{Automazione versionamento documenti}
\label{sec:automazione_docs}
L'aggiornamento del registro delle versioni, la creazione dei pdf e la pubblicazione delle modifiche nella repository remota avvengono in modo consecutivo e automatico grazie all'esecuzione di uno script Python creato dal team.
Questo script richiede inizialmente l'inserimento di alcuni input riguardanti le modifiche, compresa l'eventuale chiusura del \textit{ticket} soddisfatto, e dopo una fase di elaborazione
in cui aggiorna il registro delle versioni e crea il pdf usando il programma \textit{Latexmk}, esegue il push in remoto dei cambiamenti introdotti in locale.

Il componente del gruppo che ha eseguito lo script dovrà semplicemente recarsi nel
sito web della repository su GitHub e creare la Pull Request.
Questa verrà successivamente analizzata e accettata o rifiutata in base ai criteri descritti nel (Piano di qualifica) e
secondo le modalità citate nel paragrafo (\S \nameref{sec:ciclo_vita}).

L'utilizzo di questa automazione permette di ridurre gli errori legati all'aggiornamento e alla pubblicazione di nuove
versioni dei documenti, e riduce notevolmente il carico di lavoro assegnato ai componenti del gruppo, limitando
volutamente le loro azioni alla sola modifica del contenuto della documentazione.

\subsection{Assicurazione della qualità}
\subsubsection{Scopo}
Lo scopo di questo processo è fornire un'adeguata garanzia che i prodotti software e i processi nel ciclo di vita del progetto sono conformi ai requisiti specificati e aderiscono ai loro piani stabiliti.
Per essere imparziale, deve avere libertà organizzativa e autorità da parte delle persone direttamente responsabili dello sviluppo del prodotto software.
L'assicurazione della qualità può utilizzare i risultati di altri processi di supporto, come la verifica e la validazione.

\subsubsection{Process assurance}
Per garantire che la qualità prefissata venga raggiunta e mantenuta, viene adottato il ciclo PDCA, noto anche come ciclo di Deming, un approccio metodologico utilizzato per il miglioramento continuo. Si divide in 4 fasi:
\paragraph{Plan} Questa fase coinvolge la definizione degli obiettivi di qualità, la pianificazione delle attività e la creazione di criteri di valutazione. Aiuta a stabilire le aspettative, i processi e le risorse necessarie per raggiungere gli standard di qualità prefissati.
\paragraph{Do} Durante questa fase, vengono implementate le azioni pianificate, eseguendo le attività identificate nel piano e raccogliendo dati per il monitoraggio della qualità.
\paragraph{Check} Questa fase consiste nella valutazione dei risultati ottenuti rispetto agli obiettivi prestabiliti. Attraverso metriche precise stabilite dal team, si verifica se i risultati sono in linea con le aspettative di qualità.
\paragraph{Act} Basandosi sull'analisi dei dati raccolti, si apportano correzioni migliorative ai processi esistenti, al fine di migliorare la qualità del prodotto.

\subsubsection{Metriche: Notazione}
Le metriche di qualità, definite successivamente, vengono identificate con la seguente notazione:
\textbf{M.[Codice].[Sigla]}\\
nella quale:
\begin{itemize}
\item \lbrack \textbf{M}] indica la parola "metrica";
\item \lbrack \textbf{Codice}] è un numero progressivo univoco che identifica le metriche per ogni tipologia;
\item \lbrack \textbf{Sigla}] composta dalle iniziali del nome della metrica; aiuta a identificarla più velocemente.
\end{itemize}
\paragraph{Metriche: Didascalia}
Ogni metrica è descritta dai seguenti campi:
\begin{itemize}
    \item \textbf{Nome}: nome della metrica;
    \item \textbf{Descrizione}: descrizione della metrica;
    \item \textbf{Motivo}: motivazione per la quale è necessario misurarla;
    \item \textbf{Misurazione}: formula e strumenti tramite la quale viene calcolata.
\end{itemize}

\subsubsection{Lista delle metriche}
% TODO: definire lista metriche
\textbf{Qualità del processo}:
% Percentuale di metriche soddisfatte
% Variazione di piano
% Variazione di costo
% Variazione dei requisiti
% Numero di rischi non previsti
% Percentuale di rischi gestiti male
% Complessità ciclomatica media
% Statement coverage
% Branch coverage
\begin{itemize}
    \item \textbf{M1PMS}:
    \begin{itemize}
        \item \textbf{Nome}:
        \item \textbf{Descrizione}:
        \item \textbf{Motivo}:
        \item \textbf{Misurazione}:
    \end{itemize}
    \item 
    \begin{itemize}
        \item \textbf{Nome}:
        \item \textbf{Descrizione}:
        \item \textbf{Motivo}:
        \item \textbf{Misurazione}:
    \end{itemize}
\end{itemize}

\textbf{Qualità del prodotto}:
% Indice di Gulpease
% Percentuale di requisiti implementati
% Linee medie di codice per metodo
% Rapporto commenti - codice
% Percentuale di test di unità superati
% Percentuale di test di integrazione superati
\begin{itemize}
    \item 
    \begin{itemize}
        \item \textbf{Nome}:
        \item \textbf{Descrizione}:
        \item \textbf{Motivo}:
        \item \textbf{Misurazione}:
    \end{itemize}
    \item 
    \begin{itemize}
        \item \textbf{Nome}:
        \item \textbf{Descrizione}:
        \item \textbf{Motivo}:
        \item \textbf{Misurazione}:
    \end{itemize}
\end{itemize}

\subsubsection{Obiettivi di qualità: Struttura}
Gli obiettivi di qualità, divisi in obiettivi di processo e di prodotto, vengono indicati nel documento (Piano di qualifica). Ognuno di questi è descritto da:
\begin{itemize}
    \item \textbf{Metrica}: codice della metrica;
    \item \textbf{Nome}: nome esteso della metrica;
    \item \textbf{Valore tollerabile}: valore oltre il quale la metrica è da considerare soddisfatta;
    \item \textbf{Valore ambito}: valore ideale della metrica.
\end{itemize}

\subsection{Verifica}
\subsubsection{Scopo}
Il processo di verifica ha lo scopo di determinare se ciò che viene prodotto è conforme ai requisiti stabiliti e ai vincoli qualitativi specificati nel (Piano di qualifica).
Lo scopo principale della verifica è garantire la completezza e la correttezza del prodotto, fornendo evidenze oggettive e misurabili.

\subsubsection{Descrizione}
Ogni produzione realizzata da SWEetCode viene sottoposta ad uno o più fasi di verifica prima di essere pubblicata ufficialmente nel repository \textit{GitHub}.
Questo processo viene svolto dai verificatori. Onde evitare conflitti di interesse, tale compito viene assegnato ad uno o più membri diversi da coloro che hanno conseguito alla realizzazione del prodotto in questione.

\subsubsection{Analisi statica}
L'analisi statica è un'attività di verifica che costituisce un'esplorazione dell'oggetto di verifica senza richiedere l'esecuzione di esso. Può essere estesa anche ai documenti testuali.\\
Due tecniche di analisi statica utilizzate dal team, il walkthrough e l'ispezione, sono descritte in seguito.

\subsubsubsection{Walkthrough} Il walkthrough è un'approfondita procedura collaborativa in cui il verificatore e il realizzatore del prodotto leggono criticamente tutto l'oggetto in esame. In particolare, questa attività è composta dalle seguenti fasi:
\begin{itemize}
    \item \textbf{Pianificazione}: coinvolge sia il verificatore che l'autore. In questa fase vengono definite le modalità, le risorse e le tempistiche entro le quali svolgere l'attività;
    \item \textbf{Lettura}: il verificatore esamina l'intero prodotto per individuare errori, incongruenze e migliorie;
    \item \textbf{Discussione}: il verificatore comunica all'autore tutti gli elementi individuati e ritenuti migliorabili; in questa sessione vengono definite anche possibili soluzioni e correzioni;
    \item \textbf{Correzione dei difetti}: Una volta accordata la modalità e il contenuto delle modifiche, l'autore procede con l'effettiva attuazione delle correzioni.
\end{itemize}

\subsubsubsection{Ispezione} L'ispezione è una tecnica che utilizza liste di controllo per eseguire verifiche mirate sugli errori più comuni, evitando la lettura dell'intero documento. L'ispezione è composta dalle seguenti fasi:
\begin{itemize}
    \item \textbf{Pianificazione}: coinvolge sia il verificatore che l'autore. In questa fase vengono definite le modalità, le risorse e le tempistiche entro le quali svolgere l'attività;
    \item \textbf{Definizione lista di controllo}: vengono definiti i punti e gli aspetti critici dell'oggetto in esame; queste liste vengono costruite incrementalmente e aggiornate nel momento in cui la frequente occorrenza di certi errori diventa evidente;
    \item \textbf{Lettura}: il verificatore esamina il prodotto seguendo la lista di controllo per individuare errori, incongruenze e migliorie;
    \item \textbf{Correzione dei difetti}: L'autore procede con l'attuazione delle correzioni.
\end{itemize}

Data l'iniziale inesperienza del team, per i primi periodi è stato utilizzato l'approccio walkthrough.
Nel momento in cui le liste di controllo diventeranno sufficientemente ampie per permettere una verifica adeguata, l'ispezione permetterà al team di svolgere questa attività più velocemente, preservando una grande quantità di risorse.\\
Le liste di controllo sono raccolte nel documento (Piano di qualifica).

\subsubsection{Analisi dinamica}
L'analisi dinamica è una metodologia di verifica che richiede l'esecuzione effettiva del software al fine di valutarne il comportamento, le performance e la correttezza durante l'esecuzione.
Questo tipo di analisi deve poter essere automatizzata e ripetibile. Per questo motivo, devono essere stabilite e regolamentate le condizioni dell'ambiente di esecuzione dei test. 
L'analisi dinamica viene resa possibile dall'implementazione di varie categorie di test, in particolare: di unità, di integrazione, di sistema e di regressione.

\subsubsubsection{Test di unità}
I Verificatori sono incaricati di formulare i test di unità durante la fase di progettazione di dettaglio, descritta in (\S \nameref{sec:progettazione_di_dettaglio}). Questi test sono progettati in conformità alle specifiche di ciascuna unità software, consentendo l'associazione di più test a una singola unità, qualora necessario, costruendo una suite di test dedicata a quell'unità.
L'esecuzione dei test di unità potrebbe richiedere l'utilizzo di stub o driver, strumenti che permettono di testare le singole unità simulando alcuni dei loro componenti, nel caso in cui non fossero tutti disponibili per l'esecuzione.
Tale pratica si rivela essenziale, specialmente nelle fasi iniziali dello sviluppo, quando l'ambiente è ancora piuttosto scarno.

I test di unità possono essere suddivisi in due categorie:
\begin{itemize}
    \item \textbf{Funzionali} (o \textbf{black box}): dato un input e un'aspettativa di output, verificano se l'esecuzione di una certa funzionalità produce l'aspettativa dichiarata;
    \item \textbf{Strutturali} (o \textbf{white box}): verificano la logica interna del codice, analizzando i vari cammini di esecuzione all'interno dell'unità.
\end{itemize}
I verificatori utilizzano entrambe queste tipologie di test di unità, sfruttando strumenti di automazione disponibili per le tecnologie adottate. Questo approccio mira a garantire un processo sistematico ed efficiente, assicurando che ciascuna unità software sia accuratamente testata e rispetti le specifiche stabilite durante la progettazione dettagliata.

\subsubsubsection{Test di integrazione}
I test di integrazione vengono definiti dai verificatori durante la fase di progettazione architetturale. In particolare, si applicano alle componenti individuate con lo scopo di rilevare difetti di progettazione, errori a livello di unit testing, incompatibilità e incongruenza nell'uso delle interfacce o errata integrazione con altre applicazioni. Devono assemblare incrementalmente, ampliando il loro raggio di azione di volta in volta.

Esistono due strategie di integrazione:
\begin{itemize}
    \item \textbf{Bottom-up}: integrazione partendo dalle componenti con minor numero di dipendenze d'uso e maggiore utilità interna (molto chiamate ma che chiamano poco). Richiede pochi stub ma ritarda l'emissione di funzionalità visibili all'utente;
    \item \textbf{Top-down}: integrazione partendo dalle componenti con maggior numero di dipendenze d'uso e maggior utilità esterna (poco chiamate ma che chiamano molto). Comporta all'uso di molti stub ma integra prima le funzionalità più visibili all'utente.
\end{itemize}

\subsubsubsection{Test di sistema}
I test di sistema mirano a valutare il sistema nel suo complesso per garantire che soddisfi tutti i requisiti delineati nel documento (Analisi dei requisiti). Questa fase di testing viene definita dai verificatori e avviene dopo il completamento dei test di unità e dei test di integrazione e prima del collaudo con il committente.
Vegnono considerati come test funzionali (o black-box), non richiedono conoscenza della logica e del funzionamento interno del software.

\subsubsubsection{Test di regressione}
I test di regressione sono un tipo specifico di test che include una selezione dei test già implementati, tra cui test di unità, di integrazione e di sistema, per verificare che le modifiche apportate al software non abbiano introdotto nuovi difetti o non abbiano alterato il comportamento esistente del sistema. In altre parole, i test di regressione mirano a garantire che le modifiche apportate durante lo sviluppo del software non abbiano effetti collaterali negativi su funzionalità precedentemente testate e correttamente funzionanti.

\subsubsection{Test: Notazione}
I test vengono identificati con la seguente notazione:
\textbf{T[Tipo].[Codice]}\\
nella quale:
\begin{itemize}
\item \lbrack \textbf{T}] indica la parola "test";
\item \lbrack \textbf{Tipo}] può essere:
    \begin{itemize}
	    \item U (Unità);
	    \item I (Integrazione);
	    \item S (Sistema);
        \item A (Accettazione).
    \end{itemize}
\item \lbrack \textbf{Codice}] identifica i test per ogni tipologia. È composto da un unico numero progressivo univoco se il test non ha padre, mentre se si tratta di un sotto-test, segue il formato \textbf{[Codice\_padre].[Numero\_figlio]}; questa struttura è ricorsiva, quindi non pone un limite alla profondità della gerarchia;
\end{itemize}

\subsubsection{Test: Stato}
Ogni test è associato a uno stato che indica il risultato di soddisfacimento di esso nell'ultima versione rilasciata del prodotto software. Lo stato può assumere i seguenti valori:
\begin{itemize}
    \item I (Indisponibile, test non in funzione);
    \item S (Superato);
    \item N (Non superato).
\end{itemize}


% PROCESSI ORGANIZZATIVI
\newpage

\section{Processi organizzativi}
\subsection{Comunicazione}
SWEetCode ha deciso di mantenere una comunicazione frequente tra i membri del gruppo. In particolare, di seguito si trova la modalità di svolgimento per le comunicazioni interne e le applicazioni utilizzate.
\subsubsection{Comunicazioni interne}
% \textbf{Comunicazioni sincrone}\\
\paragraph{Comunicazioni sincrone}Il gruppo ha deciso che gli incontri si svolgeranno  in presenza oppure attraverso la piattaforma \textit{Discord}. Per gli incontri in presenza, essi verranno decisi alcuni giorni prima in modo tale da poter consentire la presenza di tutti i membri del gruppo. Per quanto riguarda \textit{Discord}, invece, si opta per una comunicazione asincrona anche pochi minuti prima del collegamento. In entrambe le situazioni, il gruppo utilizza un approccio libero alla discussione e improntato alla crescita.

% \textbf{Comunicazioni asincrone}\\
\paragraph{Comunicazioni asincrone}Il gruppo utilizzerà \textit{Whatsapp} e \textit{Notion} per le comunicazioni asincrone. In particolare è stata creata una community su \textit{Whatsapp}, composta da un gruppo principale per comunicazioni informali, una bacheca nella quale verranno inviati i messaggi più importanti dei quali è necessario prendere visione, ed altri canali in cui i componenti del gruppo si organizzano per task collaborativi.

\subsubsection{Comunicazioni esterne}
\paragraph{Comunicazioni sincrone} Assieme ai referenti della azienda AzzurroDigitale il gruppo ha concordato ed accettato un calendario di incontri settimanali su piattaforma \textit{Google Meet}. Tali incontri saranno cruciali nella possibilità di discutere con maggiore facilità e immediatezza argomenti complessi ed estesi. Il gruppo si impegna a presenziare in maniera più assidua possibile agli incontri con il proponente e a redarre un verbale alla fine degli stessi.

\paragraph{Comunicazioni asincrone} Il canale scelto per la comunicazione asincrona concordato con l'azienda è \textit{Slack}. Questo strumento viene usato per brevi comunicazioni e per accordarsi sugli orari degli incontri.

\newpage

% STRUMENTI
\newpage
\section{Strumenti}
Nella seguente sezione vengono presentati tutti gli strumenti utili al team per lo svolgimento di ogni attività.

\subsection{Adobe Illustrator}
\href{https://www.adobe.com}{https://www.adobe.com}\\\\
Software utilizzato per la creazione dei template ufficiali del team, per la generazione del logo e per la scelta della palette di colori da usare. 

\subsection{Canva}
\href{https://www.canva.com}{https://www.canva.com}\\\\
Sito utilizzato per la produzione delle slide per i Diari di Bordo. É stato creato un account condiviso utilizzabile da tutti i membri.

\subsection{Discord}
\href{https://discord.com}{https://discord.com}\\\\
Piattaforma utilizzata per lo svolgimento di riunioni formali ed informali del team, attraverso la creazione di un server apposito con un canale dedicato ai messaggi di testo e diverse sale dedicate alle conversazioni vocali.

\subsection{GitHub}
\href{https://github.com/}{https://github.com/}
Piattaforma di hosting e collaborazione per lo sviluppo di software che offre strumenti per il controllo di versione, consentendo agli sviluppatori di lavorare insieme, monitorare le modifiche al codice, gestire problemi e pubblicare il proprio lavoro in modo collaborativo.

\subsection{Jira (di \textit{Atlassian})}
\href{https://www.atlassian.com/it/software/jira}{https://www.atlassian.com/it/software/jira}\\\\
Software utilizzato per l'ITS e gli strumenti di organizzazione del lavoro tra i membri del team.

\subsection{Diagrams.net}
\href{https://app.diagrams.net/}{https://app.diagrams.net/}\\\\
Applicazione utilizzata per la creazione dei diagrammi UML.

\subsection{Notion}
\href{https://www.notion.so/product}{https://www.notion.so/product}\\\\
Spazio di lavoro utilizzato per l'organizzazione delle prime task divise per membro del gruppo e per tenere traccia delle attività e dei progressi portati avanti da ogni componente. Usato anche per l'assegnazione chiara dei ruoli, come calendario condiviso del gruppo e per il salvataggio link utili in modo da favorire l'accesso in maniera veloce a tutti i documenti ed i siti necessari.

\subsection{Overleaf}
\href{https://www.overleaf.com}{https://www.overleaf.com}\\\\
Sito utilizzato per la scrittura di tutta la documentazione ufficiale in linguaggio LaTeX, attraverso la creazione di un account condiviso per tutti i membri del team.

\subsection{Slack}
\href{https://slack.com}{https://slack.com}\\\\
Piattaforma di messaggistica specializzato nella comunicazione e collaborazione all'interno di team aziendali. Viene utilizzata dal team per le comunicazioni asincrone con il proponente.


\end{document}