\documentclass[10pt, a4paper]{article}

\input{parameters}

\usepackage{style}
\usepackage{headerfooter}
\usepackage{comment}

\title{\titolo}
\author{SWEetCode}

\begin{document}

% PRIMA PAGINA
\include{firstpage}

% REGISTRO DELLE VERSIONI
\include{registroversioni}
\newpage

% INDICE
\tableofcontents
\newpage
\listoffigures
\newpage
\listoftables
\newpage

% INTRODUZIONE
\section{Introduzione}
\subsection{Obiettivo del documento}
L'obiettivo che ci si pone nella realizzazione di questo documento è descrivere le scelte tecnologiche e l'architettura del prodotto \textit{Knowledge Managment AI}. Verrà seguito un approccio top-down, partendo dall'architettura del sistema passando poi all'architettura delle componenti ed infine alla progettazione di dettaglio.

\subsection{Glossario}
Per evitare ambiguità ed incomprensioni relative al linguaggio e ai termini utilizzati nella documentazione del progetto viene presentato un Glossario.
I termini ambigui o tecnici-specifici presenti nello stesso, vengono identificati nei corrispondenti documenti con un pedice |g| e con una scrittura in corsivo.
All'interno dei documenti viene identificata con tale scrittura solo e soltanto la prima occorrenza presente nel testo di un termine definito nel Glossario.

\subsection{Riferimenti}
   \subsubsection{Riferimenti normativi}
   \begin{itemize}
    \item \textit{(Norme di progetto v2.0.0(0))};
    \item \textit{Regolamento del progetto didattico}: \\
        \url{https://www.math.unipd.it/~tullio/IS-1/2023/Dispense/PD2.pdf}\\
        (Ultimo accesso: 2024-02-26);
    \item \textit{Standard ISO/IEC 9126}:\\
        \url{https://it.wikipedia.org/wiki/ISO/IEC_9126}\\
        (Ultimo accesso: 2024-02-26).
    \end{itemize}
    
    \subsubsection{Riferimenti informativi}
    \begin{itemize}
        \item \textit{(Analisi dei requisiti v2.0.0(0))};
        \item \textit{Capitolato C1}: \textit{Knowledge Management AI}
        \begin{itemize}
            \item \url{https://www.math.unipd.it/~tullio/IS-1/2023/Progetto/C1.pdf}\\
            (Ultimo accesso: 2024-02-26);
            \item \url{https://www.math.unipd.it/~tullio/IS-1/2023/Progetto/C1p.pdf}\\
            (Ultimo accesso: 2024-02-26).
        \end{itemize}
        \item \textit{Dispense su Dependency Injection}: \\
            \url{https://www.math.unipd.it/~rcardin/swea/2022/Design%20Pattern%20Architetturali%20-%20Dependency%20Injection.pdf}\\
            (Ultimo accesso: 2024-02-26);
        \item \textit{Dispense su OOP}: \\
            \url{https://www.math.unipd.it/~rcardin/swea/2023/Object-Oriented%20Progamming%20Principles%20Revised.pdf}\\
            (Ultimo accesso: 2024-02-26);
        \item \textit{Dispense su Diagrammi delle classi}: \\
            \url{https://www.math.unipd.it/~rcardin/swea/2023/Diagrammi%20delle%20Classi.pdf}\\
            (Ultimo accesso: 2024-02-26);
        \item \textit{Dispense su Pattern architetturali}: \\
            \url{https://www.math.unipd.it/~rcardin/swea/2022/Software%20Architecture%20Patterns.pdf}\\
            (Ultimo accesso: 2024-02-26);
        \item \textit{Dispense su Pattern creazionali}: \\
            \url{https://www.math.unipd.it/~rcardin/swea/2022/Design%20Pattern%20Creazionali.pdf}\\
            (Ultimo accesso: 2024-02-26);
        \item \textit{Dispense su Pattern strutturali}: \\
            \url{https://www.math.unipd.it/~rcardin/swea/2022/Design%20Pattern%20Strutturali.pdf}\\
            (Ultimo accesso: 2024-02-26);
        \item \textit{Dispense su Principi SOLID}: \\
            \url{https://www.math.unipd.it/~rcardin/swea/2021/SOLID%20Principles%20of%20Object-Oriented%20Design_4x4.pdf}\\
            (Ultimo accesso: 2024-02-26);
        \item \textit{Dispense sulla Progettazione software (argomento T6)}: \\
            \url{https://www.math.unipd.it/~tullio/IS-1/2023/Dispense/T6.pdf}\\
            (Ultimo accesso: 2024-02-26);
        \item \textit{Dispense sulla Qualità del software (argomento T7)}: \\
            \url{https://www.math.unipd.it/~tullio/IS-1/2023/Dispense/T7.pdf}\\
            (Ultimo accesso: 2024-02-26);
        \item \textit{Repository su Architettura esagonale}: \\
            \url{https://github.com/rcardin/hexagonal}\\
            (Ultimo accesso: 2024-02-26);
            \url{https://github.com/rcardin/hexagonal-java/}\\
            (Ultimo accesso: 2024-02-26);
        \item \textit{Repository Ingegneria del software professor Cardin}: \\
            \url{https://github.com/rcardin/swe-imdb}\\
            (Ultimo accesso: 2024-02-26);
        \item Riferimenti a scelte tecnologiche:
        \begin{itemize}
            \item \textit{AWS S3}: \\
                \url{https://aws.amazon.com/it/s3/}\\
                (Ultimo accesso: 2024-02-26);
            \item \textit{ChromaDB}: \\
                \url{https://www.trychroma.com/}\\
                (Ultimo accesso: 2024-02-26);
            \item \textit{Docker}: \\
                \url{https://www.docker.com/}\\
                (Ultimo accesso: 2024-02-26);
            \item \textit{Flask}: \\
                \url{https://flask.palletsprojects.com/en/3.0.x/}\\
            (Ultimo accesso: 2024-02-26);
            \item \textit{HuggingFace}: \\
                \url{https://huggingface.co/}\\
                (Ultimo accesso: 2024-02-26);
            \item \textit{Langchain}: \\
                \url{https://python.langchain.com/docs/get_started/introduction}\\
                (Ultimo accesso: 2024-02-26);
            \item \textit{Next.js}: \\
                \url{https://nextjs.org/}\\
                (Ultimo accesso: 2024-02-26);
            \item \textit{OpenAI}: \\
                \url{https://openai.com/}\\
                (Ultimo accesso: 2024-02-26);
            \item \textit{Pinecone}: \\
                \url{https://www.pinecone.io/}\\
                (Ultimo accesso: 2024-02-26);
            \item \textit{Postgres}: \\
                \url{https://www.postgresql.org/}\\
                (Ultimo accesso: 2024-02-26);
            \item \textit{Python}: \\
                \url{https://www.python.org/}\\
                (Ultimo accesso: 2024-02-26);
            \item \textit{Typescript}: \\
                \url{https://www.typescriptlang.org/}\\
                (Ultimo accesso: 2024-02-26);
        \end{itemize}
        \item \textit{(Glossario v2.0.0(0))};
        \item \textit{(Piano di progetto v2.0.0(0))};
        \item \textit{(Piano di qualifica v2.0.0(0))};
        \item \textit{Verbali esterni ed interni}.
    \end{itemize}


\newpage
\section{Tecnologie utilizzate}
In questa sezione vengono elencate e descritte le tecnologie utilizzate nello sviluppo, illustrando le motivazioni a sostegno di ogni scelta e le alternative scartate.

\subsection{Flask}
Flask è un micro framework per applicazioni web. È stato scelto per la sua leggerezza e la sua flessibilità, rispetto ad altri framework come Django che potrebbero risultare troppo pesanti per le esigenze del progetto.

\begin{itemize}
\item \textbf{Vantaggi:}
\begin{itemize}
\item \textbf{Leggerezza:} Flask è noto per la sua leggerezza, il che significa che ha poche dipendenze. Questo lo rende perfetto per progetti più piccoli dove non è necessario un carico pesante di funzionalità, a differenza di Django che include molte funzionalità out-of-the-box che potrebbero non essere necessarie;
\item \textbf{Flessibilità:} Flask offre una grande flessibilità, permettendo agli sviluppatori di strutturare le loro applicazioni come preferiscono, a differenza di Django che segue un approccio più rigido e strutturato;
\item \textbf{Facilità d'uso:} Flask è facile da usare e da imparare, rendendolo ideale per i principianti;
\item \textbf{Meno overhead rispetto a Django:} A causa della sua leggerezza e flessibilità, Flask può avere meno overhead rispetto a un framework più pesante come Django;
\item \textbf{Maggiore controllo rispetto a Django:} Flask offre agli sviluppatori un maggiore controllo sulle funzionalità delle loro applicazioni, a differenza di Django che fornisce molte funzionalità predefinite che potrebbero non essere necessarie o desiderate.
\end{itemize}
\item \textbf{Svantaggi:}
\begin{itemize}
\item \textbf{Manca di alcune funzionalità out-of-the-box:} Flask è un microframework, il che significa che potrebbe non avere tutte le funzionalità che potrebbero essere necessarie per un'applicazione più complessa;
\item \textbf{Potrebbe richiedere più tempo per sviluppare applicazioni complesse:} A causa della sua natura minimalista, gli sviluppatori potrebbero dover scrivere più codice per realizzare funzionalità che in altri framework potrebbero essere disponibili out-of-the-box;
\item \textbf{Richiede più configurazione rispetto a Django:} Flask richiede più configurazione rispetto ad altri framework come Django, che hanno più funzionalità integrate;
\item \textbf{Supporto della comunità più piccolo rispetto a Django:} Anche se Flask ha una comunità attiva, non è grande come quella di Django. Questo potrebbe significare meno risorse di apprendimento e supporto disponibili.
\end{itemize}
\end{itemize}
\textbf{Versione scelta:} Flask 3.0.2.

\subsubsection{Python}
Python è un linguaggio di programmazione ad alto livello, interpretato, interattivo, orientato agli oggetti e di script. È progettato per essere altamente leggibile. Rispetto ad altri linguaggi come Java o C++, Python offre una sintassi più semplice e pulita, rendendo il codice più leggibile e mantenibile.

\begin{itemize}
\item \textbf{Vantaggi:}
\begin{itemize}
\item \textbf{Facilità d'uso:} Python ha una sintassi molto pulita e facile da leggere, il che rende il linguaggio molto facile da imparare per i nuovi programmatori;
\item \textbf{Versatilità:} Python può essere utilizzato per una vasta gamma di applicazioni, tra cui sviluppo web, data analysis, machine learning, intelligenza artificiale, creazione di GUI e scripting di sistema;
\item \textbf{Grande comunità:} Python ha una grande comunità di sviluppatori che contribuiscono attivamente alla sua manutenzione e miglioramento. Ciò significa che ci sono molte risorse disponibili per l'apprendimento e la risoluzione dei problemi;
\item \textbf{Librerie ricche rispetto a Java o C++:} Python ha una vasta gamma di librerie e framework, che possono aiutare a semplificare lo sviluppo e a ridurre il tempo di sviluppo, a differenza di altri linguaggi come Java o C++ che potrebbero non avere una gamma così ampia di librerie disponibili;
\item \textbf{Sintassi più semplice rispetto a Java o C++:} Python ha una sintassi più semplice e pulita, il che rende il codice più leggibile e mantenibile rispetto a linguaggi come Java o C++.
\end{itemize}
\item \textbf{Svantaggi:}
\begin{itemize}
\item \textbf{Velocità:} Python non è il linguaggio più veloce a causa della sua natura interpretata e può non essere la scelta migliore per le applicazioni che richiedono prestazioni elevate;
\item \textbf{Gestione della memoria:} Python utilizza un garbage collector per la gestione della memoria, che può non essere efficiente come la gestione manuale della memoria in linguaggi come C++;
\item \textbf{Non è fortemente tipizzato:} A differenza di linguaggi come Java o C++, Python non è un linguaggio fortemente tipizzato. Questo può portare a errori di runtime che sarebbero stati catturati al momento della compilazione in un linguaggio fortemente tipizzato.
\end{itemize}
\end{itemize}
\textbf{Versione scelta:} Python 3.9.

\subsection{Next.js}
Next.js è un framework per applicazioni web basato su React. È stato scelto per la sua efficienza e per le sue funzionalità di rendering lato server. Rispetto ad altri framework come Angular, Next.js offre una maggiore efficienza e facilità d'uso, rendendolo ideale per questo progetto.

\begin{itemize}
\item \textbf{Vantaggi:}
\begin{itemize}
\item \textbf{Efficienza rispetto ad Angular:} Next.js è noto per la sua efficienza, il che significa che le applicazioni create con Next.js sono veloci e performanti, a differenza di Angular che può essere più pesante e meno efficiente;
\item \textbf{Rendering lato server:} Next.js offre funzionalità di rendering lato server, il che significa che può migliorare le prestazioni dell'applicazione e l'ottimizzazione dei motori di ricerca;
\item \textbf{Facilità d'uso rispetto ad Angular:} Next.js è facile da usare e da imparare, specialmente per coloro che sono già familiari con React, a differenza di Angular che può avere una curva di apprendimento più ripida;
\item \textbf{Supporto per TypeScript:} A differenza di molti altri framework, Next.js offre un supporto integrato per TypeScript, il che può migliorare l'affidabilità e la robustezza del codice.
\end{itemize}
\item \textbf{Svantaggi:}
\begin{itemize}
\item \textbf{Overhead rispetto a React da solo:} Next.js può aggiungere un certo overhead a un'applicazione a causa delle sue funzionalità aggiuntive, il che può non essere necessario per le applicazioni più semplici;
\item \textbf{Complessità:} A causa delle sue funzionalità aggiuntive, Next.js può essere più complesso da configurare e gestire rispetto a React da solo;
\item \textbf{Richiede più risorse rispetto a React da solo:} A causa delle sue funzionalità aggiuntive, Next.js può richiedere più risorse di sistema rispetto a React da solo.
\end{itemize}
\end{itemize}
\textbf{Versione scelta:} Next.js 14.1.

\subsubsection{Typescript}
Typescript è un super-set di JavaScript che aggiunge tipi statici e oggetti orientati alla programmazione. È stato scelto per la sua affidabilità e robustezza. Rispetto a JavaScript, TypeScript offre un controllo dei tipi più rigoroso, il che può aiutare a prevenire errori di runtime.

\begin{itemize}
\item \textbf{Vantaggi:}
\begin{itemize}
\item \textbf{Affidabilità rispetto a JavaScript:} Typescript offre un controllo dei tipi a tempo di compilazione, il che significa che gli errori possono essere rilevati e corretti prima dell'esecuzione, a differenza di JavaScript che è un linguaggio interpretato e gli errori possono essere rilevati solo a runtime;
\item \textbf{Robustezza:} Typescript supporta le funzionalità di programmazione orientata agli oggetti, il che può rendere il codice più robusto e facile da gestire;
\item \textbf{Interoperabilità:} Typescript è un super-set di JavaScript, il che significa che qualsiasi codice JavaScript valido può essere utilizzato in Typescript;
\item \textbf{Supporto per le annotazioni di tipo:} A differenza di JavaScript, TypeScript supporta le annotazioni di tipo, il che può migliorare la leggibilità del codice e facilitare la manutenzione.
\end{itemize}
\item \textbf{Svantaggi:}
\begin{itemize}
\item \textbf{Curva di apprendimento rispetto a JavaScript:} Typescript può essere più difficile da imparare rispetto a JavaScript a causa delle sue funzionalità aggiuntive;
\item \textbf{Compilazione:} A differenza di JavaScript, TypeScript deve essere compilato in JavaScript prima di poter essere eseguito, il che può aggiungere un passaggio aggiuntivo nel processo di sviluppo.
\end{itemize}
\end{itemize}
\textbf{Versione scelta:} Typescript 5.3.3.

\subsection{Docker}
Docker è una piattaforma open source che automatizza la distribuzione, la scalabilità e l'isolamento delle applicazioni utilizzando la virtualizzazione a livello di sistema operativo. È stato scelto per la sua efficienza e portabilità. Rispetto ad altre soluzioni come Vagrant, Docker offre una maggiore efficienza e facilità d'uso.

\begin{itemize}
\item \textbf{Vantaggi:}
\begin{itemize}
\item \textbf{Efficienza rispetto a Vagrant:} Docker consente di eseguire più applicazioni in modo isolato sulla stessa infrastruttura hardware, migliorando l'efficienza e riducendo i costi, a differenza di Vagrant che può richiedere più risorse di sistema;
\item \textbf{Portabilità:} Con Docker, le applicazioni e le loro dipendenze possono essere confezionate come un'unità portatile chiamata container, che può essere eseguita su qualsiasi macchina che supporti Docker;
\item \textbf{Isolamento:} Docker isola le applicazioni in container separati, il che significa che ogni applicazione può avere le proprie dipendenze e non interferire con le altre applicazioni;
\item \textbf{Supporto per la CI/CD:} Docker può essere facilmente integrato in pipeline di integrazione continua e distribuzione continua (CI/CD), il che può semplificare il processo di sviluppo e distribuzione.
\end{itemize}
\item \textbf{Svantaggi:}
\begin{itemize}
\item \textbf{Complessità rispetto a Vagrant:} Docker può aggiungere una certa complessità a un progetto a causa della necessità di gestire i container e le loro dipendenze, a differenza di Vagrant che può essere più semplice da configurare e gestire;
\item \textbf{Curva di apprendimento:} Docker ha una curva di apprendimento ripida e può richiedere un certo tempo per essere padroneggiato;
\item \textbf{Compatibilità:} Non tutti i sistemi operativi supportano Docker nativamente, il che può limitare la sua utilità in alcuni ambienti.
\end{itemize}
\end{itemize}
\textbf{Versione scelta:} Docker Desktop 4.28.0.

\subsection{Langchain}
Langchain è un framework che facilita l'interazione tra modelli di apprendimento automatico e risorse esterne come database o altri servizi web. È stato scelto per la sua comodità e flessibilità. Rispetto ad altri framework come TensorFlow o PyTorch, Langchain offre una maggiore facilità d'uso e una migliore integrazione con le risorse esterne.

\begin{itemize}
\item \textbf{Vantaggi:}
\begin{itemize}
\item \textbf{Comodità rispetto a TensorFlow o PyTorch:} Langchain semplifica l'interazione tra modelli di apprendimento automatico e risorse esterne, fornendo moduli e integrazioni, a differenza di TensorFlow o PyTorch che potrebbero richiedere più codice e sforzo per integrare con risorse esterne;
\item \textbf{Flessibilità:} Langchain supporta una varietà di modelli di apprendimento automatico e risorse esterne, rendendolo adatto a una vasta gamma di applicazioni;
\item \textbf{Facilità d'uso rispetto a TensorFlow o PyTorch:} Langchain è facile da usare e da imparare, rendendolo ideale per i principianti, a differenza di TensorFlow o PyTorch che possono avere una curva di apprendimento più ripida;
\item \textbf{Supporto per una varietà di risorse esterne:} A differenza di molti altri framework, Langchain offre un supporto integrato per una varietà di risorse esterne, il che può semplificare lo sviluppo e l'integrazione.
\end{itemize}
\item \textbf{Svantaggi:}
\begin{itemize}
\item \textbf{Limitazioni:} Non tutte le funzionalità sono disponibili in tutte le lingue supportate da Langchain;
\item \textbf{Documentazione:} La documentazione di Langchain potrebbe non essere così completa o aggiornata come quella di altri framework.
\end{itemize}
\end{itemize}
\textbf{Versione scelta:} Langchain 0.1.9.

\subsubsection{Pinecone}
Pinecone è un database di vettori che consente di effettuare ricerche di similarità su larga scala. È stato scelto per la sua efficienza e precisione. Rispetto ad altri database di vettori come Faiss o Annoy, Pinecone offre una maggiore efficienza e una migliore precisione nelle ricerche di similarità.

\begin{itemize}
\item \textbf{Vantaggi:}
\begin{itemize}
\item \textbf{Efficienza rispetto a Faiss o Annoy:} Pinecone è progettato per effettuare ricerche di similarità su larga scala in modo efficiente, a differenza di Faiss o Annoy che potrebbero non essere ottimizzati per ricerche su larga scala;
\item \textbf{Precisione rispetto a Faiss o Annoy:} Pinecone offre un'alta precisione nelle ricerche di similarità, il che lo rende ideale per applicazioni che richiedono un alto grado di precisione, a differenza di Faiss o Annoy che potrebbero non offrire la stessa precisione;
\item \textbf{Facilità d'uso:} Pinecone è facile da usare e da imparare, rendendolo ideale per i principianti;
\item \textbf{Scalabilità:} A differenza di molti altri database di vettori, Pinecone è progettato per scalare con le esigenze dell'applicazione, il che può semplificare la gestione delle risorse.
\end{itemize}
\item \textbf{Svantaggi:}
\begin{itemize}
\item \textbf{Costo rispetto a Faiss o Annoy:} Pinecone può essere costoso da utilizzare per applicazioni su larga scala, a differenza di Faiss o Annoy che sono open source e gratuiti da utilizzare;
\item \textbf{Limitazioni:} Pinecone potrebbe non supportare tutte le funzionalità di ricerca di similarità che potrebbero essere necessarie per alcune applicazioni.
\end{itemize}
\end{itemize}
\textbf{Versione scelta:} Pinecone Client 3.1.0.

\subsubsection{ChromaDB}
ChromaDB è un database di vettori locale open-source. È stato scelto per la sua integrazione con Langchain e la sua popolarità tra i database di vettori locali. Rispetto ad altri database di vettori locali come Faiss o Annoy, ChromaDB offre una migliore integrazione con Langchain e una maggiore popolarità.

\begin{itemize}
\item \textbf{Vantaggi:}
\begin{itemize}
\item \textbf{Integrazione con Langchain rispetto a Faiss o Annoy:} ChromaDB è ben integrato con Langchain, il che facilita l'interazione tra i due, a differenza di Faiss o Annoy che potrebbero richiedere più codice e sforzo per integrare con Langchain;
\item \textbf{Popolarità rispetto a Faiss o Annoy:} ChromaDB è il database di vettori locale open-source più popolare, il che significa che ha una grande comunità di sviluppatori e molte risorse disponibili, a differenza di Faiss o Annoy che potrebbero non avere una comunità di sviluppatori così grande;
\item \textbf{Facilità d'uso:} ChromaDB è facile da usare e da imparare, rendendolo ideale per i principianti;
\item \textbf{Supporto per una varietà di tipi di dati:} A differenza di molti altri database di vettori, ChromaDB supporta una varietà di tipi di dati, il che può semplificare la gestione dei dati.
\end{itemize}
\item \textbf{Svantaggi:}
\begin{itemize}
\item \textbf{Limitazioni:} Non tutte le funzionalità sono disponibili in tutte le lingue supportate da ChromaDB;
\item \textbf{Documentazione:} La documentazione di ChromaDB potrebbe non essere così completa o aggiornata come quella di altri database.
\end{itemize}
\end{itemize}
\textbf{Versione scelta:} ChromaDB 0.4.24.

\subsubsection{OpenAI}
OpenAI è una piattaforma di apprendimento automatico che offre una varietà di modelli, tra cui GPT-3 e GPT-4. La scelta di utilizzare OpenAI sia per il Large Language Model (LLM) che per gli embeddings è motivata dalla sua reputazione consolidata nel campo dell'apprendimento automatico e dalla sua completa integrazione con Langchain. Rispetto all’addestramento di modelli personalizzati con TensorFlow o PyTorch, l’utilizzo dei modelli pre-addestrati di OpenAI offre una maggiore facilità d’uso.

\begin{itemize}
\item \textbf{Vantaggi:}
\begin{itemize}
\item \textbf{Popolarità rispetto a TensorFlow o PyTorch:} OpenAI è molto conosciuto nel campo dell'apprendimento automatico, il che significa che ha una grande comunità di sviluppatori e molte risorse disponibili, a differenza di TensorFlow o PyTorch che potrebbero non avere una comunità di sviluppatori così grande;
\item \textbf{Integrazione:} OpenAI ha un'integrazione completa con Langchain, il che facilita l'interazione tra i due, a differenza di TensorFlow o PyTorch che potrebbero richiedere più codice e sforzo per integrare con Langchain;
\item \textbf{Flessibilità:} OpenAI offre la possibilità di scegliere tra diversi modelli semplicemente cambiando un parametro, a seconda delle esigenze e della disponibilità dell'utente finale.
\end{itemize}
\item \textbf{Svantaggi:}
\begin{itemize}
\item \textbf{Costo:} L'utilizzo di OpenAI può essere costoso, soprattutto per le applicazioni su larga scala, a differenza di TensorFlow o PyTorch che sono open source e gratuiti da utilizzare;
\item \textbf{Limitazioni:} Non tutte le funzionalità sono disponibili in tutti i modelli offerti da OpenAI.
\end{itemize}
\end{itemize}
\textbf{Versione modello LLM scelto:} gpt-3.5-turbo-instruct. \\
\textbf{Versione modello di embeddings scelto:} text-embedding-3-small.

\subsubsection{HuggingFace}
HuggingFace è una piattaforma di apprendimento automatico che offre migliaia di modelli open-source, tra cui modelli di linguaggio e modelli di embeddings. La decisione di utilizzare HuggingFace sia per il Large Language Model (LLM) che per gli embeddings è motivata dalla sua flessibilità e dalla possibilità di scaricare i modelli localmente per l’esecuzione offline. Questo offre una maggiore flessibilità rispetto all’addestramento di modelli personalizzati con TensorFlow o PyTorch, che può richiedere risorse computazionali significative e competenze specialistiche.

\begin{itemize}
\item \textbf{Vantaggi:}
\begin{itemize}
\item \textbf{Flessibilità:} HuggingFace offre una vasta gamma di modelli, il che significa che è possibile scegliere il modello più adatto alle proprie esigenze, a differenza di TensorFlow o PyTorch che potrebbero richiedere la configurazione e l'addestramento di modelli personalizzati;
\item \textbf{Località:} HuggingFace offre la possibilità di scaricare i modelli in locale, il che significa che possono essere eseguiti sulle proprie macchine senza la necessità di una connessione internet;
\item \textbf{Facilità d'uso rispetto a TensorFlow o PyTorch:} HuggingFace è facile da usare e da imparare, rendendolo ideale per i principianti, a differenza di TensorFlow o PyTorch che possono avere una curva di apprendimento più ripida.
\end{itemize}
\item \textbf{Svantaggi:}
\begin{itemize}
\item \textbf{Risorse rispetto a TensorFlow o PyTorch:} L'esecuzione dei modelli in locale può richiedere molte risorse hardware, il che può non essere ideale per tutte le macchine, a differenza di TensorFlow o PyTorch che possono essere ottimizzati per l'esecuzione su hardware specifico;
\item \textbf{Complessità:} A causa della vasta gamma di modelli disponibili, può essere difficile scegliere il modello più adatto alle proprie esigenze.
\end{itemize}
\end{itemize}
\textbf{Versione modello LLM scelto:} meta-llama/Llama-2-7b-chat-hf. \\
\textbf{Versione modello di embeddings scelto:} sentence-transformers/all-mpnet-base-v2.

\subsection{AWS S3}
Amazon S3 (Simple Storage Service) è un servizio di storage di oggetti offerto da Amazon Web Services. È stato scelto per la sua scalabilità, affidabilità, e sicurezza. Rispetto ad altre soluzioni di storage come Google Cloud Storage o Azure Blob Storage, AWS S3 offre una maggiore scalabilità e una migliore integrazione con altri servizi AWS.

\begin{itemize}
\item \textbf{Vantaggi:}
\begin{itemize}
\item \textbf{Scalabilità rispetto a Google Cloud Storage o Azure Blob Storage:} Amazon S3 può memorizzare qualsiasi quantità di dati e servire qualsiasi livello di traffico richiesto, a differenza di Google Cloud Storage o Azure Blob Storage che potrebbero avere limiti sulla quantità di dati o sul traffico;
\item \textbf{Affidabilità:} Amazon S3 offre una durabilità dell'11 9's, il che significa che i dati sono estremamente sicuri, a differenza di Google Cloud Storage o Azure Blob Storage che potrebbero non offrire lo stesso livello di durabilità;
\item \textbf{Sicurezza rispetto a Google Cloud Storage o Azure Blob Storage:} Amazon S3 offre potenti funzionalità per proteggere i dati, tra cui controllo degli accessi, crittografia in transito e a riposo, e altro ancora, a differenza di Google Cloud Storage o Azure Blob Storage che potrebbero non offrire le stesse funzionalità di sicurezza.
\end{itemize}
\item \textbf{Svantaggi:}
\begin{itemize}
\item \textbf{Costo rispetto a Google Cloud Storage o Azure Blob Storage:} Il costo di Amazon S3 può aumentare rapidamente con l'aumentare dell'uso, a differenza di Google Cloud Storage o Azure Blob Storage che potrebbero avere costi più prevedibili;
\item \textbf{Complessità:} Amazon S3 ha molte funzionalità e opzioni, il che può renderlo complesso da configurare e gestire, a differenza di Google Cloud Storage o Azure Blob Storage che potrebbero essere più semplici da configurare e gestire.
\end{itemize}
\end{itemize}
\textbf{Versione scelta:} Amazon Simple Storage Service (Amazon S3).

\subsection{Postgres}
Postgres, o PostgreSQL, è un potente sistema di gestione di database relazionali ad oggetti open source. È stato scelto per la sua robustezza, affidabilità e flessibilità. Rispetto ad altri DBMS come MySQL o SQLite, Postgres offre una maggiore robustezza e una migliore supporto per le funzionalità di programmazione orientata agli oggetti.

\begin{itemize}
\item \textbf{Vantaggi:}
\begin{itemize}
\item \textbf{Robustezza rispetto a MySQL o SQLite:} Postgres supporta una vasta gamma di tipi di dati nativi, operatori e funzioni, tra cui JSON, XML e array, a differenza di MySQL o SQLite che potrebbero non supportare tutti questi tipi di dati;
\item \textbf{Affidabilità:} Postgres è noto per la sua affidabilità e integrità dei dati. Offre transazioni atomiche, commit multi-versione (MVCC), punti di controllo, logging di scrittura anticipata (WAL) e una serie di meccanismi di replica, a differenza di MySQL o SQLite che potrebbero non offrire tutte queste funzionalità;
\item \textbf{Flessibilità rispetto a MySQL o SQLite:} Postgres è estensibile, il che significa che gli sviluppatori possono definire i propri tipi di dati, operatori e funzioni. Inoltre, può essere utilizzato sia come un database SQL tradizionale che come una soluzione NoSQL per la memorizzazione di documenti, a differenza di MySQL o SQLite che potrebbero non offrire la stessa flessibilità.
\end{itemize}
\item \textbf{Svantaggi:}
\begin{itemize}
\item \textbf{Complessità rispetto a MySQL o SQLite:} A causa della sua vasta gamma di funzionalità, Postgres può essere più complesso da configurare e gestire rispetto ad altri sistemi di gestione di database come MySQL o SQLite;
\item \textbf{Prestazioni:} Sebbene Postgres sia altamente ottimizzato, le sue prestazioni potrebbero non essere all'altezza di altri database per alcune applicazioni, in particolare quelle che richiedono letture ad alta velocità di grandi quantità di dati.
\end{itemize}
\end{itemize}
\textbf{Versione scelta:} PostgreSQL 16.2.

\newpage
\section{Architettura di sistema}
\subsection{Modello architetturale}
Il sistema è progettato seguendo l'\textbf{architettura esagonale}, un modello architetturale che mira a creare una separazione netta tra la business logic dell'applicazione e i servizi esterni, le fonti di dati e le interfacce utente con cui interagisce.
Questa struttura organizzativa posiziona il nucleo al centro, circondato da "porte" che fungono da interfaccia tra il nucleo e il mondo esterno.

Il \textbf{nucleo} dell'applicazione è il fulcro del sistema, contenente la logica di dominio e le regole di business. La sua progettazione mira a evitare riferimenti diretti a dettagli tecnologici specifici, promuovendo l'indipendenza dal contesto esterno.

Le \textbf{porte} costituiscono il confine tra il nucleo dell'applicazione e il mondo esterno, consentendo una comunicazione strutturata. Esistono due tipi principali di porte:
\begin{itemize}
    \item Inbound Port (o \textbf{Use Case}): consentono al nucleo di essere invocato da componenti esterni attraverso un'interfaccia definita. Rappresentano i punti di accesso al nucleo e isolano la logica di dominio da implementazioni specifiche;
    \item Outbound Port: consentono al nucleo di accedere a funzionalità esterne, come l'interazione con librerie esterne o sistemi di persistenza. Forniscono un'astrazione che preserva l'indipendenza del nucleo da dettagli tecnologici specifici.  
\end{itemize}

I \textbf{services} implementano le inbound port dell'applicazione e fanno parte della business logic. La loro implementazione è concentrata sulla logica di dominio, senza preoccuparsi degli aspetti tecnologici specifici.

Gli \textbf{adapters} costituiscono il livello più esterno dell'applicazione. Esistono due tipi di adapters:
\begin{itemize}
    \item Input Adapters (o \textbf{Controllers}): sono responsabili di invocare operazioni sulle porte in ingresso. Traducono le azioni provenienti dall'esterno in chiamate alle porte in ingresso del nucleo, facilitando la traduzione delle richieste esterne in operazioni comprensibili per il nucleo;
    \item Output Adapters: gestiscono le porte in uscita, traducendo le azioni del nucleo in operazioni comprensibili per il mondo esterno.
\end{itemize}

\subsection{Descrizione delle componenti}
L'architettura generale del sistema è composta da due componenti: frontend e backend.

\subsubsection{Frontend}
Il frontend si occupa di fornire un'interfaccia grafica all'utente per dialogare con il sistema. Inoltra le richieste dell'utente al backend e mostra i risultati ottenuti.
%TODO: approfondire

\subsubsection{Backend}
Il backend si occupa di elaborare le richieste degli utenti, interagendo con i sistemi di persistenza e i servizi esterni.
In particolare, il backend dialoga con il sistema di archiviazione documenti, il vector store, il database delle chat e con i modelli di intelligenza artificiale necessari per il corretto funzionamento dell'applicazione.
%TODO: approfondire

\subsection{Assemblaggio delle componenti}
Le componenti sono assemblate insieme utilizzando Docker Compose. In particolare sono prodotti i
seguenti container Docker:

\begin{itemize}
    \item \textbf{db}: espone l'istanza del database chat nella porta 3000, abilitando il dialogo con il backend;
    \item \textbf{backend}: espone la componente backend nella porta 4000, dando al frontend la possibilità di chiamare le API offerte;
    \item \textbf{frontend}: espone il frontend dell'applicazione web nella porta 80, dando la possibilità all'utente di connettersi e interagire con il sistema.
\end{itemize}

\subsection{Struttura del sistema}

\subsubsection{Frontend}
La struttura organizzativa del frontend segue la struttura standard definita dal framework Next.js.
% TODO: approfondire

\subsubsection{Backend}
La struttura organizzativa del backend segue la seguente struttura:
\code{
\begin{tabbing}
    /backend\=\\
    \> /adapter\=\\
    \> \> /in\=\\
    \> \> \> /web -- controllers\\
    \> \> /out -- implementazioni di Outbound Port\\
    \> /application\\
    \> \> /port\\
    \> \> \> /in -- Inbound Ports (Use Cases)\\
    \> \> \> /out -- Outbound Ports\\
    \> \> \> /service -- implementazioni di Inbound Port\\
    \> /domain -- classi di business
\end{tabbing}
}
Questa struttura riflette il modello architetturale scelto, facilitando il passaggio da progettazione a codifica.


\newpage
\section{Architettura delle componenti} % architettura interna di ciascuna componente
\subsection{Frontend}
% - X ogni componente frontend:
    % - definizione e utilità
    % - route API
    % - elementi grafici (anche a seguito di azioni)
    % - tracciamento requisiti soddisfatti
% - Requisiti implementativi

    %- X ogni sottocomponente della componente:
    %     - nome: definizione e utilità (componente che serve a ...)

\subsection{Backend}
% - X ogni componente backend:
    % - definizione e utilità
    % - route API
    % - metodo HTTP
    % - parametri richiesta HTTP
    % - tabella possibili risposte (status code, condizione, tipo di ritorno(header o body))
    % - tracciamento requisiti soddisfatti
    
    % - X ogni sottocomponente della componente:
    %     - nome: definizione e utilità (interfaccia/classe che serve a ...)
    %     - se sono classi, indicare "interfacce implementate" e/o "classi astratte estese"

\subsubsection{AskChatbot}
\subsubsubsection{Descrizione}
Questa componente ha il compito di ottenere una risposta ad un messaggio da parte del chatbot.
È costituita da:
\begin{itemize}
    \item \textbf{Route API}: /askChatbot;
    \item \textbf{Metodo}: POST;
    \item \textbf{Lista parametri HTTP}: 
    \begin{itemize}
        \item "message": messaggio da parte dell'utente;
        \item "chatId": id della chat a cui appartiene il messaggio.
    \end{itemize}
\end{itemize}
\subsubsubsection{Esiti possibili}
\begin{xltabular}{\textwidth}{c|X|X}
\caption{Esiti possibili AskChatbot}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endfirsthead
\caption[]{Esiti possibili AskChatbot (cont)}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endhead
\multicolumn{3}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
200 & Risposta ottenuta con successo. & - \\
\hline
500 & Risposta del chatbot fallita. & Errore di generazione della risposta del chatbot. \\
\end{xltabular}

\subsubsubsection{Tracciamento dei requisiti}
\begin{itemize}
        \item RF.D.40;
        \item RF.O.47.1;
        \item RF.O.48.
\end{itemize}

\subsubsubsection{Lista sottocomponenti}
\begin{itemize}
    \item \label{AskChatbotController}\textbf{AskChatbotController}: classe controller che si occupa del richiedere una risposta al chatbot ad un messaggio appartente ad una chat allo use case AskChatbotUseCase;
    \item \label{Message}\textbf{Message}: classe di business che rappresenta un messaggio di una chat;
    \item \label{MessageSender}\textbf{MessageSender}: classe di business che rappresenta il mittente di un messaggio;
    \item \label{AskChatbotUseCase}\textbf{AskChatbotUseCase}: interfaccia use case che rappresenta la porta della business logic in entrata per richiedere una risposta al chatbot ad un messaggio appartente ad una chat;
    \item \label{AskChatbotService}\textbf{AskChatbotService}: classe service che implementa lo use case AskChatbotUseCase;
    \item \label{ChatId}\textbf{ChatId}: classe di business che rappresenta l'id di una chat utilizzato nella ricerca;
    \item \label{AskChatbotPort}\textbf{AskChatbotPort}: interfaccia che rappresenta la porta in uscita per effettuare la richiesta di una risposta al chatbot ad un messaggio appartente ad una chat, con storicizzazione all'interno del database delle chat;
    \item \label{AskChatbotLangchain}\textbf{AskChatbotLangchain}: classe che implementa la porta AskChatbotPort, adattando la chiamata di AskChatbotService a classi offerte dal framework Langchain;
    \item \label{ChatHistoryManager}\textbf{ChatHistoryManager}: classe per interagire con le chat come oggetti lanchain.Memory;
    \item \label{ChatbotLangchain}\textbf{ChatbotLangchain}: classe che permette di interagire con un oggetto langchain.Chain;
    \item \label{LangchainLLM}\textbf{LangchainLLM}: classe astratta che permette di interagire con un oggetto langchain.BaseLanguageModel;
    \item \label{OpenAILLM}\textbf{OpenAILLM}: classe che implementa la classe astratta LangchainLLM per interagire con un modello LLM di OpenAI;
    \item \label{HugginFaceLLM}\textbf{HugginFaceLLM}: classe che implementa la classe astratta LangchainLLM per interagire con un modello LLM di HugginFace;
    \item \label{LangchainVectorStore}\textbf{LangchainVectorStore}: classe astratta che permette di interagire con un oggetto langchain.VectorStore;
    \item \label{PineconeVectorStore}\textbf{PineconeVectorStore}: classe che implementa la classe astratta LangchainVectorStore per interagire con un vector store Pinecone;
    \item \label{ChromaDBVectorStore}\textbf{ChromaDBVectorStore}: classe che implementa la classe astratta LangchainVectorStore per interagire con un vector store ChromaDB;
    \item \label{LangchainEmbeddingModel}\textbf{LangchainEmbeddingModel}: classe astratta che permette di interagire con un oggetto langhchain.Embeddings;
    \item \label{OpenAIEmbeddingModel}\textbf{OpenAIEmbeddingModel}: classe che implementa la classe astratta LangchainEmbeddingModel per interagire con un modello di generazione di embeddings di OpenAI;
    \item \label{HuggingFaceEmbeddingModel}\textbf{HuggingFaceEmbeddingModel}: classe che implementa la classe astratta LangchainEmbeddingModel per interagire con un modello di generazione di embeddings di HugginFace;
    \item \label{PostgresORM}\textbf{PostgresORM}: classe che si occupa di effettuare le operazioni su Postgres configurato, cioè il sistema di storicizzazione delle chat dell'applicazione;
    \item \label{PostgresChat}\textbf{PostgresChat}: classe di persistence che rappresenta una chat;
    \item \label{PostgresMessage}\textbf{PostgresMessage}: classe di persistence che rappresenta un messaggio.
\end{itemize}

\subsubsection{ConcealDocuments}
\subsubsubsection{Descrizione}
Questa componente ha il compito di occultare gli embeddings dei documenti indicati dall'utente.
È costituita da:
\begin{itemize}
    \item \textbf{Route API}: /concealDocuments;
    \item \textbf{Metodo}: POST;
    \item \textbf{Lista parametri HTTP}: 
    \begin{itemize}
        \item "documentIds": una lista di stringhe che rappresentano gli id dei documenti da occultare.
    \end{itemize}
\end{itemize}
\subsubsubsection{Esiti possibili}
\renewcommand{\arraystretch}{1.5}
\begin{xltabular}{\textwidth}{c|X|X}
\caption{Esiti possibili ConcealDocuments}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endfirsthead
\caption[]{Esiti possibili ConcealDocuments (cont)}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endhead
\multicolumn{3}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
200 & Occultamento avvenuto con successo. & - \\
\hline
500 & Occultamento fallito. & Errore nell'occultamento dei documenti.
\end{xltabular}

\subsubsubsection{Tracciamento dei requisiti}
\begin{itemize}
    \item RF.O.25;
    \item RF.O.26.
\end{itemize}

\subsubsubsection{Lista sottocomponenti}
\begin{itemize}
    \item \label{ConcealDocumentsController}\textbf{ConcealDocumentsController}: classe controller che si occupa del passaggio di una lista di DocumentId allo use case ConcealDocumentsUseCase a partire da una lista di stringhe che rappresentano l'id dei documenti da occultare;
    \item \label{ConcealDocumentsUseCase}\textbf{ConcealDocumentsUseCase}: interfaccia use case che rappresenta la porta della business logic in entrata per effettuare l'occultamento dei documenti;
    \item \label{ConcealDocumentsService}\textbf{ConcealDocumentsService}: classe service che implementa lo use case ConcealDocumentsUseCase;
    \item \label{ConcealDocumentsPort}\textbf{ConcealDocumentsPort}: interfaccia che rappresenta la porta in uscita per effettuare l'occultamento dei documenti nel vector store;
    \item \label{ConcealDocumentsVectorStore}\textbf{ConcealDocumentsVectorStore}: classe adapter che implementa la porta ConcealDocumentsPort, adattando la chiamata di ConcealDocumentsService a VectorStoreManager;
    \item \label{VectorStoreManager}\textbf{VectorStoreManager}: interfaccia che rende disponibile metodi per dialogare con i vector store;
    \item \label{VectorStorePineconeManager}\textbf{VectorStorePineconeManager}: classe che implementa VectorStoreManager, offrendo la possibilità di dialogare con il vector store Pinecone;
    \item \label{VectorStoreChromaDBManager}\textbf{VectorStoreChromaDBManager}: classe che implementa VectorStoreManager,  offrendo la possibilità di dialogare con il vector store Chroma;
    \item \label{VectorStoreDocumentOperationResponse}\textbf{VectorStoreDocumentOperationResponse}: classe che contiene l'esito di un'operazione effettuata su un vector store riguardo un documento.
\end{itemize}

\subsubsection{DeleteChats}
\subsubsubsection{Descrizione}
Questa componente ha il compito di eliminare una lista di chat, aggiornando di conseguenza il database utilizzato per la storicizzazione delle chat.
È costituita da:
\begin{itemize}
    \item \textbf{Route API}: /deleteChats;
    \item \textbf{Metodo}: POST;
    \item \textbf{Lista parametri HTTP}: 
    \begin{itemize}
        \item "chatIds": lista di Id utilizzati per identificare univocamente le chat.
    \end{itemize}
\end{itemize}
\subsubsubsection{Esiti possibili}
\renewcommand{\arraystretch}{1.5}
\begin{xltabular}{\textwidth}{c|X|X}
\caption{Esiti possibili DeleteChats}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endfirsthead
\caption[]{Esiti possibili DeleteChats (cont)}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endhead
\multicolumn{3}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
200 & Eliminazione avvenuta con successo. & - \\
\hline
500 & Eliminazione fallita. & Errore nella eliminazione della chat. \\
\end{xltabular}

\subsubsubsection{Tracciamento dei requisiti}
\begin{itemize}
        \item RF.O.33
        \item RF.O.34
        \item RF.O.34.1
\end{itemize}

\subsubsubsection{Lista sottocomponenti}
\begin{itemize}
    \item \label{DeleteChatsController}\textbf{DeleteChatsController}: classe controller che si occupa del passaggio allo use case CreateChatUseCase di interi rappresentanti gli id di una lista di chat per eseguire la loro eliminazione;
    \item \label{DeleteChatsUseCase}\textbf{DeleteChatsUseCase}: interfaccia use case che rappresenta la porta della business logic in entrata per effettuare l'eliminazione di una lista di chat;
    \item \label{DeleteChatsService}\textbf{DeleteChatsService}: classe service che implementa lo use case DeleteChatsUseCase;
    \item \label{DeleteChatsPort}\textbf{DeleteChatsPort}: interfaccia che rappresenta la porta in uscita per effettuare l'eliminazione di una lista di chat verso il database per la storicizzazione delle chat;
    \item \label{DeleteChatsPostgres}\textbf{DeleteChatsPostgres}: classe che implementa la porta DeleteChatPort, adattando la chiamata di DeleteChatsService a PostgresORM;
    \item \textbf{PostgresORM}: vedi \vedi{PostgresORM}.
\end{itemize}

\subsubsection{DeleteDocuments}
\subsubsubsection{Descrizione}
Questa componente ha il compito di eliminare una lista di documenti e i loro rispettivi embeddings.
È costituita da:
\begin{itemize}
    \item \textbf{Route API}: /deleteDocuments;
    \item \textbf{Metodo}: POST;
    \item \textbf{Lista parametri HTTP}: 
    \begin{itemize}
        \item "documentIds": una lista di stringhe che rappresentano gli id dei documenti da eliminare.
    \end{itemize}
\end{itemize}
\subsubsubsection{Esiti possibili}
\renewcommand{\arraystretch}{1.5}
\begin{xltabular}{\textwidth}{c|X|X}
\caption{Esiti possibili DeleteDocuments}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endfirsthead
\caption[]{Esiti possibili DeleteDocuments (cont)}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endhead
\multicolumn{3}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
200 & Eliminazione avvenuta con successo. & - \\
\hline
500 & Eliminazione fallita. & Errore nell'eliminazione dei documenti.
\end{xltabular}

\subsubsubsection{Tracciamento dei requisiti}
\begin{itemize}
    \item TODO.
\end{itemize}

\subsubsubsection{Lista sottocomponenti}
\begin{itemize}
    \item \label{DeleteDocumentsController}\textbf{DeleteDocumentsController}: classe controller che si occupa del passaggio di una lista di DocumentId allo use case DeleteDocumentsUseCase a partire da una lista di stringhe che rappresentano gli id dei documenti da eliminare;
    \item \label{DeleteDocumentsUseCase}\textbf{DeleteDocumentsUseCase}: interfaccia use case che rappresenta la porta della business logic in entrata per eliminare i documenti;
    \item \label{DeleteDocumentsService}\textbf{DeleteDocumentsService}: classe service che implementa lo use case DeleteDocumentsUseCase;
    \item \label{DeleteDocuments}\textbf{DeleteDocuments}: classe che si occupa di inoltrare la richiesta di eliminare una lista di documenti nella porta esterna DeleteDocumentsPort diretta verso il sistema di archiviazione;
    \item \label{DeleteDocumentsEmbeddings}\textbf{DeleteDocumentsEmbeddings}: classe che si occupa di eliminare gli embeddings di una lista di documenti nella porta esterna DeleteEmbeddingsPort diretta verso il vector store;
    \item \label{DeleteDocumentsPort}\textbf{DeleteDocumentsPort}: interfaccia che rappresenta la porta in uscita per eliminare una lista di documenti dal sistema di archiviazione;
    \item \label{DeleteEmbeddingsPort}\textbf{DeleteEmbeddingsPort}: interfaccia che rappresenta la porta in uscita per eliminare gli embeddings di una lista di documenti dal vector store;
    \item \textbf{DocumentOperationResponse}: vedi \vedi{DocumentOperationResponse};
    \item \label{DeleteDocumentsAWSS3}\textbf{DeleteDocumentsAWSS3}: classe adapter che implementa la porta DeleteDocumentsPort, adattando la chiamata di DeleteDocuments a AWSS3Manager;
    \item \label{AWSS3Manager}\textbf{AWSS3Manager}: classe che si occupa di effettuare le operazioni sul bucket di Amazon S3 configurato, cioè il sistema di archiviazione documenti dell'applicazione;
    \item \label{AWSDocumentOperationResponse}\textbf{AWSDocumentOperationResponse}: classe che contiene l'esito di un'operazione effettuata su un AWS S3 riguardo un documento;
    \item \label{DeleteEmbeddingsVectorStore}\textbf{DeleteEmbeddingsVectorStore}: classe adapter che implementa la porta DeleteEmbeddingsPort, adattando la chiamata di DeleteDocumentsEmbeddings a VectorStoreManager;
    \item \textbf{VectorStoreManager}: vedi \vedi{VectorStoreManager};
    \item \textbf{VectorStorePineconeManager}: vedi \vedi{VectorStorePineconeManager};
    \item \textbf{VectorStoreChromaDBManager}: vedi \vedi{VectorStoreChromaDBManager};
    \item \textbf{VectorStoreDocumentOperationResponse}: vedi \vedi{VectorStoreDocumentOperationResponse}.
\end{itemize}


\subsection{Database} %TODO
    % definisco ogni tabella e la descrivo
    % diagramma ER del db
    % script di creazione db

\subsection{Libreria per la persistenza} %TODO
    % diagramma delle classi
    % x ogni entità ci sarà una classe:
    %     - annotazioni (non ci sono in py, non penso di metterle)
    %     - attributi privati
    %     - costruttori

\newpage

\section{Progettazione di dettaglio}
    % Per ogni componente:
    %    - diagramma di dettaglio
    %    Indicare per ogni sottocomponente:
    %        - attributi (nome: tipo)
    %        - metodi (firma, descrizione)
    % - interfacce implementate

\end{document}