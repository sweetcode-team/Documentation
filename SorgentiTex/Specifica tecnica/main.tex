\documentclass[10pt, a4paper]{article}

\input{parameters}

\usepackage{style}
\usepackage{headerfooter}
\usepackage{comment}
\usepackage{rotating}

\title{\titolo}
\author{SWEetCode}

\begin{document}

% PRIMA PAGINA
\include{firstpage}

% REGISTRO DELLE VERSIONI
\include{registroversioni}
\newpage

% INDICE
\tableofcontents
\newpage
\listoffigures
\newpage
\listoftables
\newpage

% INTRODUZIONE
\section{Introduzione}
\subsection{Obiettivo del documento}
L'obiettivo che ci si pone nella realizzazione di questo documento è descrivere le scelte tecnologiche e l'architettura del prodotto \textit{Knowledge\pg Management\pg AI}. Verrà seguito un approccio top-down, partendo dall'architettura del sistema passando poi all'architettura delle componenti ed infine alla progettazione di dettaglio.

\subsection{Glossario}
Per evitare ambiguità ed incomprensioni relative al linguaggio e ai termini utilizzati nella documentazione del progetto viene presentato un Glossario.
I termini ambigui o tecnici-specifici presenti nello stesso, vengono identificati nei corrispondenti documenti con un pedice |g| e con una scrittura in corsivo.
All'interno dei documenti viene identificata con tale scrittura solo e soltanto la prima occorrenza presente nel testo di un termine definito nel Glossario.

\subsection{Riferimenti}
   \subsubsection{Riferimenti normativi}
   \begin{itemize}
    \item \textit{(Norme di progetto v3.0.0(0))};
    \item \textit{Regolamento del progetto didattico}: \\
        \url{https://www.math.unipd.it/~tullio/IS-1/2023/Dispense/PD2.pdf}\\
        (Ultimo accesso: 2024-04-08);
    \item \textit{Standard ISO/IEC 9126}:\\
        \url{https://it.wikipedia.org/wiki/ISO/IEC_9126}\\
        (Ultimo accesso: 2024-04-08).
    \end{itemize}
    
    \subsubsection{Riferimenti informativi}
    \begin{itemize}
        \item \textit{(Analisi dei requisiti v3.0.0(0))};
        \item \textit{Capitolato\pg C1}: \textit{Knowledge Management AI}
        \begin{itemize}
            \item \url{https://www.math.unipd.it/~tullio/IS-1/2023/Progetto/C1.pdf}\\
            (Ultimo accesso: 2024-04-08);
            \item \url{https://www.math.unipd.it/~tullio/IS-1/2023/Progetto/C1p.pdf}\\
            (Ultimo accesso: 2024-04-08).
        \end{itemize}
        \item \textit{Dispense su Dependency Injection}: \\
            \url{https://www.math.unipd.it/~rcardin/swea/2022/Design%20Pattern%20Architetturali%20-%20Dependency%20Injection.pdf}\\
            (Ultimo accesso: 2024-04-08);
        \item \textit{Dispense su OOP}: \\
            \url{https://www.math.unipd.it/~rcardin/swea/2023/Object-Oriented%20Progamming%20Principles%20Revised.pdf}\\
            (Ultimo accesso: 2024-04-08);
        \item \textit{Dispense su Diagrammi delle classi}: \\
            \url{https://www.math.unipd.it/~rcardin/swea/2023/Diagrammi%20delle%20Classi.pdf}\\
            (Ultimo accesso: 2024-04-08);
        \item \textit{Dispense su Pattern architetturali}: \\
            \url{https://www.math.unipd.it/~rcardin/swea/2022/Software%20Architecture%20Patterns.pdf}\\
            (Ultimo accesso: 2024-04-08);
        \item \textit{Dispense su Pattern creazionali}: \\
            \url{https://www.math.unipd.it/~rcardin/swea/2022/Design%20Pattern%20Creazionali.pdf}\\
            (Ultimo accesso: 2024-04-08);
        \item \textit{Dispense su Pattern strutturali}: \\
            \url{https://www.math.unipd.it/~rcardin/swea/2022/Design%20Pattern%20Strutturali.pdf}\\
            (Ultimo accesso: 2024-04-08);
        \item \textit{Dispense su Principi SOLID}: \\
            \url{https://www.math.unipd.it/~rcardin/swea/2021/SOLID%20Principles%20of%20Object-Oriented%20Design_4x4.pdf}\\
            (Ultimo accesso: 2024-04-08);
        \item \textit{Dispense sulla Progettazione software (argomento T6)}: \\
            \url{https://www.math.unipd.it/~tullio/IS-1/2023/Dispense/T6.pdf}\\
            (Ultimo accesso: 2024-04-08);
        \item \textit{Dispense sulla Qualità del software (argomento T7)}: \\
            \url{https://www.math.unipd.it/~tullio/IS-1/2023/Dispense/T7.pdf}\\
            (Ultimo accesso: 2024-04-08);
        \item \textit{Repository su Architettura esagonale}: \\
            \url{https://github.com/rcardin/hexagonal}\\
            (Ultimo accesso: 2024-04-08);
            \url{https://github.com/rcardin/hexagonal-java/}\\
            (Ultimo accesso: 2024-04-08);
        \item \textit{Repository Ingegneria del software\pg professor Cardin}: \\
            \url{https://github.com/rcardin/swe-imdb}\\
            (Ultimo accesso: 2024-04-08);
        \item Riferimenti a scelte tecnologiche:
        \begin{itemize}
            \item \textit{AWS\pg S3}: \\
                \url{https://aws.amazon.com/it/s3/}\\
                (Ultimo accesso: 2024-04-08);
            \item \textit{ChromaDB}: \\
                \url{https://www.trychroma.com/}\\
                (Ultimo accesso: 2024-04-08);
            \item \textit{Docker}: \\
                \url{https://www.docker.com/}\\
                (Ultimo accesso: 2024-04-08);
            \item \textit{Flask\pg}: \\
                \url{https://flask.palletsprojects.com/en/3.0.x/}\\
            (Ultimo accesso: 2024-04-08);
            \item \textit{HuggingFace\pg}: \\
                \url{https://huggingface.co/}\\
                (Ultimo accesso: 2024-04-08);
            \item \textit{Langchain\pg}: \\
                \url{https://python.langchain.com/docs/get_started/introduction}\\
                (Ultimo accesso: 2024-04-08);
            \item \textit{Next.js\pg}: \\
                \url{https://nextjs.org/}\\
                (Ultimo accesso: 2024-04-08);
            \item \textit{OpenAI\pg}: \\
                \url{https://openai.com/}\\
                (Ultimo accesso: 2024-04-08));
            \item \textit{Pinecone\pg}: \\
                \url{https://www.pinecone.io/}\\
                (Ultimo accesso: 2024-04-08));
            \item \textit{Postgres\pg}: \\
                \url{https://www.postgresql.org/}\\
                (Ultimo accesso: 2024-04-08));
            \item \textit{Python\pg}: \\
                \url{https://www.python.org/}\\
                (Ultimo accesso: 2024-04-08));
            \item \textit{Typescript\pg}: \\
                \url{https://www.typescriptlang.org/}\\
                (Ultimo accesso: 2024-04-08));
        \end{itemize}
        \item \textit{(Glossario v3.0.0(0))};
        \item \textit{(Piano di progetto v3.0.0(0))};
        \item \textit{(Piano di qualifica v3.0.0(0))};
        \item \textit{Verbali interni:}
        \begin{itemize}
            \item \textit{2024-02-19};
            \item \textit{2024-02-26};
            \item \textit{2024-03-07};
            \item \textit{2024-03-12};
            \item \textit{2024-03-19};
            \item \textit{2024-03-25};
            \item \textit{2024-04-01};
            \item \textit{2024-04-12}.
        \end{itemize}
        \item \textit{Verbali esterni:}
        \begin{itemize}
            \item \textit{2023-02-28};
            \item \textit{2023-03-13};
            \item \textit{2023-03-26}.
        \end{itemize}
    \end{itemize}


\newpage
\section{Tecnologie utilizzate}
In questa sezione vengono elencate e descritte le tecnologie utilizzate nello sviluppo, illustrando le motivazioni a sostegno di ogni scelta e le alternative scartate.

\subsection{Flask}
Flask è un micro \textit{framework\pg} per applicazioni web. È stato scelto per la sua leggerezza e la sua flessibilità, rispetto ad altri framework come \textit{Django\pg} che potrebbero risultare troppo pesanti per le esigenze del progetto.

\begin{itemize}
\item \textbf{Vantaggi:}
\begin{itemize}
\item \textbf{Leggerezza:} Flask è noto per la sua leggerezza, il che significa che ha poche dipendenze. Questo lo rende perfetto per progetti più piccoli dove non è necessario un carico pesante di funzionalità, a differenza di Django che include molte funzionalità \textit{out-of-the-box\pg} che potrebbero non essere necessarie;
\item \textbf{Flessibilità:} Flask offre una grande flessibilità, permettendo agli sviluppatori di strutturare le loro applicazioni come preferiscono, a differenza di Django che segue un approccio più rigido e strutturato;
\item \textbf{Facilità d'uso:} Flask è facile da usare e da imparare, rendendolo ideale per i principianti;
\item \textbf{Meno \textit{overhead\pg} rispetto a Django:} A causa della sua leggerezza e flessibilità, Flask può avere meno overhead rispetto a un framework più pesante come Django;
\item \textbf{Maggiore controllo rispetto a Django:} Flask offre agli sviluppatori un maggiore controllo sulle funzionalità delle loro applicazioni, a differenza di Django che fornisce molte funzionalità predefinite che potrebbero non essere necessarie o desiderate.
\end{itemize}
\item \textbf{Svantaggi:}
\begin{itemize}
\item \textbf{Manca di alcune funzionalità out-of-the-box:} Flask è un microframework, il che significa che potrebbe non avere tutte le funzionalità che potrebbero essere necessarie per un'applicazione più complessa;
\item \textbf{Potrebbe richiedere più tempo per sviluppare applicazioni complesse:} A causa della sua natura minimalista, gli sviluppatori potrebbero dover scrivere più codice per realizzare funzionalità che in altri framework potrebbero essere disponibili out-of-the-box;
\item \textbf{Richiede più configurazione rispetto a Django:} Flask richiede più configurazione rispetto ad altri framework come Django, che hanno più funzionalità integrate;
\item \textbf{Supporto della comunità più piccolo rispetto a Django:} Anche se Flask ha una comunità attiva, non è grande come quella di Django. Questo potrebbe significare meno risorse di apprendimento e supporto disponibili.
\end{itemize}
\end{itemize}
\textbf{Versione scelta:} Flask 3.0.2.

\subsubsection{Python}
Python è un linguaggio di programmazione ad alto livello, interpretato, interattivo, orientato agli oggetti e di \textit{script\pg}. È progettato per essere altamente leggibile.\\ Rispetto ad altri linguaggi come \textit{Java\pg} o \textit{C++\pg}, Python offre una sintassi più semplice e pulita, rendendo il codice più leggibile e mantenibile.

\begin{itemize}
\item \textbf{Vantaggi:}
\begin{itemize}
\item \textbf{Facilità d'uso:} Python ha una sintassi molto pulita e facile da leggere, il che rende il linguaggio molto facile da imparare per i nuovi \textit{programmatori\pg};
\item \textbf{Versatilità:} Python può essere utilizzato per una vasta gamma di applicazioni, tra cui sviluppo web, data analysis, machine learning, intelligenza artificiale, creazione di GUI e scripting di sistema;
\item \textbf{Grande comunità:} Python ha una grande comunità di sviluppatori che contribuiscono attivamente alla sua manutenzione e miglioramento. Ciò significa che ci sono molte risorse disponibili per l'apprendimento e la risoluzione dei problemi;
\item \textbf{Librerie ricche rispetto a Java o C++:} Python ha una vasta gamma di librerie e framework, che possono aiutare a semplificare lo sviluppo e a ridurre il tempo di sviluppo, a differenza di altri linguaggi come Java o C++ che potrebbero non avere una gamma così ampia di librerie disponibili;
\item \textbf{Sintassi più semplice rispetto a Java o C++:} Python ha una sintassi più semplice e pulita, il che rende il codice più leggibile e mantenibile rispetto a linguaggi come Java o C++.
\end{itemize}
\item \textbf{Svantaggi:}
\begin{itemize}
\item \textbf{Velocità:} Python non è il linguaggio più veloce a causa della sua natura interpretata e può non essere la scelta migliore per le applicazioni che richiedono prestazioni elevate;
\item \textbf{Gestione della memoria:} Python utilizza un garbage collector per la gestione della memoria, che può non essere efficiente come la gestione manuale della memoria in linguaggi come C++;
\item \textbf{Non è fortemente tipizzato:} A differenza di linguaggi come Java o C++, Python non è un linguaggio fortemente tipizzato. Questo può portare a errori di runtime che sarebbero stati catturati al momento della compilazione in un linguaggio fortemente tipizzato.
\end{itemize}
\end{itemize}
\textbf{Versione scelta:} Python 3.12-slim

\subsection{Next.js}
Next.js è un framework per applicazioni web basato su \textit{React\pg}. È stato scelto per la sua \textit{efficienza\pg} e per le sue funzionalità di rendering lato server. Rispetto ad altri framework come \textit{Angular\pg}, Next.js offre una maggiore efficienza e facilità d'uso, rendendolo ideale per questo progetto.

\begin{itemize}
\item \textbf{Vantaggi:}
\begin{itemize}
\item \textbf{Efficienza rispetto ad Angular:} Next.js è noto per la sua efficienza, il che significa che le applicazioni create con Next.js sono veloci e performanti, a differenza di Angular che può essere più pesante e meno efficiente;
\item \textbf{Rendering lato server:} Next.js offre funzionalità di rendering lato server, il che significa che può migliorare le prestazioni dell'applicazione e l'ottimizzazione dei motori di ricerca;
\item \textbf{Facilità d'uso rispetto ad Angular:} Next.js è facile da usare e da imparare, specialmente per coloro che sono già familiari con React, a differenza di Angular che può avere una curva di apprendimento più ripida;
\item \textbf{Supporto per TypeScript:} A differenza di molti altri framework, Next.js offre un supporto integrato per TypeScript, il che può migliorare l'affidabilità e la robustezza del codice.
\end{itemize}
\item \textbf{Svantaggi:}
\begin{itemize}
\item \textbf{Overhead rispetto a React da solo:} Next.js può aggiungere un certo overhead a un'applicazione a causa delle sue funzionalità aggiuntive, il che può non essere necessario per le applicazioni più semplici;
\item \textbf{Complessità:} A causa delle sue funzionalità aggiuntive, Next.js può essere più complesso da configurare e gestire rispetto a React da solo;
\item \textbf{Richiede più risorse rispetto a React da solo:} A causa delle sue funzionalità aggiuntive, Next.js può richiedere più risorse di sistema rispetto a React da solo.
\end{itemize}
\end{itemize}
\textbf{Versione scelta:} Next.js 14.1.

\subsubsection{Typescript}
Typescript è un super-set di \textit{JavaScript\pg} che aggiunge tipi statici e oggetti orientati alla programmazione. È stato scelto per la sua affidabilità e robustezza. Rispetto a JavaScript, TypeScript offre un controllo dei tipi più rigoroso, il che può aiutare a prevenire errori di runtime.

\begin{itemize}
\item \textbf{Vantaggi:}
\begin{itemize}
\item \textbf{Affidabilità rispetto a JavaScript:} Typescript offre un controllo dei tipi a tempo di compilazione, il che significa che gli errori possono essere rilevati e corretti prima dell'esecuzione, a differenza di JavaScript che è un linguaggio interpretato e gli errori possono essere rilevati solo a runtime;
\item \textbf{Robustezza:} Typescript supporta le funzionalità di programmazione orientata agli oggetti, il che può rendere il codice più robusto e facile da gestire;
\item \textbf{Interoperabilità:} Typescript è un super-set di JavaScript, il che significa che qualsiasi codice JavaScript valido può essere utilizzato in Typescript;
\item \textbf{Supporto per le annotazioni di tipo:} A differenza di JavaScript, TypeScript supporta le annotazioni di tipo, il che può migliorare la leggibilità del codice e facilitare la manutenzione.
\end{itemize}
\item \textbf{Svantaggi:}
\begin{itemize}
\item \textbf{Curva di apprendimento rispetto a JavaScript:} Typescript può essere più difficile da imparare rispetto a JavaScript a causa delle sue funzionalità aggiuntive;
\item \textbf{Compilazione:} A differenza di JavaScript, TypeScript deve essere compilato in JavaScript prima di poter essere eseguito, il che può aggiungere un passaggio aggiuntivo nel \textit{processo\pg} di sviluppo.
\end{itemize}
\end{itemize}
\textbf{Versione scelta:} Typescript 5.3.3.

\subsection{Docker}
\textit{Docker\pg} è una piattaforma open source che automatizza la distribuzione, la scalabilità e l'isolamento delle applicazioni utilizzando la virtualizzazione a livello di sistema operativo. È stato scelto per la sua efficienza e portabilità. Rispetto ad altre soluzioni come Vagrant, Docker offre una maggiore efficienza e facilità d'uso.

\begin{itemize}
\item \textbf{Vantaggi:}
\begin{itemize}
\item \textbf{Efficienza rispetto a Vagrant:} Docker consente di eseguire più applicazioni in modo isolato sulla stessa infrastruttura hardware, migliorando l'efficienza e riducendo i costi, a differenza di Vagrant che può richiedere più risorse di sistema;
\item \textbf{Portabilità:} Con Docker, le applicazioni e le loro dipendenze possono essere confezionate come un'unità portatile chiamata container, che può essere eseguita su qualsiasi macchina che supporti Docker;
\item \textbf{Isolamento:} Docker isola le applicazioni in container separati, il che significa che ogni applicazione può avere le proprie dipendenze e non interferire con le altre applicazioni;
\item \textbf{Supporto per la \textit{CI/CD\pg}:} Docker può essere facilmente integrato in pipeline di integrazione continua e distribuzione continua (CI/CD), il che può semplificare il processo di sviluppo e distribuzione.
\end{itemize}
\item \textbf{Svantaggi:}
\begin{itemize}
\item \textbf{Complessità rispetto a Vagrant:} Docker può aggiungere una certa complessità a un progetto a causa della necessità di gestire i container e le loro dipendenze, a differenza di Vagrant che può essere più semplice da configurare e gestire;
\item \textbf{Curva di apprendimento:} Docker ha una curva di apprendimento ripida e può richiedere un certo tempo per essere padroneggiato;
\item \textbf{Compatibilità:} Non tutti i sistemi operativi supportano Docker nativamente, il che può limitare la sua utilità in alcuni ambienti.
\end{itemize}
\end{itemize}
\textbf{Versione scelta:} Docker Desktop 4.28.0.

\subsection{Langchain}
Langchain è un framework che facilita l'interazione tra modelli di apprendimento automatico e risorse esterne come \textit{database\pg} o altri servizi web. È stato scelto per la sua comodità e flessibilità. Rispetto ad altri framework come \textit{TensorFlow\pg} o \textit{PyTorch\pg}, Langchain offre una maggiore facilità d'uso e una migliore integrazione con le risorse esterne.

\begin{itemize}
\item \textbf{Vantaggi:}
\begin{itemize}
\item \textbf{Comodità rispetto a TensorFlow o PyTorch:} Langchain semplifica l'interazione tra modelli di apprendimento automatico e risorse esterne, fornendo moduli e integrazioni, a differenza di TensorFlow o PyTorch che potrebbero richiedere più codice e sforzo per integrare con risorse esterne;
\item \textbf{Flessibilità:} Langchain supporta una varietà di modelli di apprendimento automatico e risorse esterne, rendendolo adatto a una vasta gamma di applicazioni;
\item \textbf{Facilità d'uso rispetto a TensorFlow o PyTorch:} Langchain è facile da usare e da imparare, rendendolo ideale per i principianti, a differenza di TensorFlow o PyTorch che possono avere una curva di apprendimento più ripida;
\item \textbf{Supporto per una varietà di risorse esterne:} A differenza di molti altri framework, Langchain offre un supporto integrato per una varietà di risorse esterne, il che può semplificare lo sviluppo e l'integrazione.
\end{itemize}
\item \textbf{Svantaggi:}
\begin{itemize}
\item \textbf{Limitazioni:} Non tutte le funzionalità sono disponibili in tutte le lingue supportate da Langchain;
\item \textbf{Documentazione:} La documentazione di Langchain potrebbe non essere così completa o aggiornata come quella di altri framework.
\end{itemize}
\end{itemize}
\textbf{Versione scelta:} Langchain 0.1.9.

\subsubsection{Pinecone}
Pinecone è un database di vettori che consente di effettuare ricerche di similarità su larga scala. È stato scelto per la sua efficienza e precisione. Rispetto ad altri database di vettori come \textit{Faiss\pg} o \textit{Annoy\pg}, Pinecone offre una maggiore efficienza e una migliore precisione nelle ricerche di similarità.

\begin{itemize}
\item \textbf{Vantaggi:}
\begin{itemize}
\item \textbf{Efficienza rispetto a Faiss o Annoy:} Pinecone è progettato per effettuare ricerche di similarità su larga scala in modo efficiente, a differenza di Faiss o Annoy che potrebbero non essere ottimizzati per ricerche su larga scala;
\item \textbf{Precisione rispetto a Faiss o Annoy:} Pinecone offre un'alta precisione nelle ricerche di similarità, il che lo rende ideale per applicazioni che richiedono un alto grado di precisione, a differenza di Faiss o Annoy che potrebbero non offrire la stessa precisione;
\item \textbf{Facilità d'uso:} Pinecone è facile da usare e da imparare, rendendolo ideale per i principianti;
\item \textbf{Scalabilità:} A differenza di molti altri database di vettori, Pinecone è progettato per scalare con le esigenze dell'applicazione, il che può semplificare la gestione delle risorse.
\end{itemize}
\item \textbf{Svantaggi:}
\begin{itemize}
\item \textbf{Costo rispetto a Faiss o Annoy:} Pinecone può essere costoso da utilizzare per applicazioni su larga scala, a differenza di Faiss o Annoy che sono open source e gratuiti da utilizzare;
\item \textbf{Limitazioni:} Pinecone potrebbe non supportare tutte le funzionalità di ricerca di similarità che potrebbero essere necessarie per alcune applicazioni.
\end{itemize}
\end{itemize}
\textbf{Versione scelta:} Pinecone Client 3.1.0.

\subsubsection{ChromaDB}
\textit{ChromaDB\pg} è un database di vettori locale open-source. È stato scelto per la sua integrazione con Langchain e la sua popolarità tra i database di vettori locali. Rispetto ad altri database di vettori locali come Faiss o Annoy, ChromaDB offre una migliore integrazione con Langchain e una maggiore popolarità.

\begin{itemize}
\item \textbf{Vantaggi:}
\begin{itemize}
\item \textbf{Integrazione con Langchain rispetto a Faiss o Annoy:} ChromaDB è ben integrato con Langchain, il che facilita l'interazione tra i due, a differenza di Faiss o Annoy che potrebbero richiedere più codice e sforzo per integrare con Langchain;
\item \textbf{Popolarità rispetto a Faiss o Annoy:} ChromaDB è il database di vettori locale open-source più popolare, il che significa che ha una grande comunità di sviluppatori e molte risorse disponibili, a differenza di Faiss o Annoy che potrebbero non avere una comunità di sviluppatori così grande;
\item \textbf{Facilità d'uso:} ChromaDB è facile da usare e da imparare, rendendolo ideale per i principianti;
\item \textbf{Supporto per una varietà di tipi di dati:} A differenza di molti altri database di vettori, ChromaDB supporta una varietà di tipi di dati, il che può semplificare la gestione dei dati.
\end{itemize}
\item \textbf{Svantaggi:}
\begin{itemize}
\item \textbf{Limitazioni:} Non tutte le funzionalità sono disponibili in tutte le lingue supportate da ChromaDB;
\item \textbf{Documentazione:} La documentazione di ChromaDB potrebbe non essere così completa o aggiornata come quella di altri database.
\end{itemize}
\end{itemize}
\textbf{Versione scelta:} ChromaDB 0.4.24.

\subsubsection{OpenAI}
Open\textit{AI\pg} è una piattaforma di apprendimento automatico che offre una varietà di modelli, tra cui GPT-3 e GPT-4. La scelta di utilizzare OpenAI sia per il \textit{Large Language Model\pg} (LLM) che per gli \textit{embeddings\pg} è motivata dalla sua reputazione consolidata nel campo dell'apprendimento automatico e dalla sua completa integrazione con Langchain. Rispetto all’addestramento di modelli personalizzati con TensorFlow o PyTorch, l’utilizzo dei modelli pre-addestrati di OpenAI offre una maggiore facilità d’uso.

\begin{itemize}
\item \textbf{Vantaggi:}
\begin{itemize}
\item \textbf{Popolarità rispetto a TensorFlow o PyTorch:} OpenAI è molto conosciuto nel campo dell'apprendimento automatico, il che significa che ha una grande comunità di sviluppatori e molte risorse disponibili, a differenza di TensorFlow o PyTorch che potrebbero non avere una comunità di sviluppatori così grande;
\item \textbf{Integrazione:} OpenAI ha un'integrazione completa con Langchain, il che facilita l'interazione tra i due, a differenza di TensorFlow o PyTorch che potrebbero richiedere più codice e sforzo per integrare con Langchain;
\item \textbf{Flessibilità:} OpenAI offre la possibilità di scegliere tra diversi modelli semplicemente cambiando un parametro, a seconda delle esigenze e della disponibilità dell'utente finale.
\end{itemize}
\item \textbf{Svantaggi:}
\begin{itemize}
\item \textbf{Costo:} L'utilizzo di OpenAI può essere costoso, soprattutto per le applicazioni su larga scala, a differenza di TensorFlow o PyTorch che sono open source e gratuiti da utilizzare;
\item \textbf{Limitazioni:} Non tutte le funzionalità sono disponibili in tutti i modelli offerti da OpenAI.
\end{itemize}
\end{itemize}
\textbf{Versione modello \textit{LLM\pg} scelto:} gpt-3.5-turbo-instruct. \\
\textbf{Versione modello di embeddings scelto:} text-embedding-3-small.

\subsubsection{HuggingFace}
HuggingFace è una piattaforma di apprendimento automatico che offre migliaia di modelli open-source, tra cui modelli di linguaggio e modelli di embeddings. La decisione di utilizzare HuggingFace sia per il Large Language Model (LLM) che per gli embeddings è motivata dalla sua flessibilità e dalla possibilità di scaricare i modelli localmente per l’esecuzione offline. Questo offre una maggiore flessibilità rispetto all’addestramento di modelli personalizzati con TensorFlow o PyTorch, che può richiedere risorse computazionali significative e competenze specialistiche.

\begin{itemize}
\item \textbf{Vantaggi:}
\begin{itemize}
\item \textbf{Flessibilità:} HuggingFace offre una vasta gamma di modelli, il che significa che è possibile scegliere il modello più adatto alle proprie esigenze, a differenza di TensorFlow o PyTorch che potrebbero richiedere la configurazione e l'addestramento di modelli personalizzati;
\item \textbf{Località:} HuggingFace offre la possibilità di scaricare i modelli in locale, il che significa che possono essere eseguiti sulle proprie macchine senza la necessità di una connessione internet;
\item \textbf{Facilità d'uso rispetto a TensorFlow o PyTorch:} HuggingFace è facile da usare e da imparare, rendendolo ideale per i principianti, a differenza di TensorFlow o PyTorch che possono avere una curva di apprendimento più ripida.
\end{itemize}
\item \textbf{Svantaggi:}
\begin{itemize}
\item \textbf{Risorse rispetto a TensorFlow o PyTorch:} L'esecuzione dei modelli in locale può richiedere molte risorse hardware, il che può non essere ideale per tutte le macchine, a differenza di TensorFlow o PyTorch che possono essere ottimizzati per l'esecuzione su hardware specifico;
\item \textbf{Complessità:} A causa della vasta gamma di modelli disponibili, può essere difficile scegliere il modello più adatto alle proprie esigenze.
\end{itemize}
\end{itemize}
\textbf{Versione modello LLM scelto:} meta-llama/Llama-2-7b-chat-hf. \\
\textbf{Versione modello di embeddings scelto:} sentence-transformers/all-mpnet-base-v2.

\subsection{AWS S3}
\textit{Amazon S3\pg} (Simple Storage Service) è un servizio di storage di oggetti offerto da \textit{Amazon Web Services\pg}. È stato scelto per la sua scalabilità, affidabilità, e sicurezza. Rispetto ad altre soluzioni di storage come \textit{Google Cloud Storage\pg} o \textit{Azure Blob Storage\pg}, AWS S3 offre una maggiore scalabilità e una migliore integrazione con altri servizi AWS.

\begin{itemize}
\item \textbf{Vantaggi:}
\begin{itemize}
\item \textbf{Scalabilità rispetto a Google Cloud Storage o Azure Blob Storage:} Amazon S3 può memorizzare qualsiasi quantità di dati e servire qualsiasi livello di traffico richiesto, a differenza di Google Cloud Storage o Azure Blob Storage che potrebbero avere limiti sulla quantità di dati o sul traffico;
\item \textbf{Affidabilità:} Amazon S3 offre una durabilità dell'\textit{11 9's\pg}, il che significa che i dati sono estremamente sicuri, a differenza di Google Cloud Storage o Azure Blob Storage che potrebbero non offrire lo stesso livello di durabilità;
\item \textbf{Sicurezza rispetto a Google Cloud Storage o Azure Blob Storage:} Amazon S3 offre potenti funzionalità per proteggere i dati, tra cui controllo degli accessi, crittografia in transito e a riposo, e altro ancora, a differenza di Google Cloud Storage o Azure Blob Storage che potrebbero non offrire le stesse funzionalità di sicurezza.
\end{itemize}
\item \textbf{Svantaggi:}
\begin{itemize}
\item \textbf{Costo rispetto a Google Cloud Storage o Azure Blob Storage:} Il costo di Amazon S3 può aumentare rapidamente con l'aumentare dell'uso, a differenza di Google Cloud Storage o Azure Blob Storage che potrebbero avere costi più prevedibili;
\item \textbf{Complessità:} Amazon S3 ha molte funzionalità e opzioni, il che può renderlo complesso da configurare e gestire, a differenza di Google Cloud Storage o Azure Blob Storage che potrebbero essere più semplici da configurare e gestire.
\end{itemize}
\end{itemize}
\textbf{Versione scelta:} Amazon Simple Storage Service (Amazon S3).

\subsection{Postgres}
Postgres, o \textit{PostgreSQL\pg}, è un potente sistema di gestione di database relazionali ad oggetti open source. È stato scelto per la sua robustezza, affidabilità e flessibilità. Rispetto ad altri \textit{DBMS\pg} come \textit{MySQL\pg} o \textit{SQLite\pg}, Postgres offre una maggiore robustezza e una migliore supporto per le funzionalità di programmazione orientata agli oggetti.

\begin{itemize}
\item \textbf{Vantaggi:}
\begin{itemize}
\item \textbf{Robustezza rispetto a MySQL o SQLite:} Postgres supporta una vasta gamma di tipi di dati nativi, operatori e funzioni, tra cui JSON, XML e array, a differenza di MySQL o SQLite che potrebbero non supportare tutti questi tipi di dati;
\item \textbf{Affidabilità:} Postgres è noto per la sua affidabilità e integrità dei dati. Offre transazioni atomiche, commit multi-versione (\textit{MVCC\pg}), punti di controllo, logging di scrittura anticipata (\textit{WAL\pg}) e una serie di meccanismi di replica, a differenza di MySQL o SQLite che potrebbero non offrire tutte queste funzionalità;
\item \textbf{Flessibilità rispetto a MySQL o SQLite:} Postgres è estensibile, il che significa che gli sviluppatori possono definire i propri tipi di dati, operatori e funzioni. Inoltre, può essere utilizzato sia come un database \textit{SQL\pg} tradizionale che come una soluzione \textit{NoSQL\pg} per la memorizzazione di documenti, a differenza di MySQL o SQLite che potrebbero non offrire la stessa flessibilità.
\end{itemize}
\item \textbf{Svantaggi:}
\begin{itemize}
\item \textbf{Complessità rispetto a MySQL o SQLite:} A causa della sua vasta gamma di funzionalità, Postgres può essere più complesso da configurare e gestire rispetto ad altri sistemi di gestione di database come MySQL o SQLite;
\item \textbf{Prestazioni:} Sebbene Postgres sia altamente ottimizzato, le sue prestazioni potrebbero non essere all'altezza di altri database per alcune applicazioni, in particolare quelle che richiedono letture ad alta velocità di grandi quantità di dati.
\end{itemize}
\end{itemize}
\textbf{Versione scelta:} PostgreSQL 16.2.

\newpage
\section{Architettura di sistema}
\subsection{Modello architetturale}
Il sistema è progettato seguendo l'\textbf{architettura esagonale}, un modello architetturale che mira a creare una separazione netta tra la business logic dell'applicazione e i servizi esterni, le fonti di dati e le interfacce utente con cui interagisce.
Questa struttura organizzativa posiziona il nucleo al centro, circondato da "porte" che fungono da interfaccia tra il nucleo e il mondo esterno.

Il \textbf{nucleo} dell'applicazione è il fulcro del sistema, contenente la logica di dominio e le regole di business. La sua progettazione mira a evitare riferimenti diretti a dettagli tecnologici specifici, promuovendo l'indipendenza dal contesto esterno.

Le \textbf{porte} costituiscono il confine tra il nucleo dell'applicazione e il mondo esterno, consentendo una comunicazione strutturata. Esistono due tipi principali di porte:
\begin{itemize}
    \item Inbound Port (o \textbf{Use Case}): consentono al nucleo di essere invocato da componenti esterni attraverso un'interfaccia definita. Rappresentano i punti di accesso al nucleo e isolano la logica di dominio da implementazioni specifiche;
    \item Outbound Port: consentono al nucleo di accedere a funzionalità esterne, come l'interazione con \textit{librerie esterne\pg} o sistemi di persistenza. Forniscono un'astrazione che preserva l'indipendenza del nucleo da dettagli tecnologici specifici.  
\end{itemize}

I \textbf{services} implementano le inbound port dell'applicazione e fanno parte della business logic. La loro implementazione è concentrata sulla logica di dominio, senza preoccuparsi degli aspetti tecnologici specifici.

Gli \textbf{adapters} costituiscono il livello più esterno dell'applicazione. Esistono due tipi di adapters:
\begin{itemize}
    \item Input Adapters (o \textbf{Controllers}): sono responsabili di invocare operazioni sulle porte in ingresso. Traducono le azioni provenienti dall'esterno in chiamate alle porte in ingresso del nucleo, facilitando la traduzione delle richieste esterne in operazioni comprensibili per il nucleo;
    \item Output Adapters: gestiscono le porte in uscita, traducendo le azioni del nucleo in operazioni comprensibili per il mondo esterno.
\end{itemize}


\begin{comment}
    \subsection{Descrizione delle componenti}







\subsection{Struttura del sistema}

\subsubsection{Frontend}
La struttura organizzativa del frontend segue la struttura standard definita dal framework Next.js.
In particolare, all'interno della cartella app sono presenti le seguenti cartelle, che nel framework sopracitato corrispondono alle route visitabili dall'utente:
\begin{itemize}
    \item \textbf{chatbot}: contiene i componenti relativi alla gestione e alla visualizzazione delle chat;
    \item \textbf{configuration}: contiene i componenti relativi alla configurazione da eseguire durante il primo avvio dell'applicazione;
    \item \textbf{documents}: contiene i componenti relativi alla gestione e alla visualizzazione dei documenti;
    \item \textbf{settings}: contiene i componenti relativi alla gestione delle impostazioni dell'applicazione, cioè il suo aspetto e la configurazione scelta.
\end{itemize}
La root del frontend corrisponde alla pagina \textbf{dashboard}, che contiene i componenti per il riepilogo e la navigazione tra le varie sezioni dell'applicazione.
I componenti grafici di base, condivisi tra le varie interfacce, sono contenuti nella cartella \textbf{components}, localizzata allo stesso livello di app. 

\subsubsection{Backend}
La struttura organizzativa del backend segue la seguente struttura:

\dirtree{%
.1 backend.
.2 adapter.
.3 \_in.
.4 web-- controllers.
.3 out -- implementazioni di Outbound Port.
.2 application.
.3 port.
.4 \_in -- Inbound Ports (Use Cases).
.4 out -- Outbound Ports.
.3 service -- implementazioni di Inbound Port.
.2 blueprints.
.2 domain -- classi di business.
}
Questa struttura riflette il modello architetturale scelto, facilitando il passaggio da progettazione a codifica.
\end{comment}



\subsection{Descrizione delle componenti}
L'architettura generale del sistema è composta da tre componenti: \textit{frontend\pg} e \textit{backend\pg} e database.

\subsubsection{Frontend}
Il frontend si occupa di fornire un'interfaccia grafica all'utente per dialogare con il sistema.
Inoltra le richieste dell'utente al backend e mostra i risultati ottenuti.

\subsubsection{Backend}
Il backend si occupa di elaborare le richieste degli utenti, interagendo con i sistemi di persistenza e i servizi esterni.
In particolare, il backend dialoga con il sistema di archiviazione documenti, il \textit{vector store\pg}, il database delle chat e con i modelli di intelligenza artificiale necessari per il corretto funzionamento dell'applicazione.

\subsubsection{Database}
Il database è responsabile della memorizzazione dei dati relativi alle chat, tra cui messaggi e relativi documenti rilevanti,
e alla configurazione attuale dell'utente.


\subsection{Assemblaggio delle componenti}
\subsubsection{Docker}
Le componenti sono assemblate tramite Docker Compose per facilitare l'esecuzione e la gestione di più container docker.

In particolare sono stati prodotti i seguenti container Docker:
\begin{itemize}
    \item \textbf{database}: espone l'istanza del database nella porta 5432, permettendo al backend di accedere ai dati relativi alle chat e alla configurazione dell'utente;
    \item \textbf{flaskapp}: espone la componente backend nella porta 4000, dando al frontend la possibilità di chiamare i servizi offerti;
    \item \textbf{nextapp}: espone il frontend dell'applicazione web nella porta 80, dando la possibilità all'utente di connettersi e interagire con il sistema.
\end{itemize}


\subsection{Struttura del sistema}

\subsubsection{Frontend}
La struttura organizzativa del frontend segue la struttura standard definita dal framework Next.js.
In particolare, all'interno della cartella app sono presenti le seguenti cartelle, che nel framework sopracitato corrispondono alle route visitabili dall'utente:
\begin{itemize}
    \item \textbf{chatbot}: contiene i componenti relativi alla gestione e alla visualizzazione delle chat;
    \item \textbf{configuration}: contiene i componenti relativi alla configurazione da eseguire durante il primo avvio dell'applicazione;
    \item \textbf{documents}: contiene i componenti relativi alla gestione e alla visualizzazione dei documenti;
    \item \textbf{settings}: contiene i componenti relativi alla gestione delle impostazioni dell'applicazione, cioè il suo aspetto e la configurazione scelta.
\end{itemize}
La root del frontend corrisponde alla pagina \textbf{dashboard}, che contiene i componenti per il riepilogo e la navigazione tra le varie sezioni dell'applicazione.
I componenti grafici di base, condivisi tra le varie interfacce, sono contenuti nella cartella \textbf{components}, localizzata allo stesso livello di app. 

\subsubsection{Backend}
La struttura organizzativa del backend segue la seguente struttura:

\dirtree{%
.1 backend.
.2 adapter.
.3 \_in.
.4 web-- controllers.
.3 out -- implementazioni di Outbound Port.
.2 application.
.3 port.
.4 \_in -- Inbound Ports (Use Cases).
.4 out -- Outbound Ports.
.3 service -- implementazioni di Inbound Port.
.2 blueprints.
.2 domain -- classi di business.
}
Questa struttura riflette il modello architetturale scelto, facilitando il passaggio da progettazione a \textit{codifica\pg}.


\newpage
\section{Architettura delle componenti}
\subsection{Frontend}



\subsubsection{Chatbot}
\subsubsubsection{Descrizione}
\subsubsubsection{Lista di sottocomponenti}
\begin{itemize} 
    \item \label{ChatContent}\textbf{ChatContent}: componente che si occupa di mostrare i dati della chat selezionata e di interagire con il \textit{chatbot\pg};
    \item \label{ChatForm}\textbf{ChatForm}: elemento che permette all'utente di inserire i messaggi e le richieste da fare al Chatbot;
    \item \label{ChatHeader}\textbf{ChatHeader}: componente che permette di visualizzare il titolo e le interazioni possibili con la chat corrente; 
    \item \label{ChatListSideBar}\textbf{ChatListSideBar}: componente che permette di navigare tra le chat salvate nel sistema e di visualizzarne le preview;
    \item \label{MessageCard}\textbf{MessageCard}: componente che rappresenta un messaggio in chat e tutte le sue informazioni.  
\end{itemize}


\subsubsubsection{Tracciamento dei requisiti}
\begin{xltabular}{\textwidth}{c|c}
\caption{Tracciamento dei requisiti nella componente Chatbot}\\
\textbf{\textit{Requisito\pg}} & \textbf{Soddisfacimento del requisito} \\
\endfirsthead
\caption[]{Tracciamento dei requisiti nella componente Chatbot (cont)}\\
\textbf{Requisito} & \textbf{Soddisfacimento del requisito} \\
\endhead
\multicolumn{2}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
RF.O.34  &  ChatListSideBar: vedi \vedi{ChatListSideBarDettaglio}. \\ %Visualizza lista chat e loro informazioni
\hline
RF.O.34.1 & ChatListSideBar: vedi \vedi{ChatListSideBarDettaglio}. \\ %singole chat in lista
\hline
RF.O.34.1.1 & ChatListSideBar: vedi \vedi{ChatListSideBarDettaglio}. \\%titolo
\hline
RF.O.34.1.2  & ChatListSideBar: vedi \vedi{ChatListSideBarDettaglio}. \\ %Visualizza timestamp
\hline
RF.O.34.1.3 & ChatListSideBar: vedi \vedi{ChatListSideBarDettaglio}. \\ %preview mess
\hline
RF.O.34.1.4 & ChatListSideBar: vedi \vedi{ChatListSideBarDettaglio}. \\% preview mitt
\hline
RF.O.35 & ChatListSideBar: vedi \vedi{ChatListSideBarDettaglio}. \\ %creare nuova chat
\hline
RF.O.36.1 & ChatListSideBar: vedi \vedi{ChatListSideBarDettaglio}. \\%visualizza messaggio errore
\hline
RF.O.37.1 & ChatHeader: vedi \vedi{ChatHeaderDettaglio}. \\% visualizza messaggio errore nell'eliminazione di una chat
\hline
RF.O.38.1 & ChatListSideBar: vedi \vedi{ChatListSideBarDettaglio}. \\ % visualizza messaggio errore nell'eliminazione di un insieme di chat
\hline
RF.O.38.2 &  ChatListSideBar: vedi \vedi{ChatListSideBarDettaglio}. \\% selezione più chat per eliminarle
\hline
RF.O.40.1 & ChatHeader: vedi \vedi{ChatHeaderDettaglio}. \\ %visualizza errore se rinomina titolo uguale ad altra chat
\hline
RF.O.41.1 & ChatHeader: vedi \vedi{ChatHeaderDettaglio}.\\%visualizza errore se rinomina titolo vuoto
\hline
RF.O.43 & ChatContent: vedi \vedi{ChatContentDettaglio}.\\% visualizzare il contenuto di una chat 
\hline
RF.O.43.1 & ChatContent: vedi \vedi{ChatContentDettaglio}.\\ % visualizza singoli mess
\hline
RF.O.43.1.1 &  MessageCard: vedi \vedi{MessageCardDettaglio}.\\% viasualizza contenuto testuale mess
\hline
RF.O.43.1.2 & MessageCard: vedi \vedi{MessageCardDettaglio}.\\ %visualizza orario mess
\hline
RF.D.44 & MessageCard: vedi \vedi{MessageCardDettaglio}.\\% %rispostachatbot con riferimento a documento
\hline
RF.D.48 & MessageCard: vedi \vedi{MessageCardDettaglio}.\\%copiare un messaggio
\hline
RF.O.51 & ChatForm: vedi \vedi{ChatFormDettaglio}.\\ %inserire messaggio in area di testo chat
\hline
RF.O.51.1 & ChatForm: vedi \vedi{ChatFormDettaglio}.\\%inserire messaggio testuale
\hline
RF.O.51.2 & ChatForm: vedi \vedi{ChatFormDettaglio}. \\% inserire messaggio vocale
\hline
RF.O.51.2.1 & ChatForm: vedi \vedi{ChatFormDettaglio}. \\ %attiva inserimento messaggio vocale
\hline
RF.O.51.2.2& ChatForm: vedi \vedi{ChatFormDettaglio}. \\%disattiva inserimento messaggio vocale
\hline
RF.O.53 & MessageCard: vedi \vedi{MessageCardDettaglio}.\\ %reso noto mittente per ogni mess
\end{xltabular}



    \subsubsection{Dashboard}
    \subsubsubsection{Descrizione}
    Pagina che raccoglie alcune funzionalità importanti dell'applicazione e i documenti e chat con cui l'utente ha interagito più recentemente.
    \subsubsubsection{Lista di sottocomponenti}
    \begin{itemize}
        \item \label{DashboardHeader}\textbf{DashboardHeader}: elemento che permette di accedere velocemente a delle funzioni principali dell'applicazione;
        \item \label{DocumentPreview}\textbf{DocumentPreview}: componente pop-up che permette di vedere una preview delle informazioni del documento in archivio a cui si riferisce;       
       % \item \label{RecentDocRecord}\textbf{RecentDocRecord}
        \item \label{LatestChatContent}\textbf{LatestChatContent}: componente che mostra il contenuto della chat con l'interazione più recente da parte dell'utente;
        \item \textbf{MessageCard}: vedi \vedi{MessageCard}; 
        \item \label{RecentChatsList}\textbf{RecentChatsList}: elenco di chat ordinate cronologicamnete con le quali l'utente ha interagito più recentemente;
        \item \label{RecentlyViewedTab}\textbf{RecentlyViewedTab}: elenco di documenti che l'utente ha visualizzato più recentemente;
        \item \label{RecentlyUploadedTab}\textbf{RecentlyUploadedTab}: elenco di documenti che l'utente ha caricato più recentemente.
       
    \end{itemize}
    \subsubsubsection{Tracciamento dei requisiti} -
    




\subsubsection{Documents}
\subsubsubsection{Descrizione}
\subsubsubsection{Lista di sottocomponenti}
\begin{itemize}
    \item \label{DocumentsList}\textbf{DocumentsList}: componente che permette di navigare tra i documenti presenti nel sistema e di interagire con essi; 
    \item \label{DocumentsListRow}\textbf{DocumentsListRow}: componente che permette di visualizzare le informazioni del documento, di eliminarlo o di modificarne lo status;
    \item \label{StagingArea}\textbf{StagingArea}: component componente che permette di caricare i documenti e successivamente di fare l'upload degli stessi;
    \item \label{StagingAreaRow}\textbf{StagingAreaRow}: componente che permette di interagire con i documenti caricati nell'area di staging.
    
\end{itemize}


\subsubsubsection{Tracciamento dei requisiti}
\begin{xltabular}{\textwidth}{c|c}
\caption{Tracciamento dei requisiti nella componente Documents}\\
\textbf{Requisito} & \textbf{Soddisfacimento del requisito} \\
\endfirsthead
\caption[]{Tracciamento dei requisiti nella componente Documents (cont)}\\
\textbf{Requisito} & \textbf{Soddisfacimento del requisito} \\
\endhead
\multicolumn{2}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
RF.O.15 & DocumentsList: vedi \vedi{DocumentsListDettaglio}.\\ %visualizzare i documenti presenti nel sistema di archiviazione
\hline
RF.O.15.1 & DocumentsListRow: vedi \vedi{DocumentsListRowDettaglio}.\\ %singoli docs in lista
\hline
RF.O.15.1.1 & DocumentsListRow: vedi \vedi{DocumentsListRowDettaglio}.\\%titolo
\hline
RF.O.15.1.2  &  DocumentsListRow: vedi \vedi{DocumentsListRowDettaglio}.\\ %Visualizza dimensione
\hline
RF.O.15.1.3 &  DocumentsListRow: vedi \vedi{DocumentsListRowDettaglio}.\\ %visualizza data caricamento
\hline
RF.O.15.1.4 &  DocumentsListRow: vedi \vedi{DocumentsListRowDettaglio}. \\% visualizza se occultato
\hline
RF.O.16 & StagingArea: vedi \vedi{StagingAreaDettaglio}. \\ 
\hline
RF.O.16.1 & StagingArea: vedi \vedi{StagingAreaDettaglio}. \\%pdf
\hline
RF.O.16.2 & StagingArea: vedi \vedi{StagingAreaDettaglio}. \\ %docs
\hline
RF.O.17 & StagingArea: vedi \vedi{StagingAreaDettaglio}. \\ % carica insieme documenti
\hline
RF.O.17.1 & StagingArea: vedi \vedi{StagingAreaDettaglio}. \\ 
\hline
RF.O.17.2 & StagingArea: vedi \vedi{StagingAreaDettaglio}. \\ 
\hline
RF.O.17.3 & StagingArea: vedi \vedi{StagingAreaDettaglio}. \\ 
\hline
RF.O.18 &  StagingArea: vedi \vedi{StagingAreaDettaglio}. \\ 
\hline
RF.O.18.1 & StagingArea: vedi \vedi{StagingAreaDettaglio}. \\  % visualizza errore sopra
\hline
RF.O.19 & StagingAreaRow: vedi \vedi{StagingAreaRowDettaglio}. \\ % rimuovi doc in staging area
\hline
RF.O.20 & StagingAreaRow: vedi \vedi{StagingAreaRowDettaglio}. \\  % rimuovi docs in staging area
\hline
RF.O.21.1 & StagingArea: vedi \vedi{StagingAreaDettaglio}.\\% poter scegliere se sostituire con il documento caricato
\hline
RF.O.21.2 & StagingArea: vedi \vedi{StagingAreaDettaglio}.\\% conferma sostituzione doc
\hline
RF.O.21.3 &  StagingArea: vedi \vedi{StagingAreaDettaglio}.\\ % annulla sostituzione doc
\hline
RF.O.21.4 &  StagingArea: vedi \vedi{StagingAreaDettaglio}.\\% poter scegliere se sostituire con il documento caricato
\hline
RF.O.21.5 & StagingArea: vedi \vedi{StagingAreaDettaglio}.\\ % conferma sostituzione docs
\hline
RF.O.21.6 & StagingArea: vedi \vedi{StagingAreaDettaglio}.\\% annulla sostituzione docs
\hline
RF.O.22.1.1 & StagingArea: vedi \vedi{StagingAreaDettaglio}.\\
\hline
RF.O.23.1.1 & StagingArea: vedi \vedi{StagingAreaDettaglio}.\\
\hline
RF.O.26.1.1  & DocumentsList: vedi \vedi{DocumentsListDettaglio}.\\% visualizza errore se fallisce eliminazione dal document store
\hline
RF.O.27.1 &  DocumentsListRow: vedi \vedi{DocumentsListRowDettaglio}.\\%Seleziona più documenti per eliminarli 
\hline
RF.O.28.1.1 & DocumentsListRow: vedi \vedi{DocumentsListRowDettaglio}. \\% poter visualizzare un errore se l’eliminazione di un insieme di documenti sul sistema di archiviazione fallisce.
\hline
RF.O.30.1 & DocumentsListRow: vedi \vedi{DocumentsListRowDettaglio}. \\ %Seleziona più documenti per occultarli
\hline
RF.O.32.1 & DocumentsListRow: vedi \vedi{DocumentsListRowDettaglio}.\\% Seleziona più documenti per riabilitarli
\end{xltabular}

%DOCUMENT VIEWER
\subsubsection{DocumentView}
\subsubsubsection{Descrizione}
Componente che permette visualizzare l'intero contenuto del documento salvato nel sistema di achiviazione e altre sue informazioni rilevanti.

\subsubsubsection{Lista di sottocomponenti}
\begin{itemize}
    \item \label{DocumentViewer}\textbf{DocumentViewer}: componente che permette di visionare per intero il documento selezionato.
\end{itemize}



\subsubsection{SettingsAppearance}
\subsubsubsection{Descrizione}
Pagina della finestra Settings che permette all'utente di modificare il tema dell'applicazione.
\subsubsubsection{Lista di sottocomponenti}
\begin{itemize}
    \item \label{ThemeSelection}\textbf{ThemeSelection}: componente che permette di scegliere il tema dell'applicazione.
\end{itemize}
\subsubsubsection{Tracciamento dei requisiti} -



\subsubsection{SettingsConfiguration}

\subsubsubsection{Descrizione}
Pagina della finestra Settings che permette di visualizzare e modificare alcuni elementi della configurazione del sistema.
\subsubsubsection{Lista di sottocomponenti}
\begin{itemize}
    \item \label{ChangeLLMConfiguration}\textbf{ChangeLLMConfiguration}: sezione che consente di cambiare LLM Model configurato;
    \item \label{CurrentConfigurationCarousel}\textbf{CurrentConfigurationCarousel}: componente che permette di conoscere la configurazione corrente di vector store, sistema di archiviazione documenti, embedding model e LLM;
    \item \label{DocumentStoreCard}\textbf{DocumentStoreCard}: elemento che contiene informazioni rilevanti di un sistema di archiviazione dei documenti;
    \item \label{EmbeddingModelCard}\textbf{EmbeddingModelCard}: elemento che contiene informazioni rilevanti di un modello di embeddings;
    \item \label{LLMCard}\textbf{LLMCard}: elemento che contiene informazioni rilevanti di un modello LLM; 
    \item \label{VectorStoreCard}\textbf{VectorStoreCard}: elemento che contiene informazioni rilevanti di un vector store.
    
    
\end{itemize}


\subsubsubsection{Tracciamento dei requisiti}
\begin{xltabular}{\textwidth}{c|c}
\caption{Tracciamento dei requisiti nella componente SettingsConfiguration}\\
\textbf{Requisito} & \textbf{Soddisfacimento del requisito} \\
\endfirsthead
\caption[]{Tracciamento dei requisiti nella componente SettingsConfiguration (cont)}\\
\textbf{Requisito} & \textbf{Soddisfacimento del requisito} \\
\endhead
\multicolumn{2}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
RF.O.2 & ChangeLLMConfiguration: vedi \vedi{ChangeLLMConfigurationDettaglio}. \\ 
\hline
RF.O.2.1 & ChangeLLMConfiguration: vedi \vedi{ChangeLLMConfigurationDettaglio}.\\ 
\hline
RF.O.6.1 & ChangeLLMConfiguration: vedi \vedi{ChangeLLMConfigurationDettaglio}.\\
\hline
RF.O.10 & LLMCard: vedi \vedi{LLMCardDettaglio}. \\
\hline
RF.O.10.1 & LLMCard: vedi \vedi{LLMCardDettaglio}. \\
\hline
RF.O.10.2 & LLMCard: vedi \vedi{LLMCardDettaglio}. \\
\hline
RF.O.10.3 & LLMCard: vedi \vedi{LLMCardDettaglio}. \\
\hline
RF.O.10.4 & LLMCard: vedi \vedi{LLMCardDettaglio}. \\
\hline
RF.O.10.5 & LLMCard: vedi \vedi{LLMCardDettaglio}. \\
\hline
RF.O.11 &  VectorStoreCard: vedi \vedi{VectorStoreCardDettaglio}.\\ 
\hline
RF.O.11.1 &  VectorStoreCard: vedi \vedi{VectorStoreCardDettaglio}.\\ 
\hline
RF.O.11.2 &  VectorStoreCard: vedi \vedi{VectorStoreCardDettaglio}.\\ 
\hline
RF.O.11.3 &  VectorStoreCard: vedi \vedi{VectorStoreCardDettaglio}.\\ 
\hline
RF.O.11.4 &  VectorStoreCard: vedi \vedi{VectorStoreCardDettaglio}.\\ 
\hline
RF.O.11.5 &  VectorStoreCard: vedi \vedi{VectorStoreCardDettaglio}.\\ 
\hline
RF.O.12 &  EmbeddingModelCard: vedi \vedi{EmbeddingModelCardDettaglio}. \\
\hline
RF.O.12.1 &  EmbeddingModelCard: vedi \vedi{EmbeddingModelCardDettaglio}. \\
\hline
RF.O.12.2 &  EmbeddingModelCard: vedi \vedi{EmbeddingModelCardDettaglio}. \\
\hline
RF.O.12.3 &  EmbeddingModelCard: vedi \vedi{EmbeddingModelCardDettaglio}. \\
\hline
RF.O.12.4 &  EmbeddingModelCard: vedi \vedi{EmbeddingModelCardDettaglio}. \\
\hline
RF.O.12.5 &  EmbeddingModelCard: vedi \vedi{EmbeddingModelCardDettaglio}. \\
\hline
RF.O.13 & DocumentStoreCard: vedi \vedi{DocumentStoreCardDettaglio}. \\ 
\hline
RF.O.13.1 & DocumentStoreCard: vedi \vedi{DocumentStoreCardDettaglio}. \\ 
\hline
RF.O.13.2 & DocumentStoreCard: vedi \vedi{DocumentStoreCardDettaglio}. \\ 
\hline
RF.O.13.3 & DocumentStoreCard: vedi \vedi{DocumentStoreCardDettaglio}. \\ 
\hline
RF.O.13.4 & DocumentStoreCard: vedi \vedi{DocumentStoreCardDettaglio}. \\ 
\hline
RF.O.13.5 & DocumentStoreCard: vedi \vedi{DocumentStoreCardDettaglio}. \\ 
\end{xltabular}



\subsubsection{SetUp (Primo avvio)}
\subsubsubsection{Descrizione}
Pagina che permette di inizializzare le configurazioni di vector store, sistema di archiviazione dei documenti, modello di embeddings e LLM al primo avvio dell'applicazione.
\subsubsubsection{Lista di sottocomponenti}
\begin{itemize}
    \item \label{ConfirmConfiguration}: per confermare la configurazione scelta;
    \item \textbf{DocumentStoreCard}: vedi \vedi{DocumentStoreCard};
    \item \label{DocumentStoreInit}\textbf{DocumentStoreInit}: componente che permette di scegliere e inizializzare la configurazione del sistema di archiviazione dei documenti;
    \item \textbf{EmbeddingModelCard}: vedi \vedi{EmbeddingModelCard};
    \item \label{EmbeddingModelInit}\textbf{EmbeddingModelInit}: componente che permette di scegliere e inizializzare la configurazione del modello di embedding;
    \item \textbf{LLMCard}: vedi \vedi{LLMCard};
    \item \label{LLMModelInit}\textbf{LLMModelInit}: componente che permette di scegliere e inizializzare la configurazione del modello LLM;
    \item \textbf{VectorStoreCard}: vedi \vedi{VectorStoreCard};
    \item \label{VectorStoreInit}\textbf{VectorStoreInit}: componente che permette di scegliere e inizializzare la configurazione del vector store.    
\end{itemize}


\subsubsubsection{Tracciamento dei requisiti}
\begin{xltabular}{\textwidth}{c|c}
\caption{Tracciamento dei requisiti nella componente SetUp}\\
\textbf{Requisito} & \textbf{Soddisfacimento del requisito} \\
\endfirsthead
\caption[]{Tracciamento dei requisiti nella componente SetUp (cont)}\\
\textbf{Requisito} & \textbf{Soddisfacimento del requisito} \\
\endhead
\multicolumn{2}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
RF.O.1.1.1 & LLMModelInit: vedi \vedi{LLMModelInitDettaglio}.\\ %selezionare modello llm presente al primo avvio
\hline
RF.O.1.2.1 & VectorStoreInit: vedi \vedi{VectorStoreInitDettaglio}.\\  % selezionare vector db  presente al primo avvio
\hline
RF.O.1.3.1 & EmbeddingModelInit: vedi \vedi{EmbeddingModelInitDettaglio}.\\   %selezionare modello embeddingspresente al primo avvio
\hline
RF.O.1.4.1 & DocumentStoreInit: vedi \vedi{DocumentStoreInitDettaglio}.\\ % selezionare sistema di archiviazione presente al primo avvio
\hline
RF.O.3 & VectorStoreInit: vedi \vedi{VectorStoreInitDettaglio}.\\ %seleziona
\hline
RF.O.3.1 & VectorStoreCard: vedi \vedi{VectorStoreCardDettaglio}.\\  %se
\hline
RF.O.4 & EmbeddingModelInit: vedi \vedi{EmbeddingModelInitDettaglio}.\\  %sel
\hline
RF.O.4.1 & EmbeddingModelCard: vedi \vedi{EmbeddingModelCardDettaglio}.\\  %se
\hline
RF.O.5 & DocumentStoreInit: vedi \vedi{DocumentStoreInitDettaglio}.\\ %s
\hline
RF.O.5.1 & DocumentStoreCard: vedi \vedi{DocumentStoreCardDettaglio}.\\

\end{xltabular}



\subsubsection{SideBar}
\subsubsubsection{Descrizione}
Componente fissa dell'interfaccia utente che permette di navigare tramite tabs le seguenti pagine dell'applicazione:\\
\begin{itemize}
    \item Chatbot;
    \item Dashboard;
    \item Documents;
    \item Settings.
\end{itemize}
\subsubsubsection{Lista di sottocomponenti}
\begin{itemize}
    \item \label{NavigationMenu}\textbf{NavigationMenu}: componente che permette di raggiungere altre pagine dell'applicazione;
    \item \label{SettingShortcut}\textbf{SettingShortcut}: componente che permette di raggiungere la pagina Settings per modificare le impostazioni di sistema.
\end{itemize}
\subsubsubsection{Tracciamento dei requisiti} -




% - X ogni componente frontend:
    % - definizione e utilità
    % - elementi grafici (anche a seguito di azioni)
    % - tracciamento requisiti soddisfatti


    %- X ogni sottocomponente della componente:
    %     - nome: definizione e utilità (componente che serve a ...)

\subsection{Backend}
% - X ogni componente backend:
    % - definizione e utilità
    % - route API
    % - metodo HTTP
    % - parametri richiesta HTTP
    % - tabella possibili risposte (status code, condizione, tipo di ritorno(header o body))
    % - tracciamento requisiti soddisfatti
    
    % - X ogni sottocomponente della componente:
    %     - nome: definizione e utilità (interfaccia/classe che serve a ...)
    %     - se sono classi, indicare "interfacce implementate" e/o "classi astratte estese"

\subsubsection{AskChatbot}
\subsubsubsection{Descrizione}
Questa componente ha il compito di ottenere una risposta ad un messaggio da parte del chatbot.
È costituita da:
\begin{itemize}
    \item \textbf{Route \textit{API\pg}}: /askChatbot;
    \item \textbf{Metodo}: POST;
    \item \textbf{Lista parametri HTTP}: 
    \begin{itemize}
        \item \code{message}: messaggio da parte dell'utente;
        \item \code{chatId}: id della chat a cui appartiene il messaggio.
    \end{itemize}
    \item \textbf{Implementazione generale}: La componente viene implementata dal blueprint \code{askChatbot} che esegue i seguenti controlli:
    \begin{enumerate}
        \item Il parametro \code{message} non deve essere nullo nè vuoto;
        \item Il parametro \code{chatId} deve essere valido.
    \end{enumerate}
\end{itemize}
\subsubsubsection{Esiti possibili}
\begin{xltabular}{\textwidth}{c|X|X}
\caption{Esiti possibili AskChatbot}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endfirsthead
\caption[]{Esiti possibili AskChatbot (cont)}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endhead
\multicolumn{3}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
200 & Risposta ottenuta con successo. & - \\
\hline
400 & Il parametro \code{message} è nullo. & Parametri insufficienti. \\
\hline
400 & Il parametro \code{message} è vuoto. & Filtro '{message}' non valido. \\
\hline
400 & Il parametro \code{chatId} è nullo, non un numero o un numero negativo. & Filtro '{message}' non valido. \\
\hline
500 & Risposta del chatbot fallita. & Errore di generazione della risposta. \\
\end{xltabular}

    


\subsubsubsection{Lista sottocomponenti}
\begin{itemize}
    \item \label{AskChatbotController}\textbf{AskChatbotController}: \textit{classe\pg} controller che si occupa del richiedere una risposta al chatbot ad un messaggio appartente ad una chat allo use case AskChatbotUseCase;
    \item \label{AskChatbotLangchain}\textbf{AskChatbotLangchain}: classe che implementa la porta AskChatbotPort, adattando la chiamata di AskChatbotService a classi offerte dal framework Langchain;
    \item \label{AskChatbotPort}\textbf{AskChatbotPort}: interfaccia che rappresenta la porta in uscita per effettuare la richiesta di una risposta al chatbot ad un messaggio appartente ad una chat;%, con storicizzazione all'interno del database delle chat;
    \item \label{AskChatbotService}\textbf{AskChatbotService}: classe service che implementa lo use case AskChatbotUseCase;
    \item \label{AskChatbotUseCase}\textbf{AskChatbotUseCase}: interfaccia use case che rappresenta la porta della business logic in entrata per richiedere una risposta al chatbot ad un messaggio appartente ad una chat;
    %\item \label{ChatbotLangchain}\textbf{ChatbotLangchain}: classe che permette di interagire con un oggetto langchain.Chain;
    \item \label{ChatHistoryManager}\textbf{ChatHistoryManager}: classe per interagire con le chat come oggetti lanchain.Memory;
    \item \label{ChatId}\textbf{ChatId}: classe di business che rappresenta l'id di una chat utilizzato nella ricerca;
    \item \label{ChatOperationResponse}\textbf{ChatOperationResponse}: classe che contiene l'esito di un'operazione effettuata su una chat;
    \item \label{Message}\textbf{Message}: classe di business che rappresenta un messaggio di una chat;
    \item \label{MessageResponse}\textbf{MessageResponse}: classe che rappresenta un messaggio risposta del chatbot;
    \item \label{MessageSender}\textbf{MessageSender}: classe di business che rappresenta il mittente di un messaggio;
    \item \label{PersistChatPort}\textbf{PersistChatPort}: interfaccia che rappresenta la porta in uscita verso il database per la storicizzazione delle chat;
    \item \label{PostgresChat}\textbf{PostgresChat}: classe di persistence che rappresenta una chat;
    \item \label{PostgresChatOperationResponse}\textbf{PostgresChatOperationResponse}: classe che contiene l'esito di un'operazione effettuata su Postgres riguardo una chat;
    \item \label{PostgresMessage}\textbf{PostgresMessage}: classe di persistence che rappresenta un messaggio;
    \item \label{PostgresMessageSenderType}\textbf{PostgresMessageSenderType}: enumeration che rappresenta i valori che può assumere il campo sender di un PostgresMessage;
    \item \label{PostgresPersistChat}\textbf{PostgresPersistChat}: classe adapter che implementa la porta PersistChatPort, adattando la chiamata di persistChat a PostgresChatORM;
    \item \label{PostgresChatORM}\textbf{PostgresChatORM}: classe che si occupa di effettuare le operazioni su Postgres configurato, cioè il sistema di storicizzazione delle chat dell'applicazione.
    
\end{itemize}

\subsubsubsection{Tracciamento dei requisiti}
\begin{xltabular}{\textwidth}{c|c}
\caption{Tracciamento dei requisiti nella componente AskChatbot}\\
\textbf{Requisito} & \textbf{Soddisfacimento del requisito} \\
\endfirsthead
\caption[]{Tracciamento dei requisiti nella componente AskChatbot (cont)}\\
\textbf{Requisito} & \textbf{Soddisfacimento del requisito} \\
\endhead
\multicolumn{2}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
RF.O.35 & PostgresChatORM: vedi \vedi{PostgresChatORMDettaglio}.\\
\hline
RF.O.36 & PostgresChatORM: vedi \vedi{PostgresChatORMDettaglio}.\\
\hline
RF.O.52 &  AskChatbotService: vedi \vedi{AskChatbotServiceDettaglio}.\\
\hline 
RF.D.56 &  AskChatbotService: vedi \vedi{AskChatbotServiceDettaglio}.\\
\hline
RF.OP.57 & AskChatbotService: vedi \vedi{AskChatbotServiceDettaglio}.\\
\hline
RF.O.59 &  AskChatbotService: vedi \vedi{AskChatbotServiceDettaglio}.\\
\hline
RF.O.60 &  AskChatbotService: vedi \vedi{AskChatbotServiceDettaglio}.\\
\end{xltabular}




\subsubsection{ChangeConfiguration} 
\subsubsubsection{Descrizione}
Questa componente ha il compito di cambiare la configurazione del modello LLM del sistema.
È costituita da:
\begin{itemize}
    \item \textbf{Route \textit{API\pg}}: /changeConfiguration;
    \item \textbf{Metodo}: POST;
    \item \textbf{Lista parametri HTTP}: 
    \begin{itemize}
        \item \code{LLMModel}: stringa che rappresenta il modello LLM da configurare.
    \end{itemize}
    \item \textbf{Implementazione generale}: La componente viene implementata dal blueprint \code{changeConfiguration} che esegue i seguenti controlli:
    \begin{enumerate}
        \item Il parametro \code{LLMModel} non deve essere nullo nè vuoto.
    \end{enumerate}
\end{itemize}
\subsubsubsection{Esiti possibili}
\begin{xltabular}{\textwidth}{c|X|X}
\caption{Esiti possibili ChangeConfiguration}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endfirsthead
\caption[]{Esiti possibili ChangeConfiguration (cont)}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endhead
\multicolumn{3}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
200 & Configurazione avvenuta con successo. & - \\
\hline
400 & Il parametro \code{LLMModel} è nullo. & Parametri insufficienti. \\
\hline
400 & Il parametro \code{LLMModel} è vuoto. & Modello LLM '{LLMModel}' non valido. \\
\hline
500 & Configurazione fallita. & Errore nell'aggiornamento del modello LLM. \\
\end{xltabular}




\subsubsubsection{Lista sottocomponenti}
\begin{itemize}
    \item \label{ChangeConfigurationController}\textbf{ChangeConfigurationController}: classe controller che si occupa del cambio del modello LLM;
    \item \label{ChangeConfigurationPort}\textbf{ChangeConfigurationPort}: interfaccia che rappresenta la porta in uscita verso il database, per effettuare il cambio di modello LLM;
    \item \label{ChangeConfigurationPostgres}\textbf{ChangeConfigurationPostgres}: classe che implementa ChangeConfigurationPort, adattando la chiamata di ChangeConfigurationService a PostgresConfigurationORM;
    \item \label{ChangeConfigurationService}\textbf{ChangeConfigurationService}: classe service che implementa lo use case ChangeConfigurationUseCase;
    \item \label{ChangeConfigurationUseCase}\textbf{ChangeConfigurationUseCase}: interfaccia use case che rappresenta la porta della business logic in entrata per eseguire il cambio della configurazione del modello LLM;
    \item \label{ConfigurationOperationResponse}\textbf{ConfigurationOperationResponse}:  classe che contiene l'esito di un'operazione eseguita sulla configurazione del modello LLM;
    \item \label{PostgresConfigurationOperationResponse}\textbf{PostgresConfigurationOperationResponse}: classe che contiene l'esito di un'operazione effettuata su Postgres riguardo la configurazione del modello LLM;
    \item \label{PostgresConfigurationORM}\textbf{PostgresConfigurationORM}: classe che si occupa di effettuare le operazioni su Postgres configurato, cioè dove viene storicizzata la configurazione del sistema.


\end{itemize}

\subsubsubsection{Tracciamento dei requisiti}
\begin{xltabular}{\textwidth}{c|c}
\caption{Tracciamento dei requisiti nell componente ChangeConfiguration}\\
\textbf{Requisito} & \textbf{Soddisfacimento del requisito} \\
\endfirsthead
\caption[]{Tracciamento dei requisiti nell componente ChangeConfiguration (cont)}\\
\textbf{Requisito} & \textbf{Soddisfacimento del requisito} \\
\endhead
\multicolumn{2}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
RF.O.6 & ChangeConfigurationService: vedi \vedi{ChangeConfigurationServiceDettaglio}.\\

\end{xltabular}



\subsubsection{ConcealDocuments}
\subsubsubsection{Descrizione}
Questa componente ha il compito di occultare gli embeddings dei documenti indicati dall'utente.
È costituita da:
\begin{itemize}
    \item \textbf{Route API}: /concealDocuments;
    \item \textbf{Metodo}: POST;
    \item \textbf{Lista parametri HTTP}: 
    \begin{itemize}
        \item \code{documentIds}: una lista di stringhe che rappresentano gli id dei documenti da occultare.
    \end{itemize}
    \item \textbf{Implementazione generale}: La componente viene implementata dal blueprint \code{concealDocuments} che esegue i seguenti controlli:
    \begin{enumerate}
        \item Il parametro \code{documentIds} non deve essere nullo nè vuoto.
    \end{enumerate}
\end{itemize}
\subsubsubsection{Esiti possibili}
\renewcommand{\arraystretch}{1.5}
\begin{xltabular}{\textwidth}{c|X|X}
\caption{Esiti possibili ConcealDocuments}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endfirsthead
\caption[]{Esiti possibili ConcealDocuments (cont)}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endhead
\multicolumn{3}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
200 & \textit{Occultamento\pg} avvenuto con successo. & - \\
\hline
400 & Il parametro \code{documentIds} è nullo. & Parametri insufficienti. \\
\hline
400 & La lunghezza del parametro \code{documentIds} è 0. & Nessun id di documento specificato.\\
\hline
400 & Un id di \code{documentIds} è vuoto. & Id di documento '{id}' non valido. \\
\hline
500 & Occultamento fallito. & Errore nell'occultamento dei documenti.\\
\end{xltabular}




\subsubsubsection{Lista sottocomponenti}
\begin{itemize}
    \item \label{ConcealDocumentsController}\textbf{ConcealDocumentsController}: classe controller che si occupa del passaggio di una lista di DocumentId allo use case ConcealDocumentsUseCase a partire da una lista di stringhe che rappresentano l'id dei documenti da occultare;
    \item \label{ConcealDocumentsPort}\textbf{ConcealDocumentsPort}: interfaccia che rappresenta la porta per effettuare l'occultamento dei documenti nel vector store;
    \item \label{ConcealDocumentsService}\textbf{ConcealDocumentsService}: classe service che implementa lo use case ConcealDocumentsUseCase;
    \item \label{ConcealDocumentsUseCase}\textbf{ConcealDocumentsUseCase}: interfaccia use case che rappresenta la porta della business logic in entrata per effettuare l'occultamento dei documenti;
    \item \label{ConcealDocumentsVectorStore}\textbf{ConcealDocumentsVectorStore}: classe adapter che implementa la porta ConcealDocumentsPort, adattando la chiamata di ConcealDocumentsService a VectorStoreManager;
    \item \label{DocumentId}\textbf{DocumentId}: classe di business che rappresenta l'id di un documento;
    \item \label{DocumentOperationResponse}\textbf{DocumentOperationResponse}: classe che contiene l'esito di un'operazione effettuata su un documento;
    \item \label{VectorStoreChromaDBManager}\textbf{VectorStoreChromaDBManager}: classe che implementa VectorStoreManager, offrendo la possibilità di dialogare con il vector store Chroma;
    \item \label{VectorStoreDocumentOperationResponse} \textbf{VectorStoreDocumentOperationResponse}: classe che contiene l'esito di un'operazione effettuata su un vector store riguardo un documento;
    \item \label{VectorStoreManager}\textbf{VectorStoreManager}: interfaccia che rende disponibile metodi per dialogare con i vector store;
    \item \label{VectorStorePineconeManager}\textbf{VectorStorePineconeManager}: classe che implementa VectorStoreManager, offrendo la possibilità di dialogare con il vector store Pinecone.
\end{itemize}


\subsubsubsection{Tracciamento dei requisiti}
\begin{xltabular}{\textwidth}{c|c}
\caption{Tracciamento dei requisiti nella componente ConcealDocuments}\\
\textbf{Requisito} & \textbf{Soddisfacimento del requisito} \\
\endfirsthead
\caption[]{Tracciamento dei requisiti nella componente ConcealDocuments (cont)}\\
\textbf{Requisito} & \textbf{Soddisfacimento del requisito} \\
\endhead
\multicolumn{2}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
RF.O.29 & ConcealDocumentsService: vedi \vedi{ConcealDocumentsServiceDettaglio}.\\
\hline
RF.O.30 & ConcealDocumentsService: vedi \vedi{ConcealDocumentsServiceDettaglio}. \\
\end{xltabular}

\subsubsection{ConfigurationManager}
\subsubsubsection{Descrizione}
Questa componente ha il compito di gestire la configurazione del sistema.
    

È costituita da:
\begin{itemize}
    \item \textbf{Route API}:%TODO ;
    \item \textbf{Metodo}:%TODO ;
    \item \textbf{Lista parametri HTTP}: 
    \begin{itemize}
        \item %TODO
    \end{itemize}
\end{itemize}
\subsubsubsection{Esiti possibili ConfigurationManager}
\renewcommand{\arraystretch}{1.5}
\begin{xltabular}{\textwidth}{c|X|X}
\caption{Esiti possibili }\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endfirsthead
\caption[]{Esiti possibili ConfigurationManager (cont)}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endhead
\multicolumn{3}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
 - & - & - \\
\end{xltabular}

\subsubsubsection{Tracciamento dei requisiti}
\begin{itemize}
        \item 
       
\end{itemize}
\subsubsubsection{Lista sottocomponenti}
\begin{itemize}
    \item \label{ConfigurationManager}\textbf{ConfigurationManager}: classe che espone \textit{metodi\pg} per ottenere le porte in uscita delle componenti del sistema;
    \item \label{PostgresConfiguration}\textbf{PostgresConfiguration}: classe di persistence che rappresenta la configurazione del sistema di userId, vector store, document store, LLM ed embedding model su Postgres;
    \item \textbf{PostgresConfigurationORM}: vedi \vedi{PostgresConfigurationORM};
    \item \label{PostgresDocumentStoreConfiguration}\textbf{PostgresDocumentStoreConfiguration}: classe di persistence che rappresenta la configurazione di un document store;
    \item \label{PostgresDocumentStoreType}\textbf{PostgresDocumentStoreType}: enumeration che rappresenta i valori che può assumere il campo \code{name} in PostgresDocumentStoreConfiguration;

    \item \label{PostgresEmbeddingModelConfiguration}\textbf{PostgresEmbeddingModelConfiguration}: classe di persistence che rappresenta la configurazione di un embedding model;
    \item \label{PostgresEmbeddingModelType}\textbf{PostgresEmbeddingModelType}: enumeration che rappresenta i valori che può assumere il campo \code{name} in PostgresEmbeddingModelConfiguration;
    \item \label{PostgresLLMModelConfiguration}\textbf{PostgresLLMModelConfiguration}: classe di persistence che rappresenta la configurazione di un modello LLM;
    \item \label{PostgresLLMModelType}\textbf{PostgresLLMModelType}: enumeration che rappresenta i valori che può assumere il campo \code{name} in PostgresLLMModelConfiguration;

    \item \label{PostgresVectorStoreConfiguration}\textbf{PostgresVectorStoreConfiguration}: classe di persistence che rappresenta la configurazione di un vector store su Postgres;
    \item \label{PostgresVectorStoreType}\textbf{PostgresVectorStoreType}: enumeration che rappresenta i valori che può assumere il campo \code{name} in PostgresVectorStoreConfiguration.
   
    
\end{itemize}

\subsubsection{DeleteChats}
\subsubsubsection{Descrizione}
Questa componente ha il compito di eliminare una lista di chat, aggiornando di conseguenza il database utilizzato per la storicizzazione delle chat.
È costituita da:
\begin{itemize}
    \item \textbf{Route API}: /deleteChats;
    \item \textbf{Metodo}: POST;
    \item \textbf{Lista parametri HTTP}: 
    \begin{itemize}
        \item \code{chatIds}: lista di Id utilizzati per identificare univocamente le chat.
    \end{itemize}
    \item \textbf{Implementazione generale}: La componente viene implementata dal blueprint \code{deleteChats} che esegue i seguenti controlli:
    \begin{enumerate}
        \item Il parametro \code{chatIds} non deve essere nullo nè vuoto.
    \end{enumerate}
\end{itemize}
\subsubsubsection{Esiti possibili}
\renewcommand{\arraystretch}{1.5}
\begin{xltabular}{\textwidth}{c|X|X}
\caption{Esiti possibili DeleteChats}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endfirsthead
\caption[]{Esiti possibili DeleteChats (cont)}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endhead
\multicolumn{3}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
200 & Eliminazione avvenuta con successo. & - \\
\hline
400 & Il parametro \code{chatIds} è nullo. & Parametri insufficienti. \\
\hline
400 & La lunghezza del parametro \code{chatIds} è 0. & Nessun chat id specificato.\\
\hline
400 & Un id di \code{chatIds} è vuoto. & Chat id '{Id}' non valido. \\
\hline
500 & Eliminazione fallita. & Errore nell' eliminazione delle chat. \\
\end{xltabular}



\subsubsubsection{Lista sottocomponenti}
\begin{itemize}
    \item \textbf{ChatId}: Vedi \vedi{ChatId}
    \item \textbf{ChatOperationResponse}: vedi \vedi{ChatOperationResponse};
    \item \label{DeleteChatsController}\textbf{DeleteChatsController}: classe controller che si occupa del passaggio allo use case CreateChatUseCase di interi rappresentanti gli id di una lista di chat per eseguire la loro eliminazione;
    \item \label{DeleteChatsPort}\textbf{DeleteChatsPort}: interfaccia che rappresenta la porta in uscita per effettuare l'eliminazione di una lista di chat verso il database per la storicizzazione delle chat;
    \item \label{DeleteChatsPostgres}\textbf{DeleteChatsPostgres}: classe che implementa la porta DeleteChatPort, adattando la chiamata di DeleteChatsService a PostgresChatORM;
    \item \label{DeleteChatsService}\textbf{DeleteChatsService}: classe service che implementa lo use case DeleteChatsUseCase;
    \item \label{DeleteChatsUseCase}\textbf{DeleteChatsUseCase}: interfaccia use case che rappresenta la porta della business logic in entrata per effettuare l'eliminazione di una lista di chat;
    \item \textbf{PostgresChatOperationResponse}: vedi \vedi{PostgresChatOperationResponse};
    \item \textbf{PostgresChatORM}: vedi \vedi{PostgresChatORM}.
\end{itemize}
 
\subsubsubsection{Tracciamento dei requisiti}
\begin{xltabular}{\textwidth}{c|c}
\caption{Tracciamento dei requisiti nella componente DeleteChats}\\
\textbf{Requisito} & \textbf{Soddisfacimento del requisito} \\
\endfirsthead
\caption[]{Tracciamento dei requisiti nella componente DeleteChats (cont)}\\
\textbf{Requisito} & \textbf{Soddisfacimento del requisito} \\
\endhead
\multicolumn{2}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
RF.O.37 & DeleteChatsService: vedi \vedi{DeleteChatsServiceDettaglio}.\\
\hline
RF.O.38 & DeleteChatsService: vedi \vedi{DeleteChatsServiceDettaglio}.\\
\end{xltabular}



\subsubsection{DeleteDocuments}
\subsubsubsection{Descrizione}
Questa componente ha il compito di eliminare una lista di documenti e i loro rispettivi embeddings.
È costituita da:
\begin{itemize}
    \item \textbf{Route API}: /deleteDocuments;
    \item \textbf{Metodo}: POST;
    \item \textbf{Lista parametri HTTP}: 
    \begin{itemize}
        \item \code{documentIds}: una lista di stringhe che rappresentano gli id dei documenti da eliminare.
    \end{itemize}
    \item \textbf{Implementazione generale}: La componente viene implementata dal blueprint \code{deleteDocuments} che esegue i seguenti controlli:
    \begin{enumerate}
        \item Il parametro \code{documentIds} non deve essere nullo nè vuoto.
    \end{enumerate}
\end{itemize}
\subsubsubsection{Esiti possibili}
\renewcommand{\arraystretch}{1.5}
\begin{xltabular}{\textwidth}{c|X|X}
\caption{Esiti possibili DeleteDocuments}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endfirsthead
\caption[]{Esiti possibili DeleteDocuments (cont)}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endhead
\multicolumn{3}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
200 & Eliminazione avvenuta con successo. & - \\
\hline
400 & Il parametro \code{documentIds} è nullo. & Parametri insufficienti. \\
\hline
400 & La lunghezza del parametro \code{documentIds} è 0. & Nessun id di documento specificato.\\
\hline
400 & Un id di \code{documentIds} è vuoto. & Id di documento '{id}' non valido. \\
\hline
500 & Eliminazione fallita. & Errore nell'eliminazione dei documenti.
\end{xltabular}



\subsubsubsection{Lista sottocomponenti}
\begin{itemize}
    \item \label{AWSDocumentOperationResponse}\textbf{AWSDocumentOperationResponse}: classe che contiene l'esito di un'operazione effettuata su un AWS S3 riguardo un documento;
    \item \label{AWSS3Manager}\textbf{AWSS3Manager}: classe che si occupa di effettuare le operazioni sul bucket di Amazon S3 configurato, cioè il sistema di archiviazione documenti dell'applicazione;
    \item \label{DeleteDocuments}\textbf{DeleteDocuments}: classe che si occupa di inoltrare la richiesta di eliminare una lista di documenti nella porta esterna DeleteDocumentsPort diretta verso il sistema di archiviazione;
    \item \label{DeleteDocumentsAWSS3}\textbf{DeleteDocumentsAWSS3}: classe adapter che implementa la porta DeleteDocumentsPort, adattando la chiamata di DeleteDocuments a AWSS3Manager;
    \item \label{DeleteDocumentsController}\textbf{DeleteDocumentsController}: classe controller che si occupa del passaggio di una lista di DocumentId allo use case DeleteDocumentsUseCase a partire da una lista di stringhe che rappresentano gli id dei documenti da eliminare;
    \item \label{DeleteDocumentsEmbeddings}\textbf{DeleteDocumentsEmbeddings}: classe che si occupa di eliminare gli embeddings di una lista di documenti nella porta esterna DeleteEmbeddingsPort diretta verso il vector store;
    \item \label{DeleteDocumentsPort}\textbf{DeleteDocumentsPort}: interfaccia che rappresenta la porta in uscita per eliminare una lista di documenti dal sistema di archiviazione;
    \item \label{DeleteDocumentsService}\textbf{DeleteDocumentsService}: classe service che implementa lo use case DeleteDocumentsUseCase;
    \item \label{DeleteDocumentsUseCase}\textbf{DeleteDocumentsUseCase}: interfaccia use case che rappresenta la porta della business logic in entrata per eliminare i documenti;
    \item \label{DeleteEmbeddingsPort}\textbf{DeleteEmbeddingsPort}: interfaccia che rappresenta la porta in uscita per eliminare gli embeddings di una lista di documenti dal vector store;
    \item \label{DeleteEmbeddingsVectorStore}\textbf{DeleteEmbeddingsVectorStore}: classe adapter che implementa la porta DeleteEmbeddingsPort, adattando la chiamata di DeleteDocumentsEmbeddings a VectorStoreManager;
    \item \textbf{DocumentId}: vedi \vedi{DocumentId};
    \item \textbf{DocumentOperationResponse}: vedi \vedi{DocumentOperationResponse};
    \item \textbf{VectorStoreChromaDBManager}: vedi \vedi{VectorStoreChromaDBManager};
    \item \textbf{VectorStoreDocumentOperationResponse}: vedi \vedi{VectorStoreDocumentOperationResponse};
    \item \textbf{VectorStoreManager}: vedi \vedi{VectorStoreManager};
    \item \textbf{VectorStorePineconeManager}: vedi \vedi{VectorStorePineconeManager}.
\end{itemize}

\subsubsubsection{Tracciamento dei requisiti}
\begin{xltabular}{\textwidth}{c|c}
\caption{Tracciamento dei requisiti nella componente DeleteDocuments}\\
\textbf{Requisito} & \textbf{Soddisfacimento del requisito} \\
\endfirsthead
\caption[]{Tracciamento dei requisiti nella componente DeleteDocuments (cont)}\\
\textbf{Requisito} & \textbf{Soddisfacimento del requisito} \\
\endhead
\multicolumn{2}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
RF.O.25 & DeleteDocumentsService: vedi \vedi{DeleteDocumentsServiceDettaglio}.\\
\hline
RF.O.26 & DeleteDocuments: vedi \vedi{DeleteDocumentsDettaglio}.\\
\hline
RF.O.26.1 & DeleteDocuments: vedi \vedi{DeleteDocumentsDettaglio}.\\
\hline
RF.O.26.2 & DeleteDocumentsEmbeddings: vedi \vedi{DeleteDocumentsEmbeddingsDettaglio}.\\
\hline
RF.O.26.3 & DeleteDocumentsEmbeddings: vedi \vedi{DeleteDocumentsEmbeddingsDettaglio}.\\
\hline
RF.O.27 & DeleteDocumentsService: vedi \vedi{DeleteDocumentsServiceDettaglio}.\\
\hline
RF.O.28 & DeleteDocuments: vedi \vedi{DeleteDocumentsDettaglio}.\\
\hline
RF.O.28.1 &DeleteDocuments: vedi \vedi{DeleteDocumentsDettaglio}.\\
\hline
RF.O.28.2 & DeleteDocumentsEmbeddings: vedi \vedi{DeleteDocumentsEmbeddingsDettaglio}.\\
\hline
RF.O.28.3 & DeleteDocumentsEmbeddings: vedi \vedi{DeleteDocumentsEmbeddingsDettaglio}.\\
\end{xltabular}






\subsubsection{EmbedDocuments}
\subsubsubsection{Descrizione}
Questa componente ha il compito di generare e memorizzare gli embeddings dei documenti indicati dall'utente.
È costituita da:
\begin{itemize}
    \item \textbf{Route API}: /embedDocuments;
    \item \textbf{Metodo}: POST;
    \item \textbf{Lista parametri HTTP}: 
    \begin{itemize}
        \item \code{documentIds}: una lista di stringhe che rappresentano gli id dei documenti di cui generare gli embeddings.
    \end{itemize}
    \item \textbf{Implementazione generale}: La componente viene implementata dal blueprint \code{embedDocuments} che esegue i seguenti controlli:
    \begin{enumerate}
        \item Il parametro \code{documentIds} non deve essere nullo nè vuoto.
    \end{enumerate}
\end{itemize}
\subsubsubsection{Esiti possibili}
\renewcommand{\arraystretch}{1.5}
\begin{xltabular}{\textwidth}{c|X|X}
\caption{Esiti possibili EmbedDocuments}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endfirsthead
\caption[]{Esiti possibili EmbedDocuments (cont)}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endhead
\multicolumn{3}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
200 & Generazione embeddings avvenuta con successo. & - \\
\hline
400 & Il parametro \code{documentIds} è nullo. & Parametri insufficienti. \\
\hline
400 & La lunghezza del parametro \code{documentIds} è 0. & Nessun id di documento specificato.\\
\hline
400 & Un id di \code{documentIds} è vuoto. & Id di documento '{id}' non valido. \\
\hline
500 & Generazione embeddings fallita. & Errore nella generazione degli embeddings.
\end{xltabular}




\subsubsubsection{Lista sottocomponenti}
\begin{itemize}
    \item \label{AWSDocument}\textbf{AWSDocument}: classe che rappresenta i documenti gestibili da AWSS3Manager;
    \item \textbf{AWSS3Manager}: vedi \vedi{AWSS3Manager};
    \item \label{Chunkerizer}\textbf{Chunkerizer}: classe che crea \textit{chunks\pg} a partire da testo;
    \item \label{Document}\textbf{Document}: classe di business che rappresenta i documenti completi;
    \item \label{DocumentContent}\textbf{DocumentContent}: classe di business che rappresenta il contenuto di un documento;
    \item \textbf{DocumentId}: vedi \vedi{DocumentId};    
    \item \textbf{DocumentMetadata}: vedi \vedi{DocumentMetadata};
    \item \textbf{DocumentOperationResponse}: vedi \vedi{DocumentOperationResponse};
    \item \label{DocumentStatus} \textbf{DocumentStatus}: classe di business che rappresenta lo status di un documento;
    %\item \label{DocumentToText}\textbf{DocumentToText}: classe che si occupa di convertire documenti;
    \item \label{DOCXTextExtractor}\textbf{DOCXTextExtractor}: classe che implementa l'interfaccia TextExtractor, offrendo un metodo per l'estrazione di testo da documenti docx;
    \item \label{DocumentType}\textbf{DocumentType}: enumeration che rappresenta i valori che può assumere il tipo di un documento;
    \item  \label{EmbeddingsCreator}\textbf{EmbeddingsCreator}: classe che dialoga con il modello di embeddings per creare gli embeddings a partire dai chunk forniti in input;
    \item \label{EmbeddingsUploader}\textbf{EmbeddingsUploader}: classe che si occupa di effettuare la chiamata dell'upload degli embeddings nella porta esterna diretta verso il vector store;
    \item \label{EmbeddingsUploaderFacadeLangchain}\textbf{EmbeddingsUploaderFacadeLangchain}: classe adapter che implementa la porta EmbeddingsUploaderPort, adattando la chiamata di EmbeddingsUploader alla sequenza di operazioni necessarie per il calcolo degli embeddings e il loro upload nel vector store;
    \item \label{EmbeddingsUploaderPort}\textbf{EmbeddingsUploaderPort}: interfaccia che rappresenta la porta in uscita per effettuare l'upload degli embeddings verso i vector store;
    \item \label{EmbeddingsUploaderVectorStore}\textbf{EmbeddingsUploaderVectorStore}: classe che offre un metodo per eseguire l'upload degli embeddings nel vector store;
    \item \label{EmbedDocumentsController}\textbf{EmbedDocumentsController}: classe controller che si occupa del passaggio di una lista di DocumentId allo use case EmbedDocumentsUseCase a partire da una lista di stringhe che rappresentano l'id dei documenti di cui generare gli embeddings;
    \item \label{EmbedDocumentsService}\textbf{EmbedDocumentsService}: classe service che implementa lo use case EmbedDocumentsUseCase;
    \item \label{EmbedDocumentsUseCase}\textbf{EmbedDocumentsUseCase}: interfaccia use case che rappresenta la porta della business logic in entrata per generare gli embeddings dei documenti;    
    \item \label{GetDocumentsContent}\textbf{GetDocumentsContent}: classe che si occupa di inoltrare la richiesta di recuperare i documenti nella porta esterna diretta verso il sistema di archiviazione;
    
    \item \label{GetDocumentsContentAWSS3}\textbf{GetDocumentsContentAWSS3}: classe adapter che implementa la porta GetDocumentsContentPort, adattando la chiamata di GetDocumentsContent a AWSS3Manager;
    \item \label{GetDocumentsContentPort}\textbf{GetDocumentsContentPort}: interfaccia che rappresenta la porta in uscita per recuperare il contenuto dei documenti dal sistema di archiviazione;
    \item \label{GetDocumentsStatus}\textbf{GetDocumentsStatus}: classe che si occupa di inoltrare la richiesta di recuperare gli status di una lista di documenti nella porta esterna GetDocumentsStatusPort diretta verso il vector store;
    \item  \label{GetDocumentsStatusPort}\textbf{GetDocumentsStatusPort}: interfaccia che rappresenta la porta in uscita per recuperare gli status di una lista di documenti dal vector store;
    
    \item \label{GetDocumentsStatusVectorStore}\textbf{GetDocumentsStatusVectorStore}: classe adapter che implementa la porta GetDocumentsStatusPort, adattando la chiamata di GetDocumentsStatus a VectorStoreManager;
    \item \label{HuggingFaceEmbeddingModel}\textbf{HuggingFaceEmbeddingModel}: classe che implementa LangchainEmbeddingModel offrendo la possibilità di creare embeddings attraverso un embedding model di HuggingFace;
    \item \label{LangchainDocument}\textbf{LangchainDocument}: classe che rappresenta un documento e i suoi embeddings;    
    \item \label{LangchainEmbeddingModel}\textbf{LangchainEmbeddingModel}: classe astratta che permette di interagire con un oggetto langhchain.Embeddings;
    \item \label{OpenAIEmbeddingModel}\textbf{OpenAIEmbeddingModel}: classe che implementa la classe astratta LangchainEmbeddingModel per interagire con un modello di generazione di embeddings di OpenAI;
    \item \label{PDFTextExtractor}\textbf{PDFTextExtractor}: classe che implementa l'interfaccia TextExtractor, offrendo un metodo per l'estrazione di testo da documenti \textit{PDF\pg};
    \item \label{PlainDocument}\textbf{PlainDocument}: classe di business che rappresenta i documenti, compresi i metadati e il contenuto;
    \item \label{Status}\textbf{Status}: enumeration che rappresenta i valori che può assumere lo status di un documento;
    \item \label{TextExtractor}\textbf{TextExtractor}: interfaccia che espone il metodo astratto di estrazione di testo da un documento;   
    \item \textbf{VectorStoreChromaDBManager}: vedi \vedi{VectorStoreChromaDBManager};
    \item \textbf{VectorStoreDocumentOperationResponse}: vedi \vedi{VectorStoreDocumentOperationResponse};
    \item \label{VectorStoreDocumentStatusResponse}\textbf{VectorStoreDocumentStatusResponse}: classe che rappresenta la risposta generata da un vector store, contenente lo status del documento richiesto;
    \item \textbf{VectorStoreManager}: vedi \vedi{VectorStoreManager};
    \item \textbf{VectorStorePineconeManager}: vedi \vedi{VectorStorePineconeManager}.
\end{itemize}

\subsubsubsection{Tracciamento dei requisiti}
\begin{xltabular}{\textwidth}{c|c}
\caption{Tracciamento dei requisiti nella componente EmbedDocuments}\\
\textbf{Requisito} & \textbf{Soddisfacimento del requisito} \\
\endfirsthead
\caption[]{Tracciamento dei requisiti nella componente EmbedDocuments (cont)}\\
\textbf{Requisito} & \textbf{Soddisfacimento del requisito} \\
\endhead
\multicolumn{2}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
RF.O.58 & EmbedDocumentsService: vedi \vedi{EmbedDocumentsServiceDettaglio}.\\
\end{xltabular}




\subsubsection{EnableDocuments}
\subsubsubsection{Descrizione}
Questa componente ha il compito di riabilitare gli embeddings dei documenti indicati dall'utente.
È costituita da:
\begin{itemize}
    \item \textbf{Route API}: /enableDocuments;
    \item \textbf{Metodo}: POST;
    \item \textbf{Lista parametri HTTP}: 
    \begin{itemize}
        \item \code{documentIds}: una lista di stringhe che rappresentano gli id dei documenti da riabilitare.
    \end{itemize}
    \item \textbf{Implementazione generale}: La componente viene implementata dal blueprint \code{enableDocuments} che esegue i seguenti controlli:
    \begin{enumerate}
        \item Il parametro \code{documentIds} non deve essere nullo nè vuoto.
    \end{enumerate}
\end{itemize}
\subsubsubsection{Esiti possibili}
\renewcommand{\arraystretch}{1.5}
\begin{xltabular}{\textwidth}{c|X|X}
\caption{Esiti possibili EnableDocuments}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endfirsthead
\caption[]{Esiti possibili EnableDocuments (cont)}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endhead
\multicolumn{3}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
200 & Riabilitazione avvenuta con successo. & - \\
\hline
400 & Il parametro \code{documentIds} è nullo. & Parametri insufficienti. \\
\hline
400 & La lunghezza del parametro \code{documentIds} è 0. & Nessun id di documento specificato.\\
\hline
400 & Un id di \code{documentIds} è vuoto. & Id di documento '{id}' non valido. \\
\hline
500 & Riabilitazione fallita. & Errore nella riabilitazione dei documenti.
\end{xltabular}

    




\subsubsubsection{Lista sottocomponenti}
\begin{itemize}
    \item \textbf{DocumentId}: vedi \vedi{DocumentId};
    \item \textbf{DocumentOperationResponse}: vedi \vedi{DocumentOperationResponse};
    \item \label{EnableDocumentsController}\textbf{EnableDocumentsController}: classe controller che si occupa del passaggio di una lista di DocumentId allo use case EnableDocumentsUseCase a partire da una lista di stringhe che rappresentano l'id dei documenti da riabilitare;
    \item \label{EnableDocumentsPort}\textbf{EnableDocumentsPort}: interfaccia che rappresenta la porta in uscita per effettuare la riabilitazione dei documenti nel vector store;
    \item \label{EnableDocumentsService}\textbf{EnableDocumentsService}: classe service che implementa lo use case EnableDocumentsUseCase;
    \item \label{EnableDocumentsUseCase}\textbf{EnableDocumentsUseCase}: interfaccia use case che rappresenta la porta della business logic in entrata per effettuare la riabilitazione dei documenti;
    \item \label{EnableDocumentsVectorStore}\textbf{EnableDocumentsVectorStore}: classe adapter che implementa la porta EnableDocumentsPort, adattando la chiamata di EnableDocumentsService a VectorStoreManager;
    \item \textbf{VectorStoreChromaDBManager}: vedi \vedi{VectorStoreChromaDBManager};
    \item \textbf{VectorStoreDocumentOperationResponse}: vedi \vedi{VectorStoreDocumentOperationResponse};
    \item \textbf{VectorStoreManager}: vedi \vedi{VectorStoreManager};
    \item \textbf{VectorStorePineconeManager}: vedi \vedi{VectorStorePineconeManager}.
    
\end{itemize}

\subsubsubsection{Tracciamento dei requisiti}
\begin{xltabular}{\textwidth}{c|c}
\caption{Tracciamento dei requisiti nella componente EnableDocuments}\\
\textbf{Requisito} & \textbf{Soddisfacimento del requisito} \\
\endfirsthead
\caption[]{Tracciamento dei requisiti nella componente EnableDocuments (cont)}\\
\textbf{Requisito} & \textbf{Soddisfacimento del requisito} \\
\endhead
\multicolumn{2}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
RF.O.31 & EnableDocumentsService: vedi \vedi{EnableDocumentsServiceDettaglio}.\\
\hline
RF.O.32 & EnableDocumentsService: vedi \vedi{EnableDocumentsServiceDettaglio}.\\
\end{xltabular}


\subsubsection{GetChatMessages}
\subsubsubsection{Descrizione}
Questa componente ha il compito di ottenere una chat completa, ovvero che comprende sia le sue informazioni che i suoi messaggi.
È costituita da:
\begin{itemize}
    \item \textbf{Route API}: /getChatMessages;
    \item \textbf{Metodo}: GET;
    \item \textbf{Lista parametri HTTP}: 
    \begin{itemize}
        \item \code{chatId}: id della chat da recuperare.
    \end{itemize}
    \item \textbf{Implementazione generale}: La componente viene implementata dal blueprint \code{getChatMessages} che esegue i seguenti controlli:
    \begin{enumerate}
        \item Il parametro \code{chatId} non deve essere nullo nè minore di 0.
    \end{enumerate}
\end{itemize}
\subsubsubsection{Esiti possibili}
\begin{xltabular}{\textwidth}{c|X|X}
\caption{Esiti possibili GetChatMessages}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endfirsthead
\caption[]{Esiti possibili GetChatMessages (cont)}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endhead
\multicolumn{3}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
200 & Chat recuperata con succcesso. & - \\
\hline
400 & Il parametro \code{chatId} è nullo. & Parametri insufficienti.\\
\hline
400 & Il parametro \code{chatId} è minore di 0. & Chat id '{chatId}' non valido.\\
\hline
500 & Recupero della Chat fallito. & Errore nel recupero dei messaggi. \\
\end{xltabular}






\subsubsubsection{Lista sottocomponenti}
\begin{itemize}
    \item \label{Chat}\textbf{Chat}: classe di business che rappresenta una chat completa;
    \item \textbf{ChatId}: vedi \vedi{ChatId};
    %\item \label{ChatInfo}\textbf{ChatInfo}: classe di business che rappresenta le informazioni di una chat;
    \item \label{GetChatMessagesController}\textbf{GetChatMessagesController}: classe controller che si occupa del richiedere una chat allo use case GetChatMessagesUseCase;
    \item \label{GetChatMessagesPort}\textbf{GetChatMessagesPort}: interfaccia che rappresenta la porta in uscita per effettuare la richiesta di una chat verso il database per la storicizzazione delle chat;
    \item \label{GetChatMessagesPostgres}\textbf{GetChatMessagesPostgres}: classe che implementa la porta GetChatMessagesPort, adattando la chiamata di GetChatMessagesService a PostgresChatORM;
    \item \label{GetChatMessagesService}\textbf{GetChatMessagesService}: classe service che implementa lo use case GetChatMessagesUseCase;
    \item \label{GetChatMessagesUseCase}\textbf{GetChatMessagesUseCase}: interfaccia use case che rappresenta la porta della business logic in entrata per richiedere una chat;
    \item \textbf{Message}: vedi \vedi{Message};
    \item \textbf{MessageSender}: vedi \vedi{MessageSender};
    \item \textbf{PostgresChat}: vedi \vedi{PostgresChat};
    \item \textbf{PostgresChatORM}: vedi \vedi{PostgresChatORM};
    \item \textbf{PostgresMessage}: vedi \vedi{PostgresMessage};
    \item \textbf{PostgresMessageSenderType}: vedi \vedi{PostgresMessageSenderType}.
\end{itemize}


\subsubsubsection{Tracciamento dei requisiti}
\begin{xltabular}{\textwidth}{c|c}
\caption{Tracciamento dei requisiti nella componente GetChatMessages}\\
\textbf{Requisito} & \textbf{Soddisfacimento del requisito} \\
\endfirsthead
\caption[]{Tracciamento dei requisiti nella componente GetChatMessages (cont)}\\
\textbf{Requisito} & \textbf{Soddisfacimento del requisito} \\
\endhead
\multicolumn{2}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
RF.O.42 & GetChatMessagesService: vedi \vedi{GetChatMessagesServiceDettaglio}.\\
\end{xltabular}    
    

    

\subsubsection{GetChats}
\subsubsubsection{Descrizione}
Questa componente ha il compito di ottenere una lista di preview di chat, eventualmente filtrando la ricerca.
È costituita da:
\begin{itemize}
    \item \textbf{Route API}: /getChats;
    \item \textbf{Metodo}: GET;
    \item \textbf{Lista parametri HTTP}: 
    \begin{itemize}
        \item \code{filter}: filtro da applicare per la ricerca tra le chat.
    \end{itemize}
    \item \textbf{Implementazione generale}: La componente viene implementata dal blueprint \code{getChats} che esegue i seguenti controlli:
    \begin{enumerate}
        \item Il parametro \code{filter} non deve essere nullo.
    \end{enumerate}
\end{itemize}
\subsubsubsection{Esiti possibili}
\begin{xltabular}{\textwidth}{c|X|X}
\caption{Esiti possibili GetChats}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endfirsthead
\caption[]{Esiti possibili GetChats (cont)}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endhead
\multicolumn{3}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
200 & Ricerca avvenuta con successo. & - \\
\hline
400 & Il parametro \code{filter} è nullo. & Parametri insufficienti \\
\hline
404 & Non sono state trovate chat & - \\
\end{xltabular}

    




\subsubsubsection{Lista sottocomponenti}
\begin{itemize}
    \item \label{ChatFilter}\textbf{ChatFilter}: classe di business che rappresenta il filtro utilizzato nella ricerca;
    \item \textbf{ChatId}: vedi \vedi{ChatId};
    %\item \textbf{ChatInfo}: vedi \vedi{ChatInfo};
    \item \label{ChatPreview}\textbf{ChatPreview}: classe di business che rappresenta la preview di una chat;
    \item \label{GetChatsController}\textbf{GetChatsController}: classe controller che si occupa del richiedere le preview delle chat allo use case GetChatsUseCase, con eventuale passaggio di un filtro per eseguire una ricerca;
    \item \label{GetChatsPort}\textbf{GetChatsPort}: interfaccia che rappresenta la porta in uscita per effettuare la richiesta delle chat eventualmente filtrate verso il database per la storicizzazione delle chat;
    \item \label{GetChatsPostgres}\textbf{GetChatsPostgres}: classe che implementa la porta GetChatsPort, adattando la chiamata di GetChatsService a PostgresChatORM;
    \item \label{GetChatsService}\textbf{GetChatsService}: classe service che implementa lo use case GetChatsUseCase;
    \item \label{GetChatsUseCase}\textbf{GetChatsUseCase}: interfaccia use case che rappresenta la porta della business logic in entrata per richiedere le chat, eventualmente filtrate;
    \item \textbf{Message}: vedi \vedi{Message};
    \item \textbf{MessageSender}: vedi \vedi{MessageSender};
    \item \textbf{PostgresChatORM}: vedi \vedi{PostgresChatORM};
    \item \label{PostgresChatPreview}\textbf{PostgresChatPreview}: classe di persistence che rappresenta la preview di una chat;
    \item \textbf{PostgresMessage}: vedi \vedi{PostgresMessage};
    \item \textbf{PostgresMessageSenderType}: vedi \vedi{PostgresMessageSenderType}.
\end{itemize}


\subsubsubsection{Tracciamento dei requisiti} -



\subsubsection{GetConfiguration}
    \subsubsubsection{Descrizione}
    Questa componente ha il compito di ricavare la configurazione del sistema.
    È costituita da:
    \begin{itemize}
        \item \textbf{Route API}: /getConfiguration;
        \item \textbf{Metodo}: GET;
        \item \textbf{Lista parametri HTTP}: -
        \item \textbf{Implementazione generale}: La componente viene implementata dal blueprint \code{getConfiguration} che esegue i seguenti controlli:
        \begin{enumerate}
            \item L'oggetto configurazione non deve essere nullo;
            \item Nessun campo dell'oggetto configurazione deve essere nullo.
        \end{enumerate}
    \end{itemize}
    \subsubsubsection{Esiti possibili}
    \begin{xltabular}{\textwidth}{c|X|X}
    \caption{Esiti possibili GetConfiguration}\\
    \textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
    \endfirsthead
    \caption[]{Esiti possibili GetConfiguration (cont)}\\
    \textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
    \endhead
    \multicolumn{3}{r}{{Continua nella pagina successiva}} \\
    \endfoot
    \endlastfoot
    \hline
    200 & Configurazione ricavata con successo. & - \\
    \hline
    404 & Almeno un campo della configurazione è nullo. & Configurazione inesistente. \\
    \hline
    400 & Recupero configurazione fallito. & Errore nel recupero della configurazione. \\
    \end{xltabular}
    


\subsubsubsection{Lista sottocomponenti}
\begin{itemize}

    \item \label{Configuration}\textbf{Configuration}: classe che contiene la configurazione e le informazioni riguardo a vector store, document store, LLM ed embedding model;
    \item \label{DocumentStoreConfiguration}\textbf{DocumentStoreConfiguration}: classe che rappresenta la configurazione di un document store;
    \item \label{DocumentStoreType}\textbf{DocumentStoreType}:  enumeration che rappresenta i valori che può assumere il campo \code{name} in DocumentStoreConfiguration;
    \item \label{EmbeddingModelConfiguration}\textbf{EmbeddingModelConfiguration}: classe che rappresenta la configurazione di un modello di embedding;
    \item \label{EmbeddingModelType}\textbf{EmbeddingModelType}: enumeration che rappresenta i valori che può assumere il campo \code{name} in EmbeddingModelConfiguration;
    \item \label{GetConfigurationController}\textbf{GetConfigurationController}: classe che si occupa di ritornare la configurazione di vector store, document store, embedding model e LLM;
    \item \label{GetConfigurationPort}\textbf{GetConfigurationPort}: interfaccia che rappresenta la porta in uscita per ottenere la configurazione del sistema;
    \item \label{GetConfigurationPostgres}\textbf{GetConfigurationPostgres}: classe che implementa la porta GetConfigurationPort, adattando la chiamata di GetConfigurationService a PostgresConfigurationORM;
    \item \label{GetConfigurationService}\textbf{GetConfigurationService}: classe service che implementa lo use case GetConfigurationUseCase;
    \item \label{GetConfigurationUseCase}\textbf{GetConfigurationUseCase}: interfaccia use case che rappresenta la porta della business logic in entrata per effettuare il recupero della configurazione; 
    
    \item \label{LLMModelConfiguration}\textbf{LLMModelConfiguration}: classe che rappresenta la configurazione di un modello LLM;
    \item \label{LLMModelType}\textbf{LLMModelType}: enumeration che rappresenta il tipo di valori del campo \code{name} di LLMModelConfiguration;
    \item \textbf{PostgresConfiguration}: vedi \vedi{PostgresConfiguration};
    \item \textbf{PostgresConfigurationORM}: vedi \vedi{PostgresConfigurationORM};
    \item \textbf{PostgresDocumentStoreConfiguration}: vedi \vedi{PostgresDocumentStoreConfiguration};
    \item \textbf{PostgresDocumentStoreType}: vedi \vedi{PostgresDocumentStoreType};

    \item \textbf{PostgresEmbeddingModelConfiguration}: vedi \vedi{PostgresEmbeddingModelConfiguration};
    \item \textbf{PostgresEmbeddingModelType}: vedi \vedi{PostgresEmbeddingModelType};
    
    \item \textbf{PostgresLLMModelConfiguration}: vedi \vedi{PostgresLLMModelConfiguration};
    \item \textbf{PostgresLLMModelType}:vedi \vedi{PostgresLLMModelType};

    \item \textbf{PostgresVectorStoreConfiguration}: vedi \vedi{PostgresVectorStoreConfiguration};
    \item \textbf{PostgresVectorStoreType}: vedi \vedi{PostgresVectorStoreType};

    \item \label{VectorStoreConfiguration}\textbf{VectorStoreConfiguration}: classe che rappresenta la configurazione di un vector store;
    \item \label{VectorStoreType}\textbf{VectorStoreType}: enumeration che rappresenta i valori che può assumere il campo \code{name} in VectorStoreConfiguration.
    
\end{itemize}
 



\subsubsubsection{Tracciamento dei requisiti}
\begin{xltabular}{\textwidth}{c|c}
\caption{Tracciamento dei requisiti nella componente GetConfiguration}\\
\textbf{Requisito} & \textbf{Soddisfacimento del requisito} \\
\endfirsthead
\caption[]{Tracciamento dei requisiti nella componente GetConfiguration (cont)}\\
\textbf{Requisito} & \textbf{Soddisfacimento del requisito} \\
\endhead
\multicolumn{2}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
RF.O.14 & GetConfigurationService: vedi \vedi{GetConfigurationServiceDettaglio}.\\
\hline
RF.O.14.1 & GetConfigurationService: vedi \vedi{GetConfigurationServiceDettaglio}.\\
\hline
RF.O.14.2 & GetConfigurationService: vedi \vedi{GetConfigurationServiceDettaglio}.\\
\hline
RF.O.14.3 & GetConfigurationService: vedi \vedi{GetConfigurationServiceDettaglio}.\\
\hline
RF.O.14.4 &  GetConfigurationService: vedi \vedi{GetConfigurationServiceDettaglio}.\\
\hline
RF.O.54. &  LLMModelType: vedi \vedi{LLMModelTypeDettaglio}.  \\
\end{xltabular}



    
%GetConfigurationOptions

\subsubsection{GetConfigurationOptions}
    \subsubsubsection{Descrizione}
    Questa componente ha il compito di ottenere le possibili opzioni delle configurazioni di modello di embedding, LLM, vector store e document store.
    È costituita da:
    \begin{itemize}
        \item \textbf{Route API}: /getConfigurationOptions;
        \item \textbf{Metodo}: GET;
        \item \textbf{Lista parametri HTTP}: -
        \item \textbf{Implementazione generale}: La componente viene implementata dal blueprint \code{getConfigurationOptions} che esegue i seguenti controlli:
        \begin{enumerate}
            \item L'oggetto opzioni di configurazione non deve essere nullo.
        \end{enumerate}
    \end{itemize}
    \subsubsubsection{Esiti possibili}
    \begin{xltabular}{\textwidth}{c|X|X}
    \caption{Esiti possibili GetConfigurationOptions}\\
    \textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
    \endfirsthead
    \caption[]{Esiti possibili GetConfigurationOptions (cont)}\\
    \textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
    \endhead
    \multicolumn{3}{r}{{Continua nella pagina successiva}} \\
    \endfoot
    \endlastfoot
    \hline
    200 & Opzioni di configurazione ricavate con successo. & - \\
    \hline
    404 & Opzioni di configurazione non esistenti. & - \\%da controllare la frase
    \end{xltabular}
    

       
\subsubsubsection{Lista sottocomponenti}
\begin{itemize}
    \item \label{ConfigurationOptions}\textbf{ConfigurationOptions}: classe che contiene liste delle possibili configurazioni per vector store, document store, embedding model e LLM;
    \item \textbf{DocumentStoreConfiguration}: vedi \vedi{DocumentStoreConfiguration};
    \item \textbf{DocumentStoreType}: vedi \vedi{DocumentStoreType};
    \item \textbf{EmbeddingModelConfiguration}: vedi \vedi{EmbeddingModelConfiguration};
    \item \textbf{EmbeddingModelType}: vedi \vedi{EmbeddingModelType};
    \item \label{GetConfigurationOptions}\textbf{GetConfigurationOptions}: classe che si occupa di ottenere le possibili configurazioni di vector store, document store, embedding model e LLM; 
    
     \item \label{GetConfigurationOptionsPort}\textbf{GetConfigurationOptionsPort}: interfaccia che rappresenta la porta in uscita per ottenere le possibili configurazione di vector store, document store, embedding model e LLM;
    \item \label{GetConfigurationOptionsPostgres}\textbf{GetConfigurationOptionsPostgres}: classe che implementa la porta GetConfigurationOptionsPort, adattando la chiamata di GetConfigurationOptionsService a PostgresConfigurationORM;
    \item \label{GetConfigurationOptionsService}\textbf{GetConfigurationOptionsService}: classe service che implementa lo use case GetConfigurationOptionsUseCase;
    \item \label{GetConfigurationOptionsUseCase}\textbf{GetConfigurationOptionsUseCase}: interfaccia use case che rappresenta la porta della business logic in entrata per effettuare il recupero dellopzioni di configurazione per vector store, document store, embedding model e LLM; 
    \item \textbf{LLMModelConfiguration}: vedi \vedi{LLMModelConfiguration};
    \item \textbf{LLMModelType}: vedi \vedi{LLMModelType};
   % \item \textbf{PostgresConfiguration}: vedi \vedi{PostgresConfiguration};
    \item \textbf{PostgresConfigurationORM}: vedi \vedi{PostgresConfigurationORM};
    \item \textbf{PostgresDocumentStoreConfiguration}: vedi \vedi{PostgresDocumentStoreConfiguration};
    \item \textbf{PostgresDocumentStoreType}: vedi \vedi{PostgresDocumentStoreType};

    \item \textbf{PostgresEmbeddingModelConfiguration}: vedi \vedi{PostgresEmbeddingModelConfiguration};
    \item \textbf{PostgresEmbeddingModelType}: vedi \vedi{PostgresEmbeddingModelType};
    
    \item \textbf{PostgresLLMModelConfiguration}: vedi \vedi{PostgresLLMModelConfiguration};
    \item \textbf{PostgresLLMModelType}: vedi \vedi{PostgresLLMModelType};

    \item \textbf{PostgresVectorStoreConfiguration}: vedi \vedi{PostgresVectorStoreConfiguration};
    \item \textbf{PostgresVectorStoreType}: vedi \vedi{PostgresVectorStoreType};

    \item \textbf{VectorStoreConfiguration}: vedi \vedi{VectorStoreConfiguration};
    \item \textbf{VectorStoreType}: vedi \vedi{VectorStoreType}.
   
\end{itemize}
 
   
\subsubsubsection{Tracciamento dei requisiti} -



\subsubsection{GetDocumentContent}
\subsubsubsection{Descrizione}
Questa componente ha il compito di recuperare tutte le informazioni di un documento, compreso il suo contenuto.
È costituita da:
\begin{itemize}
    \item \textbf{Route API}: /getDocumentContent;
    \item \textbf{Metodo}: GET;
    \item \textbf{Lista parametri HTTP}: 
    \begin{itemize}
        \item {documentId}: una stringa che rappresenta l'id del documento da recuperare.
    \end{itemize}
    \item \textbf{Implementazione generale}: La componente viene implementata dal blueprint \code{getDocumentContent} che esegue i seguenti controlli:
        \begin{enumerate}
            \item Il parametro {documentId} non deve essere vuoto o nullo.
        \end{enumerate}
\end{itemize}
\subsubsubsection{Esiti possibili}
\renewcommand{\arraystretch}{1.5}
\begin{xltabular}{\textwidth}{c|X|X}
\caption{Esiti possibili GetDocumentContent}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endfirsthead
\caption[]{Esiti possibili GetDocumentContent (cont)}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endhead
\multicolumn{3}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
200 & Documento recuperato con successo. & - \\
\hline
400 & Il parametro {documentId} è nullo. &  Parametri insufficienti.\\
\hline
400 & Il parametro {documentId} è vuoto. &  Id di documento '{documentId}' non valido.\\
\hline
404 & Recupero documento fallito. & Errore nel recupero del documento.
\end{xltabular}


\subsubsubsection{Lista sottocomponenti}
\begin{itemize}
    \item \textbf{AWSDocument}: vedi \vedi{AWSDocument};
    \item \textbf{AWSS3Manager}: vedi \vedi{AWSS3Manager};
    \item \textbf{Document}: vedi \vedi{Document};
    \item \textbf{DocumentContent}: vedi \vedi{DocumentContent};
    \item \textbf{DocumentId}: vedi \vedi{DocumentId};
    \item \textbf{DocumentMetadata}: vedi \vedi{DocumentMetadata};
    \item \textbf{DocumentStatus}: vedi \vedi{DocumentStatus};
    \item \textbf{DocumentType}: vedi \vedi{DocumentType};
    \item \label{GetDocumentContentController}\textbf{GetDocumentContentController}: classe controller che si occupa del passaggio di un DocumentId allo use case GetDocumentsContentUseCase a partire da una stringa che rappresenta l'id del documento da recuperare;
    \item \label{GetDocumentsContentFacadeService}\textbf{GetDocumentsContentFacadeService}: classe service che implementa lo use case GetDocumentsContetUseCase;
    %\item \textbf{GetDocuments}: vedi \vedi{GetDocuments};
    %\item \textbf{GetDocumentsAWSS3}: vedi \vedi{GetDocumentsAWSS3};
    \item \textbf{GetDocumentsContent}: vedi \vedi{GetDocumentsContent};
    \item \textbf{GetDocumentsContentAWSS3}: vedi \vedi{GetDocumentsContentAWSS3};
    \item \textbf{GetDocumentsContentPort}: vedi \vedi{GetDocumentsContentPort};
    %\item \textbf{GetDocumentsPort}: vedi \vedi{GetDocumentsPort};
    \item \textbf{GetDocumentsStatus}: vedi \vedi{GetDocumentsStatus};
    \item \textbf{GetDocumentsStatusPort}: \vedi{GetDocumentsStatusPort};
    \item \textbf{GetDocumentsStatusVectorStore}: vedi \vedi{GetDocumentsStatusVectorStore};
    \item \label{GetDocumentsContentUseCase}\textbf{GetDocumentsContentUseCase}: interfaccia use case che rappresenta la porta della business logic in entrata per recuperare un documento;
    \item \textbf{PlainDocument}: vedi \vedi{PlainDocument};    
    \item \textbf{Status}: vedi \vedi{Status};
    \item \textbf{VectorStoreChromaDBManager}: vedi \vedi{VectorStoreChromaDBManager};
    \item \textbf{VectorStoreDocumentStatusResponse}: vedi \vedi{VectorStoreDocumentStatusResponse};
    \item \textbf{VectorStoreManager}: vedi \vedi{VectorStoreManager};
    \item \textbf{VectorStorePineconeManager}: vedi \vedi{VectorStorePineconeManager}.
\end{itemize}

\subsubsubsection{Tracciamento dei requisiti}
\begin{xltabular}{\textwidth}{c|c}
\caption{Tracciamento dei requisiti nella componente GetDocumentContent}\\
\textbf{Requisito} & \textbf{Soddisfacimento del requisito} \\
\endfirsthead
\caption[]{Tracciamento dei requisiti nella componente GetDocumentContent (cont)}\\
\textbf{Requisito} & \textbf{Soddisfacimento del requisito} \\
\endhead
\multicolumn{2}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
RF.O.24 & GetDocumentsContentFacadeService: vedi \vedi{GetDocumentsContentFacadeServiceDettaglio}.\\
\end{xltabular}


\subsubsection{GetDocuments}
\subsubsubsection{Descrizione}
Questa componente ha il compito di ricavare la lista di tutti i documenti presenti nel sistema e di rispondere a ricerche basate sull'id dei documenti.
È costituita da:
\begin{itemize}
    \item \textbf{Route API}: /getDocuments;
    \item \textbf{Metodo}: GET;
    \item \textbf{Lista parametri HTTP}: 
    \begin{itemize}
        \item \code{filter}: stringa che rappresenta il filtro opzionale da applicare alla ricerca dei documenti.
    \end{itemize}
    \item \textbf{Implementazione generale}: La componente viene implementata dal blueprint \code{getDocuments} che esegue i seguenti controlli:
        \begin{enumerate}
            \item Il parametro \code{filter} non deve essere nullo.
        \end{enumerate}
\end{itemize}
\subsubsubsection{Esiti possibili}
\renewcommand{\arraystretch}{1.5}
\begin{xltabular}{\textwidth}{c|X|X}
\caption{Esiti possibili GetDocuments}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endfirsthead
\caption[]{Esiti possibili GetDocuments (cont)}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endhead
\multicolumn{3}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
200 & Ricerca avvenuta con successo. & - \\
\hline
400 & Il parametro \code{filter} è nullo. & Parametri insufficienti. \\
\hline
404 & Ricerca fallita. & Errore nella ricerca dei documenti.
\end{xltabular}


\subsubsubsection{Lista sottocomponenti}
\begin{itemize}
    \item \label{AWSDocumentMetadata}\textbf{AWSDocumentMetadata}: classe che rappresenta i metadati di un documento ricavato da AWS;
    \item \textbf{AWSS3Manager}: vedi \vedi{AWSS3Manager};
    \item \label{DocumentFilter}\textbf{DocumentFilter}: classe di business che rappresenta il filtro applicabile alla ricerca di documenti;
    \item \textbf{DocumentId}: vedi \vedi{DocumentId};
    \item \label{DocumentMetadata}\textbf{DocumentMetadata}: classe di business che rappresenta i metadati di un documento;
    \item \textbf{DocumentStatus}: vedi \vedi{DocumentStatus};
    \item \textbf{DocumentType}: vedi \vedi{DocumentType};
    \item \label{ElaborationException}\textbf{ElaborationException}: classe che rappresenta il messaggio di eccezione;
     \item \label{GetDocumentsController}\textbf{GetDocumentsController}: classe controller che si occupa del passaggio di un oggetto DocumentFilter allo use case GetDocumentsUseCase a partire da una stringa che rappresenta il filtro della ricerca;
     \item \label{GetDocumentsFacadeService}\textbf{GetDocumentsFacadeService}: classe service che implementa lo use case GetDocumentsUseCase;
     \item \label{GetDocumentsListAWSS3}\textbf{GetDocumentsListAWSS3}: classe adapter che implementa la porta GetDocumentsMetadataPort, adattando la chiamata di GetDocumentsMetadata a \\AWSS3Manager;
     \item \label{GetDocumentsMetadata}\textbf{GetDocumentsMetadata}: classe che si occupa di ricavare i metadati di una lista di documenti nella porta esterna GetDocumentsMetadataPort diretta verso il sistema di archiviazione documenti a partire da un filtro di ricerca;
     \item \label{GetDocumentsMetadataPort}\textbf{GetDocumentsMetadataPort}: interfaccia che rappresenta la porta in uscita per ricavare i metadati di una lista di documenti dal sistema di archiviazione a partire da un filtro di ricerca;
     \item \textbf{GetDocumentsStatus}: vedi \vedi{GetDocumentsStatus};
     \item \textbf{GetDocumentsStatusPort}: vedi \vedi{GetDocumentsStatusPort};
    \item \textbf{GetDocumentsStatusVectorStore}: \vedi{GetDocumentsStatusVectorStore};
     \item \label{GetDocumentsUseCase}\textbf{GetDocumentsUseCase}: interfaccia use case che rappresenta la porta della business logic in entrata per ricercare dei documenti;
     \item \label{LightDocument}\textbf{LightDocument}: classe di business che fornisce una rappresentazione leggera dei documenti, esculdendo il contenuto;
    \item \textbf{Status}: vedi \vedi{Status};    
    \item \textbf{VectorStoreChromaDBManager}: vedi \vedi{VectorStoreChromaDBManager};
    \item \textbf{VectorStoreDocumentStatusResponse}: \vedi{VectorStoreDocumentStatusResponse};
    \item \textbf{VectorStoreManager}: vedi \vedi{VectorStoreManager};
    
    \item \textbf{VectorStorePineconeManager}: vedi \vedi{VectorStorePineconeManager}.
    
\end{itemize}

\subsubsubsection{Tracciamento dei requisiti}
\begin{xltabular}{\textwidth}{c|c}
\caption{Tracciamento dei requisiti nella componente GetDocuments}\\
\textbf{Requisito} & \textbf{Soddisfacimento del requisito} \\
\endfirsthead
\caption[]{Tracciamento dei requisiti nella componente GetDocuments (cont)}\\
\textbf{Requisito} & \textbf{Soddisfacimento del requisito} \\
\endhead
\multicolumn{2}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
RF.O.33 & GetDocumentsFacadeService: vedi \vedi{GetDocumentsFacadeServiceDettaglio}.\\
\end{xltabular}



\subsubsection{RenameChat}
\subsubsubsection{Descrizione}
Questa componente ha il compito di rinominare una chat, aggiornando di conseguenza il database utilizzato per la storicizzazione delle chat.
È costituita da:
\begin{itemize}
    \item \textbf{Route API}: /renameChat;
    \item \textbf{Metodo}: POST;
    \item \textbf{Lista parametri HTTP}: 
    \begin{itemize}
        \item \code{chatId}: l'Id utilizzato per identificare univocamente una chat;
        \item \code{title}: nuovo titolo da assegnare alla chat.
    \end{itemize}
    \item \textbf{Implementazione generale}: La componente viene implementata dal blueprint \code{renameChat} che esegue i seguenti controlli:
        \begin{enumerate}
            \item Il parametro \code{chatId} non deve essere nullo;
            \item Il parametro \code{chatId} non deve essere vuoto, diverso da un numero o un numero negativo;
            \item Il parametro \code{title} non può essere vuoto.
        \end{enumerate}
\end{itemize}
\subsubsubsection{Esiti possibili}
\begin{xltabular}{\textwidth}{c|X|X}
\caption{Esiti possibili RenameChat}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endfirsthead
\caption[]{Esiti possibili RenameChat (cont)}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endhead
\multicolumn{3}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
200 & Rinomina avventua con successo. & -\\
\hline
400 & Il parametro \code{chatId} o il parametro \code{title} sono nulli. & Parametri insufficienti. \\
\hline
400 & Il parametro \code{chatId} non è valido. & Chat id '{chatId}' non valido. \\
\hline
400 & Il parametro \code{title} è vuoto. & Il titolo della chat non può essere vuoto.\\
\hline
500 & Rinomina fallita. & Errore nella rinomina della chat.\\ 

\end{xltabular}


\subsubsubsection{Lista sottocomponenti}
\begin{itemize}
    \item \textbf{ChatId}: vedi \vedi{ChatId};
    \item \textbf{ChatOperationResponse}: vedi \vedi{ChatOperationResponse};
    \item \label{RenameChatController}\textbf{RenameChatController}: classe controller che si occupa di effettuare la rinomina di una chat;%del passaggio allo use case CreateChatUseCase di un intero rappresentante l'id di una chat e un titolo per eseguire la sua rinomina;
    \item \label{RenameChatPort}\textbf{RenameChatPort}: interfaccia che rappresenta la porta in uscita per effettuare la rinomina di una chat verso il database per la storicizzazione delle chat;
    \item \label{RenameChatPostgres}\textbf{RenameChatPostgres}: classe che implementa la porta RenameChatPort, adattando la chiamata di RenameChatService a PostgresChatORM;
    \item \label{RenameChatService}\textbf{RenameChatService}: classe service che implementa lo use case RenameChatUseCase;
    \item \label{RenameChatUseCase}\textbf{RenameChatUseCase}: interfaccia use case che rappresenta la porta della business logic in entrata per effettuare la rinomina di una chat;
    \item \textbf{PostgresChatOperationResponse}: vedi \vedi{PostgresChatOperationResponse};
    \item \textbf{PostgresChatORM}: vedi \vedi{PostgresChatORM}. 
\end{itemize}

\subsubsubsection{Tracciamento dei requisiti}
\begin{xltabular}{\textwidth}{c|c}
\caption{Tracciamento dei requisiti nella componente RenameChat}\\
\textbf{Requisito} & \textbf{Soddisfacimento del requisito} \\
\endfirsthead
\caption[]{Tracciamento dei requisiti nella componente RenameChat (cont)}\\
\textbf{Requisito} & \textbf{Soddisfacimento del requisito} \\
\endhead
\multicolumn{2}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
RF.O.39 & RenameChatService: vedi \vedi{RenameChatServiceDettaglio}.\\
\hline
RF.O.40 &  RenameChatService: vedi \vedi{RenameChatServiceDettaglio}. \\
\hline
RF.O.41 &  RenameChatService: vedi \vedi{RenameChatServiceDettaglio}. \\
\end{xltabular}


%SETCONFIGURATION
\subsubsection{SetConfiguration}
\subsubsubsection{Descrizione}
Questa componente ha il compito di impostare le configurazioni di vector store, documents store, modelli LLM e di embedding al primo avvio del sistema.
È costituita da:
\begin{itemize}
    \item \textbf{Route API}: /setConfiguration;
    \item \textbf{Metodo}: POST;
    \item \textbf{Lista parametri HTTP}: 
    \begin{itemize}
        \item \code{embeddingModel}: modello di embedding scelto;
        \item \code{documentStore}: metodo di storicizzazione dei documenti scelto;
        \item \code{LLMModel}: modello LLM scelto;
        \item \code{vectorStore}: vector store scelto.
    \end{itemize}
    \item \textbf{Implementazione generale}: La componente viene implementata dal blueprint \code{setConfiguration} che esegue i seguenti controlli:
        \begin{enumerate}
            \item Il parametro \code{embeddingModel} non deve essere vuoto o nullo;
            \item Il parametro \code{documentStore} non deve essere vuoto o nullo;
            \item Il parametro \code{LLMModel} non deve essere vuoto o nullo;
            \item Il parametro \code{vectorStore} non deve essere vuoto o nullo.
        \end{enumerate}
\end{itemize}
\subsubsubsection{Esiti possibili}
\begin{xltabular}{\textwidth}{c|X|X}
\caption{Esiti possibili SetConfiguration}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endfirsthead
\caption[]{Esiti possibili SetConfiguration (cont)}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endhead
\multicolumn{3}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
200 & Configurazione impostata con successo. & -\\
\hline
400 & Uno o più dei parametri (\code{embeddingModel, documentStore,}\code{ LLMModel, vectorStore}) è nullo. & Parametri insufficienti. \\
\hline
400 & Il parametro \code{LLMModel} è vuoto. & Modello LLM '{LLMModel}' non valido. \\
\hline
400 & Il parametro \code{embeddingModel} è vuoto. & Modello di embedding '{embeddingModel}' non valido.\\
\hline
400 & Il parametro \code{documentStore} è vuoto. & Document Store '{documentStore}' non valido. \\
\hline
400 & Il parametro \code{vectorStore} è vuoto. & Vector Store '{vectorStore}' non valido.\\
\hline
500 & Configurazione fallita. & Errore nella inizializzazione della configurazione.\\ 

\end{xltabular}

\subsubsubsection{Lista sottocomponenti}
\begin{itemize}
    \item \textbf{ConfigurationOperationResponse}: vedi \vedi{ConfigurationOperationResponse};
    \item \textbf{PostgresConfigurationOperationResponse}: vedi \vedi{PostgresConfigurationOperationResponse};
    \item \textbf{PostgresConfigurationORM}: vedi \vedi{PostgresConfigurationORM};
    
    \item \label{SetConfigurationController}\textbf{SetConfigurationController}: classe controller che si occupa del passaggio allo use case SetConfigurationUseCase di stringhe che rappresentano rispettivamente LLModel, document store, vector store ed embedding model, per inizializzare la configurazione del sistema;
    \item \label{SetConfigurationPort}\textbf{SetConfigurationPort}: interfaccia che rappresenta la porta in uscita per effettuare la inizializzazione della configurazione di sistema;
    \item \label{SetConfigurationPostgres}\textbf{SetConfigurationPostgres}:  classe che implementa la porta SetConfigurationPort, adattando la chiamata di SetConfigurationService a PostgresConfigurationORM;

    \item \label{SetConfigurationService}\textbf{SetConfigurationService}:classe service che implementa lo use case SetConfigurationUseCase;
    \item \label{SetConfigurationUseCase}\textbf{SetConfigurationUseCase}: interfaccia use case che rappresenta la porta della business logic in entrata per effettuare la inizializzazione della configurazione di sistema.


\end{itemize}

\subsubsubsection{Tracciamento dei requisiti}
\begin{xltabular}{\textwidth}{c|c}
\caption{Tracciamento dei requisiti nella componente SetConfiguration}\\
\textbf{Requisito} & \textbf{Soddisfacimento del requisito} \\
\endfirsthead
\caption[]{Tracciamento dei requisiti nella componente SetConfiguration (cont)}\\
\textbf{Requisito} & \textbf{Soddisfacimento del requisito} \\
\endhead
\multicolumn{2}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
RF.O.1 & SetConfigurationService: vedi \vedi{SetConfigurationServiceDettaglio}.\\
\hline
RF.O.1.1 & SetConfigurationService: vedi \vedi{SetConfigurationServiceDettaglio}.\\
\hline
RF.O.1.2 & SetConfigurationService: vedi \vedi{SetConfigurationServiceDettaglio}.\\
\hline
RF.O.1.3 & SetConfigurationService: vedi \vedi{SetConfigurationServiceDettaglio}.\\
\hline
RF.O.1.4 & SetConfigurationService: vedi \vedi{SetConfigurationServiceDettaglio}.\\
\end{xltabular}




\subsubsection{UploadDocuments}
\subsubsubsection{Descrizione}
Questa componente ha il compito di memorizzare i documenti inseriti dall'utente nel sistema di archiviazione e calcolare gli embeddings, memorizzandoli nel vector store configurato.
È costituita da:
\begin{itemize}
    \item \textbf{Route API}: /uploadDocuments;
    \item \textbf{Metodo}: POST;
    \item \textbf{Lista parametri HTTP}: 
    \begin{itemize}
        \item \code{documents}: una lista di documenti.
    \end{itemize}
    \item \textbf{Implementazione generale}: La componente viene implementata dal blueprint \code{uploadDocuments} che esegue i seguenti controlli:
        \begin{enumerate}
            \item Ogni documento deve avere un titolo;
            \item Ogni documento deve essere di tipo \textit{PDF} o \textit{DOC};
            \item Devono esserci dei documenti nell'area di staging.
        \end{enumerate}
\end{itemize}
\subsubsubsection{Esiti possibili}
\renewcommand{\arraystretch}{1.5}
\begin{xltabular}{\textwidth}{c|X|X}
\caption{Esiti possibili UploadDocuments}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endfirsthead
\caption[]{Esiti possibili UploadDocuments (cont)}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endhead
\multicolumn{3}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
200 & Upload avvenuto con successo. & - \\
\hline
400 & Non ci sono documenti di cui fare l'upload. & Parametri insufficienti.\\
\hline
422 & Un documento ha titolo vuoto. & L'upload di documenti senza titolo non è supportato.\\
\hline
422 & Formato non accettato. & Documento {filename} non supportato. \\
\hline
500 & Upload fallito. & Errore nell'upload dei documenti. \\
\end{xltabular}


\subsubsubsection{Lista sottocomponenti}
\begin{itemize}
    \item \textbf{AWSDocument}: vedi \vedi{AWSDocument};
    \item \textbf{AWSDocumentOperationResponse}: vedi \vedi{AWSDocumentOperationResponse};
    \item \textbf{AWSS3Manager}: vedi \vedi{AWSS3Manager};
    \item \textbf{Chunkerizer}: vedi \vedi{Chunkerizer};
    \item \textbf{Document}: vedi \vedi{Document};
    \item \textbf{DocumentContent}: vedi \vedi{DocumentContent};
    \item \textbf{DocumentId}: vedi \vedi{DocumentId};    
    \item \textbf{DocumentMetadata}: vedi \vedi{DocumentMetadata};
    \item \textbf{DocumentOperationResponse}: vedi \vedi{DocumentOperationResponse};
    \item \textbf{DocumentStatus}: vedi \vedi{DocumentStatus};
    %\item \textbf{DocumentToText}: vedi \vedi{DocumentToText};
    \item \textbf{DocumentType}: vedi \vedi{DocumentType};
    \item \label{DocumentsUploader}\textbf{DocumentUploader}: classe che si occupa di effettuare la chiamata dell'upload dei documenti nella porta esterna diretta verso il sistema di archiviazione documenti;
    \item \label{DocumentsUploaderAWSS3}\textbf{DocumentUploaderAWSS3}: classe adapter che implementa la porta DocumentUploaderPort, adattando la chiamata di DocumentUploader a AWSS3Manager;
    \item \label{DocumentsUploaderPort}\textbf{DocumentUploaderPort}: interfaccia che rappresenta la porta in uscita per effettuare l'upload dei documenti verso il sistema di archiviazione documenti;
    \item \textbf{DOCXTextExtractor}: vedi \vedi{DOCXTextExtractor};
    \item \textbf{EmbeddingsCreator}: vedi \vedi{EmbeddingsCreator};
    \item \textbf{EmbeddingsUploader}: vedi \vedi{EmbeddingsUploader};
    \item \textbf{EmbeddingsUploaderFacadeLangchain}: vedi \vedi{EmbeddingsUploaderFacadeLangchain};
    \item \textbf{EmbeddingsUploaderPort}: vedi \vedi{EmbeddingsUploaderPort};
    \item \textbf{EmbeddingsUploaderVectorStore}: vedi \vedi{EmbeddingsUploaderVectorStore};
    \item \textbf{HuggingFaceEmbeddingModel}: vedi \vedi{HuggingFaceEmbeddingModel};
    \item \textbf{LangchainDocument}: vedi \vedi{LangchainDocument};
    \item \textbf{LangchainEmbeddingModel}: vedi \vedi{LangchainEmbeddingModel};
    \item \label{NewDocument}\textbf{NewDocument}: classe di presentation che contiene le informazioni relative ai documenti appena inseriti dall'utente, presenti nella richiesta HTTP;
    \item \textbf{OpenAIEmbeddingModel}: vedi \vedi{OpenAIEmbeddingModel};
    \item \textbf{PDFTextExtractor}: vedi \vedi{PDFTextExtractor};
    \item \textbf{PlainDocument}: vedi \vedi{PlainDocument}
    \item \textbf{Status}: vedi \vedi{Status};
    \item \textbf{TextExtractor}: vedi \vedi{TextExtractor};
    \item \label{UploadDocumentsController}\textbf{UploadDocumentsController}: classe controller che si occupa del passaggio di Documents allo use case UploadDocumentsUseCase a partire da NewDocuments;
    \item \label{UploadDocumentsService}\textbf{UploadDocumentsService}: classe service che implementa lo use case UploadDocumentsUseCase;
    \item \label{UploadDocumentsUseCase}\textbf{UploadDocumentsUseCase}: interfaccia use case che rappresenta la porta della business logic in entrata per effettuare l'upload dei documenti;
    \item \textbf{VectorStoreChromaDBManager}: vedi \vedi{VectorStoreChromaDBManager};
    \item \textbf{VectorStoreDocumentOperationResponse}: vedi \vedi{VectorStoreDocumentOperationResponse};
    %\item \textbf{VectorStoreDocumentStatusResponse}: \vedi{VectorStoreDocumentStatusResponse};
    \item \textbf{VectorStoreManager}: vedi \vedi{VectorStoreManager};
    \item \textbf{VectorStorePineconeManager}: vedi \vedi{VectorStorePineconeManager}.
    
\end{itemize}


\subsubsubsection{Tracciamento dei requisiti}
\begin{xltabular}{\textwidth}{c|c}
\caption{Tracciamento dei requisiti nella componente UploadDocuments}\\
\textbf{Requisito} & \textbf{Soddisfacimento del requisito} \\
\endfirsthead
\caption[]{Tracciamento dei requisiti nella componente UploadDocuments (cont)}\\
\textbf{Requisito} & \textbf{Soddisfacimento del requisito} \\
\endhead
\multicolumn{2}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
RF.O.21 & UploadDocumentsService: vedi \vedi{UploadDocumentsServiceDettaglio}.\\
\hline
RF.O.22 & DocumentsUploader: vedi \vedi{DocumentsUploaderDettaglio}.\\
\hline
RF.O.22.1 & DocumentsUploader: vedi \vedi{DocumentsUploaderDettaglio}.\\
\hline
RF.O.22.2 & EmbeddingsUploader: vedi \vedi{EmbeddingsUploaderDettaglio}.\\
\hline
RF.O.22.3 & EmbeddingsUploader: vedi \vedi{EmbeddingsUploaderDettaglio}.\\
\hline
RF.O.23 & DocumentsUploader: vedi \vedi{DocumentsUploaderDettaglio}.\\
\hline
RF.O.23.1 & DocumentsUploader: vedi \vedi{DocumentsUploaderDettaglio}.\\
\hline
RF.O.23.2 & EmbeddingsUploader: vedi \vedi{EmbeddingsUploaderDettaglio}.\\
\hline
RF.O.23.3 & EmbeddingsUploader: vedi \vedi{EmbeddingsUploaderDettaglio}.\\

\end{xltabular}



\newpage
\subsection{Database} 
Il Database è composto dalle seguenti tabelle riguardanti la configurazione del sistema e la archiviazione delle chat:
\subsubsection{Configurazione del sistema}
\subsubsubsection{Diagramma ER}
\begin{figure}[H]
    \centering        
    \includegraphics[width=16.5cm]{img/ConfigurationDB.png}
    \caption{Diagramma ER: Configurations}
\end{figure}

\subsubsubsection{Definizione}
\begin{itemize}
     \item \textbf{configuration} che rappresenta la scelta di configurazione di vector store, document store, modello LLM e di embedding:\\
     Questa tabella contiene:
    \begin{itemize}
        \item \code{documentStore}: fa riferimento alla colonna \code{name} nella tabella \\\code{documentStoreConfiguration} e indica la configurazione del document store scelto;
        \item \code{embeddingModel}: fa riferimento alla colonna \code{name} nella tabella \\\code{embeddingModelConfiguration} e indica la configurazione del modello di embedding scelto;
        \item \code{LLMModel}: fa riferimento alla colonna \code{name} nella tabella \code{LLMModelConfiguration} e indica la configurazione del modello LLM scelto;
        \item \code{userId}: questa colonna funge da chiave primaria e identifica univocamente la configurazione;
        \item \code{vectorStore}: fa riferimento alla colonna \code{name} nella tabella \code{vectorStoreConfiguration} e indica la configurazione del vector store scelto.\\
    \end{itemize}

    \item \textbf{documentStoreConfiguration} che rappresenta la configurazione di un sistema di archiviazione dei documenti e contiene:
    \begin{itemize}
        \item \code{costIndicator}: indica il costo associato all'uso del document store;
         \item \code{description}: descrizione della organizzazione proprietaria del document store e del document store;
        \item \code{name}: il nome univoco del document store;
        \item \code{organization}: rappresenta l'associazione proprietaria del document store;
        \item \code{type}: indica il tipo di document store (locale o meno).\\
    \end{itemize}

    \item \textbf{embeddingModelConfiguration} che rappresenta la configurazione di un modello di embeddings e contiene:
    \begin{itemize}
        \item \code{costIndicator}: indicatore del costo associato all'uso del modello di embeddings;
         \item \code{description}: descrizione della organizzazione proprietaria del modello di embeddings e del modello di embeddings stesso;
        \item \code{name}: il nome univoco del modello di embeddings;
        \item \code{organization}: rappresenta l'associazione proprietaria del modello di embeddings;
        \item \code{type}: indica il tipo di modello di embeddings (locale o meno).\\
    \end{itemize}

\item \textbf{LLMModelConfiguration} che rappresenta la configurazione di un modello LLM e contiene:
    \begin{itemize}
        \item \code{costIndicator}: indicatore del costo associato all'uso del modello LLM;
         \item \code{description}: descrizione della organizzazione proprietaria del modello LLM e del modello di LLM stesso;
        \item \code{name}: il nome univoco del modello di LLM;
        \item \code{organization}: rappresenta l'associazione proprietaria del modello LLM;
        \item \code{type}: indica il tipo di modello LLM (locale o meno).\\
    \end{itemize}
    
\item \textbf{vectorStoreConfiguration} che rappresenta la configurazione di un vector store e contiene:
    \begin{itemize}
        \item \code{costIndicator}: indicatore del costo associato all'uso del vector store;
         \item \code{description}: descrizione della organizzazione proprietaria del vector store e del vector store;
        \item \code{name}: il nome univoco del vector store;
        \item \code{organization}: rappresenta l'associazione proprietaria del vector store;
        \item \code{type}: indica il tipo di vector store (locale o meno).\\
    \end{itemize}
    \end{itemize}

\subsubsection{Archiviazione chat}

\subsubsubsection{Diagramma ER}
\begin{figure}[H]
    \centering        
    \includegraphics[width=15.5cm]{img/ChatDB.png}
    \caption{Diagramma ER: Chats}
\end{figure}




\subsubsubsection{Definizione}
\begin{itemize}

    \item \textbf{chat} tabella che rappresenta una chat del Chatbot e contiene:
    \begin{itemize}
        \item \code{id}: chiave primaria univoca che identifica la chat;
        \item \code{title}: campo che sta per il titolo della chat, unico e non nullo.\\
    \end{itemize}
        
    \item \textbf{messageRelevantDocuments} tabella che rappresenta i documenti rilevanti usati per un messaggio del Chatbot:
    \begin{itemize}
        \item \code{documentId}: campo che identifica un documento rilevante; 
        \item \code{id}: chiave primaria univoca che fa riferimento alla colonna \code{id} nella tabella \code{messageStore}.\\
    \end{itemize}
         
    \item \textbf{messageStore} tabella che rappresenta un messaggio di una chat del Chatbot e contiene:
    \begin{itemize}
        \item \code{id}: chiave primaria univoca che identifica il messaggio;
        \item \code{message}: contenuto del messaggio, memorizzato come JSON;
        \item \code{sessionId}: fa riferimento alla colonna \code{id} nella tabella \code{chat} e indica la chat di apparteneza del messaggio. Permette inoltre la cancellazione a cascata.\\
    \end{itemize}
    
\end{itemize}




\newpage

\subsection{Riepilogo tracciamento dei requisiti}
\begin{xltabular}{\textwidth}{c|c}
\caption{Tabella riepilogativa del tracciamento dei requisiti}\\
\textbf{Requisito} & \textbf{Soddisfacimento del requisito} \\
\endfirsthead
\caption[]{Tabella riepilogativa del tracciamento dei requisiti (cont)}\\
\textbf{Requisito} & \textbf{Soddisfacimento del requisito} \\
\endhead
\multicolumn{2}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline 

    

RF.O.1 & SetConfigurationService: vedi \vedi{SetConfigurationServiceDettaglio}.\\
\hline 
RF.O.1.1 & SetConfigurationService: vedi \vedi{SetConfigurationServiceDettaglio}.\\
\hline 
RF.O.1.1.1 & LLMModelInit: vedi \vedi{LLMModelInitDettaglio}.\\ 
\hline 
RF.O.1.2 & SetConfigurationService: vedi \vedi{SetConfigurationServiceDettaglio}.\\
\hline 
RF.O.1.3 & SetConfigurationService: vedi \vedi{SetConfigurationServiceDettaglio}.\\
\hline 
RF.O.1.3.1 & EmbeddingModelInit: vedi \vedi{EmbeddingModelInitDettaglio}.\\    
\hline 
RF.O.1.4  & SetConfigurationService: vedi \vedi{SetConfigurationServiceDettaglio}.\\

\hline 
RF.O.1.4.1 &  DocumentStoreInit: vedi \vedi{DocumentStoreInitDettaglio}.\\
\hline 
RF.O.2  & ChangeLLMConfiguration: vedi \vedi{ChangeLLMConfigurationDettaglio}. \\ 
\hline 
RF.O.2.1  & ChangeLLMConfiguration: vedi \vedi{ChangeLLMConfigurationDettaglio}. \\ 
\hline 
RF.O.3 & VectorStoreInit: vedi \vedi{VectorStoreInitDettaglio}.\\
\hline 
RF.O.3.1 &  VectorStoreCard: vedi \vedi{VectorStoreCardDettaglio}.\\
\hline 
RF.O.4  & EmbeddingModelInit: vedi \vedi{EmbeddingModelInitDettaglio}.\\ 
\hline 
RF.O.4.1  & EmbeddingModelCard: vedi \vedi{EmbeddingModelCardDettaglio}.\\

\hline 
RF.O.5  & DocumentStoreInit: vedi \vedi{DocumentStoreInitDettaglio}.\\
\hline 
RF.O.5.1  & DocumentStoreCard: vedi \vedi{DocumentStoreCardDettaglio}.\\
\hline
 RF.O.6  & ChangeConfigurationService: vedi \vedi{ChangeConfigurationServiceDettaglio}.\\
\hline 
RF.O.6.1 & ChangeLLMConfiguration: vedi \vedi{ChangeLLMConfigurationDettaglio}.\\

\hline 
RF.OP.7  & NS \\
\hline 
RF.OP.7.1 & NS \\
\hline 
RF.OP.8 & NS \\
\hline 
RF.OP.8.1 & NS \\
\hline 
RF.OP.9 & NS \\
\hline 
RF.OP.9.1 & NS \\

\hline 
RF.O.10  & LLMCard: vedi \vedi{LLMCardDettaglio}.\\
\hline 
RF.O.10.1  & LLMCard: vedi \vedi{LLMCardDettaglio}.\\
\hline
RF.O.10.2  & LLMCard: vedi \vedi{LLMCardDettaglio}.\\
\hline 
RF.O.10.3  & LLMCard: vedi \vedi{LLMCardDettaglio}.\\
\hline 
RF.O.10.4  & LLMCard: vedi \vedi{LLMCardDettaglio}.\\
\hline 
RF.O.10.5  & LLMCard: vedi \vedi{LLMCardDettaglio}.\\
\hline
RF.O.11 &  VectorStoreCard: vedi \vedi{VectorStoreCardDettaglio}.\\ 
\hline
RF.O.11.1 &  VectorStoreCard: vedi \vedi{VectorStoreCardDettaglio}.\\ 
\hline
RF.O.11.2 &  VectorStoreCard: vedi \vedi{VectorStoreCardDettaglio}.\\ 
\hline
RF.O.11.3 &  VectorStoreCard: vedi \vedi{VectorStoreCardDettaglio}.\\ 
\hline
RF.O.11.4 &  VectorStoreCard: vedi \vedi{VectorStoreCardDettaglio}.\\ 
\hline
RF.O.11.5 &  VectorStoreCard: vedi \vedi{VectorStoreCardDettaglio}.\\ 
\hline
RF.O.12 &  EmbeddingModelCard: vedi \vedi{EmbeddingModelCardDettaglio}. \\
\hline
RF.O.12.1 &  EmbeddingModelCard: vedi \vedi{EmbeddingModelCardDettaglio}. \\
\hline
RF.O.12.2 &  EmbeddingModelCard: vedi \vedi{EmbeddingModelCardDettaglio}. \\
\hline
RF.O.12.3 &  EmbeddingModelCard: vedi \vedi{EmbeddingModelCardDettaglio}. \\
\hline
RF.O.12.4 &  EmbeddingModelCard: vedi \vedi{EmbeddingModelCardDettaglio}. \\
\hline
RF.O.12.5 &  EmbeddingModelCard: vedi \vedi{EmbeddingModelCardDettaglio}. \\
\hline
RF.O.13 & DocumentStoreCard: vedi \vedi{DocumentStoreCardDettaglio}. \\ 
\hline
RF.O.13.1 & DocumentStoreCard: vedi \vedi{DocumentStoreCardDettaglio}. \\ 
\hline
RF.O.13.2 & DocumentStoreCard: vedi \vedi{DocumentStoreCardDettaglio}. \\ 
\hline
RF.O.13.3 & DocumentStoreCard: vedi \vedi{DocumentStoreCardDettaglio}. \\ 
\hline
RF.O.13.4 & DocumentStoreCard: vedi \vedi{DocumentStoreCardDettaglio}. \\ 
\hline
RF.O.13.5 & DocumentStoreCard: vedi \vedi{DocumentStoreCardDettaglio}. \\ 
\hline
RF.O.14 & GetConfigurationService: vedi \vedi{GetConfigurationServiceDettaglio}.\\
\hline
RF.O.14.1 & GetConfigurationService: vedi \vedi{GetConfigurationServiceDettaglio}.\\
\hline
RF.O.14.2 & GetConfigurationService: vedi \vedi{GetConfigurationServiceDettaglio}.\\
\hline
RF.O.14.3 & GetConfigurationService: vedi \vedi{GetConfigurationServiceDettaglio}.\\
\hline
RF.O.14.4 &  GetConfigurationService: vedi \vedi{GetConfigurationServiceDettaglio}.\\
\hline
RF.O.15 & DocumentsList: vedi \vedi{DocumentsListDettaglio}.\\  

\hline
RF.O.15.1 & DocumentsListRow: vedi \vedi{DocumentsListRowDettaglio}.\\ 
\hline
RF.O.15.1.1 & DocumentsListRow: vedi \vedi{DocumentsListRowDettaglio}.\\ 
\hline
RF.O.15.1.2  &  DocumentsListRow: vedi \vedi{DocumentsListRowDettaglio}.\\  
\hline
RF.O.15.1.3 &  DocumentsListRow: vedi \vedi{DocumentsListRowDettaglio}.\\   
\hline
RF.O.15.1.4 &  DocumentsListRow: vedi \vedi{DocumentsListRowDettaglio}. \\
\hline
RF.O.16 & StagingArea: vedi \vedi{StagingAreaDettaglio}. \\ 
\hline
RF.O.16.1 & StagingArea: vedi \vedi{StagingAreaDettaglio}. \\ 
\hline
RF.O.16.2 & StagingArea: vedi \vedi{StagingAreaDettaglio}. \\  
\hline
RF.O.17 & StagingArea: vedi \vedi{StagingAreaDettaglio}. \\  
\hline
RF.O.17.1 & StagingArea: vedi \vedi{StagingAreaDettaglio}. \\ 
\hline
RF.O.17.2 & StagingArea: vedi \vedi{StagingAreaDettaglio}. \\ 
\hline
RF.O.17.3 & StagingArea: vedi \vedi{StagingAreaDettaglio}. \\ 
\hline
RF.O.18 &  StagingArea: vedi \vedi{StagingAreaDettaglio}. \\ 
\hline
RF.O.18.1 & StagingArea: vedi \vedi{StagingAreaDettaglio}. \\ 
\hline
RF.O.19 & StagingAreaRow: vedi \vedi{StagingAreaRowDettaglio}. \\ 
\hline
RF.O.20 & StagingAreaRow: vedi \vedi{StagingAreaRowDettaglio}. \\   
\hline
RF.O.21 & UploadDocumentsService: vedi \vedi{UploadDocumentsServiceDettaglio}.\\
\hline
RF.O.21.1 & StagingArea: vedi \vedi{StagingAreaDettaglio}.\\ 
\hline
RF.O.21.2 & StagingArea: vedi \vedi{StagingAreaDettaglio}.\\ 
\hline
RF.O.21.3 &  StagingArea: vedi \vedi{StagingAreaDettaglio}.\\  
\hline
RF.O.21.4 &  StagingArea: vedi \vedi{StagingAreaDettaglio}.\\ 
\hline
RF.O.21.5 & StagingArea: vedi \vedi{StagingAreaDettaglio}.\\  
\hline
RF.O.21.6 & StagingArea: vedi \vedi{StagingAreaDettaglio}.\\ 
\hline
RF.O.22 & DocumentsUploader: vedi \vedi{DocumentsUploaderDettaglio}.\\
\hline
RF.O.22.1 & DocumentsUploader: vedi \vedi{DocumentsUploaderDettaglio}.\\
\hline
RF.O.22.1.1 & StagingArea: vedi \vedi{StagingAreaDettaglio}.\\
\hline
RF.O.22.2 & EmbeddingsUploader: vedi \vedi{EmbeddingsUploaderDettaglio}.\\
\hline
RF.O.22.3 & EmbeddingsUploader: vedi \vedi{EmbeddingsUploaderDettaglio}.\\
\hline
RF.O.23 & DocumentsUploader: vedi \vedi{DocumentsUploaderDettaglio}.\\
\hline
RF.O.23.1 & DocumentsUploader: vedi \vedi{DocumentsUploaderDettaglio}.\\
\hline
RF.O.23.1.1 & StagingArea: vedi \vedi{StagingAreaDettaglio}.\\
\hline
RF.O.23.2 & EmbeddingsUploader: vedi \vedi{EmbeddingsUploaderDettaglio}.\\
\hline
RF.O.23.3 & EmbeddingsUploader: vedi \vedi{EmbeddingsUploaderDettaglio}.\\
\hline
RF.O.24 & GetDocumentsContentFacadeService: vedi \vedi{GetDocumentsContentFacadeServiceDettaglio}.\\
\hline
RF.O.25 & DeleteDocumentsService: vedi \vedi{DeleteDocumentsServiceDettaglio}.\\
\hline
RF.O.26 & DeleteDocuments: vedi \vedi{DeleteDocumentsDettaglio}.\\
\hline
RF.O.26.1 & DeleteDocuments: vedi \vedi{DeleteDocumentsDettaglio}.\\
\hline
RF.O.26.1.1  & DocumentsList: vedi \vedi{DocumentsListDettaglio}.\\
\hline
RF.O.26.2 & DeleteDocumentsEmbeddings: vedi \vedi{DeleteDocumentsEmbeddingsDettaglio}.\\
\hline
RF.O.26.3 & DeleteDocumentsEmbeddings: vedi \vedi{DeleteDocumentsEmbeddingsDettaglio}.\\
\hline
RF.O.27 & DeleteDocumentsService: vedi \vedi{DeleteDocumentsServiceDettaglio}.\\
\hline
RF.O.27.1 &  DocumentsListRow: vedi \vedi{DocumentsListRowDettaglio}.\\
\hline
RF.O.28 & DeleteDocuments: vedi \vedi{DeleteDocumentsDettaglio}.\\
\hline
RF.O.28.1 & DeleteDocuments: vedi \vedi{DeleteDocumentsDettaglio}.\\
\hline
RF.O.28.1.1 & DocumentsListRow: vedi \vedi{DocumentsListRowDettaglio}. \\
\hline
RF.O.28.2 & DeleteDocumentsEmbeddings: vedi \vedi{DeleteDocumentsEmbeddingsDettaglio}.\\
\hline
RF.O.28.3 & DeleteDocumentsEmbeddings: vedi \vedi{DeleteDocumentsEmbeddingsDettaglio}.\\
\hline
RF.O.29 & ConcealDocumentsService: vedi \vedi{ConcealDocumentsServiceDettaglio}.\\
\hline
RF.O.30 & ConcealDocumentsService: vedi \vedi{ConcealDocumentsServiceDettaglio}. \\
\hline
RF.O.30.1 & DocumentsListRow: vedi \vedi{DocumentsListRowDettaglio}. \\
\hline
RF.O.31 & EnableDocumentsService: vedi \vedi{EnableDocumentsServiceDettaglio}.\\
\hline
RF.O.32 & EnableDocumentsService: vedi \vedi{EnableDocumentsServiceDettaglio}.\\
\hline
RF.O.32.1 & DocumentsListRow: vedi \vedi{DocumentsListRowDettaglio}.\\
\hline
RF.O.33 & GetDocumentsFacadeService: vedi \vedi{GetDocumentsFacadeServiceDettaglio}.\\
\hline
RF.O.34  &  ChatListSideBar: vedi \vedi{ChatListSideBarDettaglio}. \\  
\hline
RF.O.34.1 & ChatListSideBar: vedi \vedi{ChatListSideBarDettaglio}. \\  
\hline
RF.O.34.1.1 & ChatListSideBar: vedi \vedi{ChatListSideBarDettaglio}. \\  
\hline
RF.O.34.1.2  & ChatListSideBar: vedi \vedi{ChatListSideBarDettaglio}. \\  
\hline
RF.O.34.1.3 & ChatListSideBar: vedi \vedi{ChatListSideBarDettaglio}. \\  
\hline
RF.O.34.1.4 & ChatListSideBar: vedi \vedi{ChatListSideBarDettaglio}. \\ 
\hline
RF.O.35 & ChatListSideBar: vedi \vedi{ChatListSideBarDettaglio}. \\
\hline
RF.O.36 & PostgresChatORM: vedi \vedi{PostgresChatORMDettaglio}.\\
\hline
RF.O.36.1 & ChatListSideBar: vedi \vedi{ChatListSideBarDettaglio}. \\
\hline
RF.O.37 & DeleteChatsService: vedi \vedi{DeleteChatsServiceDettaglio}.\\
\hline
RF.O.37.1 & ChatHeader: vedi \vedi{ChatHeaderDettaglio}. \\
\hline
RF.O.38 & DeleteChatsService: vedi \vedi{DeleteChatsServiceDettaglio}.\\
\hline
RF.O.38.1 & ChatListSideBar: vedi \vedi{ChatListSideBarDettaglio}. \\  
\hline
RF.O.38.2 &  ChatListSideBar: vedi \vedi{ChatListSideBarDettaglio}. \\
\hline
RF.O.39 & RenameChatService: vedi \vedi{RenameChatServiceDettaglio}.\\
\hline
RF.O.40 &  RenameChatService: vedi \vedi{RenameChatServiceDettaglio}. \\
\hline
RF.O.40.1 & ChatHeader: vedi \vedi{ChatHeaderDettaglio}. \\
\hline
RF.O.41 &  RenameChatService: vedi \vedi{RenameChatServiceDettaglio}. \\
\hline
RF.O.41.1 & ChatHeader: vedi \vedi{ChatHeaderDettaglio}.\\
\hline
RF.O.42 & GetChatMessagesService: vedi \vedi{GetChatMessagesServiceDettaglio}.\\
\hline
RF.O.43 & ChatContent: vedi \vedi{ChatContentDettaglio}.\\

\hline
RF.O.43.1 & ChatContent: vedi \vedi{ChatContentDettaglio}.\\  
\hline
RF.O.43.1.1 &  MessageCard: vedi \vedi{MessageCardDettaglio}.\\ 
\hline
RF.O.43.1.2 & MessageCard: vedi \vedi{MessageCardDettaglio}.\\
\hline
RF.D.44 & MessageCard: vedi \vedi{MessageCardDettaglio}.\\
\hline 
RF.D.45  & NS \\
\hline 
RF.D.46 & NS \\
\hline 
RF.D.46.1 & NS \\
\hline 
RF.D.46.2 & NS \\
\hline
RF.D.48 & MessageCard: vedi \vedi{MessageCardDettaglio}.\\
\hline
RF.OP.49  & NS \\
\hline 
RF.OP.50 & NS \\
\hline
RF.O.51 & ChatForm: vedi \vedi{ChatFormDettaglio}.\\  
\hline
RF.O.51.1 & ChatForm: vedi \vedi{ChatFormDettaglio}.\\ 
\hline
RF.O.51.2 & ChatForm: vedi \vedi{ChatFormDettaglio}. \\ 
\hline
RF.O.51.2.1 & ChatForm: vedi \vedi{ChatFormDettaglio}. \\  
\hline
RF.O.51.2.2 & ChatForm: vedi \vedi{ChatFormDettaglio}. \\
\hline
RF.O.52 &  AskChatbotService: vedi \vedi{AskChatbotServiceDettaglio}.\\
\hline
RF.O.53 & MessageCard: vedi \vedi{MessageCardDettaglio}.\\ 
\hline
RF.O.54. &  LLMModelType: vedi \vedi{LLMModelTypeDettaglio}.  \\
\hline
RF.OP.55 & NS \\
\hline 
RF.D.56 &  AskChatbotService: vedi \vedi{AskChatbotServiceDettaglio}.\\
\hline
RF.OP.57 & NS \\%AskChatbotService: vedi \vedi{AskChatbotServiceDettaglio}.\\
\hline
RF.O.58 & EmbedDocumentsService: vedi \vedi{EmbedDocumentsServiceDettaglio}.\\
\hline
RF.O.59 &  AskChatbotService: vedi \vedi{AskChatbotServiceDettaglio}.\\
\hline
RF.O.60 &  AskChatbotService: vedi \vedi{AskChatbotServiceDettaglio}.\\
\end{xltabular}










%\subsection{Libreria per la persistenza} %TODO
    % diagramma delle classi
    % x ogni entità ci sarà una classe:
    %     - annotazioni (non ci sono in py, non penso di metterle)
    %     - attributi privati
    %     - costruttori

\newpage

\section{Progettazione di dettaglio frontend}

%CHATBOT-FRONTEND
\subsection{Chatbot}

\subsubsection{Lista delle sottocomponenti}

\subsubsubsection{ChatContent}
\label{ChatContentDettaglio}
\begin{itemize}
    \item \textbf{Elementi determinanti}:
     \begin{itemize}
        \item Messagges: i messaggi rappresentati sotto forma di MessageCard ordinati cronologicamente.
    \end{itemize}
\end{itemize}


\subsubsubsection{ChatForm}
\label{ChatFormDettaglio}
\begin{itemize}
    \item \textbf{Elementi determinanti}:
    \begin{itemize}
        \item Send Button: per l'invio della richiesta contenuta nella texting Area;
        \item Pause-Play Button: per mettere in pausa o in play la registrazione del messaggio vocale;
        \item Record Button: per iniziare la registrazione del messaggio vocale;
        \item Texting Area: per l'inserimento di messaggi testuali;
        \item Vocal Message Button: per l'inserimento di messaggi vocali.
    \end{itemize}
\end{itemize}


\subsubsubsection{ChatHeader}
\label{ChatHeaderDettaglio}
\begin{itemize}
    \item \textbf{Elementi determinanti}:
    \begin{itemize}
        \item Delete Chat Button: per eliminare la chat corrente;
        \item Rename Chat Button: per rinominare la chat corrente;
        \item Title: campo per la visualizzazione e la modifica del titolo.
    \end{itemize}

\end{itemize}


\subsubsubsection{ChatListSideBar}
\label{ChatListSideBarDettaglio}
\begin{itemize}
    \item \textbf{Elementi determinanti}:
    \begin{itemize}
        \item Abort Delete Button: per annullare l'eliminazione delle chat selezionate;
        \item Chat Search Bar: campo di inserimento per permettere la ricerca delle chat;
        \item Chat List: sezione che contiene i record delle chat salvate;
        \item Confirm Delete Button: per confermare l'eliminazione delle chat selezionate;
        \item New Chat Button: per creare una nuova chat;
        \item Select Chat: componente per permettere di selezionare più chat da eliminare.
    \end{itemize}
\end{itemize}


\subsubsubsection{MessageCard}
\label{MessageCardDettaglio}
\begin{itemize}
    \item \textbf{Elementi determinanti}:
    \begin{itemize}
        \item Copy Button: elemento che permette di copiare il testo del messaggio;
        \item Message Content: elemento che contiene il testo del messaggio e i collegamenti ai documenti pertinenti nel caso dei messaggi del chatbot;
        \item Referenced Docs Shortcut: pulsante  presente nei messaggi del chatbot che permette di visualizzare i documenti pertinenti alla risposta;
        \item Timestamp: campo contenente data e ora di invio del messaggio.
    \end{itemize}
\end{itemize}


%DASHBOARD-FRONTEND
\subsection{Dashboard}

\subsubsection{Lista delle sottocomponenti}

\subsubsubsection{DashboardHeader}
\label{DashboardHeaderDettaglio}
\begin{itemize}
    \item \textbf{Elementi determinanti}:
    \begin{itemize}
        \item New Chat Shortcut: elemento che permette di passare velocemente alla finestra Chatbot con una nuova chat aperta;
        \item Upload Document Shortcut: elemento ch epermette di passare velocemente alla finestra Documents per caricare un nuovo documento.   
    \end{itemize}
\end{itemize}


\subsubsubsection{DocumentPreview}
\label{DocumentPreviewDettaglio}
\begin{itemize}
    \item \textbf{Elementi determinanti}:
    \begin{itemize}
        \item Close Preview Button: elemento che permette di chiudere la preview pop-up del documento selezionato;
        \item Document Info: scheda che permette di vedere lo status del documento, la dimensione, il formato, e la data di caricamento;
        \item Document Title: campo che contiene il nome del documento;
        \item View Document Button: elemento che permette di vedere per intero il documento selezionato.
    \end{itemize}
\end{itemize}

\subsubsubsection{LatestChatContent}
\label{LatestChatContentDettaglio}
\begin{itemize}
    \item \textbf{Elementi determinanti}:
    \begin{itemize}
        \item Expand Chat Button: elemento che permette di aprire la finestra Chatbot con la chat più recente aperta;
        \item Recent Chat Messages: i messaggi della chat più recente rappresentati sotto forma di MessageCard ordinati cronologicamente.
    \end{itemize}
\end{itemize}

\subsubsubsection{MessageCard}
Vedi \vedi{MessageCardDettaglio}.


\subsubsubsection{RecentChatsList}
\label{RecentChatsListDettaglio}
\begin{itemize}
    \item \textbf{Elementi determinanti}:
    \begin{itemize}
        \item Recent Chat Row: componenteche rappresenta una chat con la quale l'utente ha recentemente interagito e ne mostra una preview.
    \end{itemize}
\end{itemize}


\subsubsubsection{RecentlyViewedTab}
\label{RecentlyViewedTabDettaglio}
\begin{itemize}
    \item \textbf{Elementi determinanti}:
    \begin{itemize}
        \item Recently Uploaded Document Record: elemento che rappresenta un documento recentemente visualizzato e ne mostra il titolo, formato, dimensioni e status.
    \end{itemize}
\end{itemize}

\subsubsubsection{RecentlyUploadedTab}
\label{RecentlyUploadedTabDettaglio}
\begin{itemize}
    \item \textbf{Elementi determinanti}:
    \begin{itemize}
        \item Recently Uploaded Document Record: elemento che rappresenta un documento recentemente caricato nel sistema e ne mostra il titolo, formato, dimensioni e status.
    \end{itemize}
\end{itemize}




%DOCUMENTS-FRONTEND

\subsection{Documents}

\subsubsection{Lista delle sottocomponenti}

\subsubsubsection{DocumentsList}
\label{DocumentsListDettaglio}
\begin{itemize}
    \item \textbf{Elementi determinanti}:
     \begin{itemize}
        \item Documents: i documenti rappresentati sotto forma di DocumentsListRow;
        \item Delete Selected Button: per eliminare i DocumentsListRow selezionati;
        \item Nav Row Pages Buttons: per navigare tra le pagine di DocumentsListRow;
        \item Order By Button: per ordinare secondo i diversi campi informazione dei DocumentsListRow;
        \item Rows Per Page: per scegliere il numero di DocumentsListRow per pagina;
        \item Status Filter: per visualizzare i documenti in base allo status selezionato;
        \item Title Search Bar: per ricercare i documenti per titolo;
        \item Type Filter: per visualizzare i documenti in base al formato selezionato; 
    \end{itemize}
\end{itemize}


\subsubsubsection{DocumentsListRow}
\label{DocumentsListRowDettaglio}
\begin{itemize}
    \item \textbf{Elementi determinanti}:
     \begin{itemize}
        \item Document Info: parte del record che contiene informazioni significative del documento quali la dimensione, lo status, il formato e la data di upload;
        \item Document Title: parte del record che contiene il titolo del documento;
        \item Conceal Document Button: per occultare gli embeddings di un documento abilitato;
        \item Delete Document Button: per eliminare il documento selezionato;
        \item Embed Document Button: per creare gli embeddings di un documento \textit{Not Embedded};
        \item Enable Document Button: per abilitare un documento occultato;
        \item Select Row Button: per selezionare il record del documento;
        \item View Document Button: per visualizzare il documento selezionato.
    \end{itemize}
\end{itemize}

\subsubsubsection{StagingArea}
\label{StagingAreaDettaglio}
\begin{itemize}
    \item \textbf{Elementi determinanti}:
     \begin{itemize}
        \item Cancel Upload Button: per annullare l'upload dei documenti caricati in area di staging;
        \item Drag\&Drop Area: area dove è possibile trascinare e rilasciare i file nell'area di staging;
        \item Staged Documents: i documenti caricati nell'area di staging, rappresentati sotto forma di StagingAreaRow;
        \item Upload Button: per confermare l'upload dei documenti caricati in area di staging.
    \end{itemize}
\end{itemize}

\subsubsubsection{StagingAreaRow}
\label{StagingAreaRowDettaglio}
\begin{itemize}
    \item \textbf{Elementi determinanti}:
     \begin{itemize}
        \item Cancel Staging Button: per eliminare il documento caricato in area di staging;
        \item Staged Document Info: parte del record che contiene informazioni significative del documento caricato in area di staging, quali il titolo, la dimensione e il formato.
    \end{itemize}
\end{itemize}


%DocumentViewer-FRONTEND 
\subsection{DocumentView}
\subsubsection{Lista delle sottocomponenti}

\subsubsubsection{DocumentViewer}
\label{DocumentViewerDettaglio}
\begin{itemize}
    \item \textbf{Elementi determinanti}:
     \begin{itemize}
        \item Document Viewer Box: componente che permette di visualizzare l'intero documento \textit{PDF} o \textit{DOC} selezionato.
    \end{itemize}
\end{itemize}






%CHATBOT-FRONTEND 
\subsection{SettingsAppearance}
\subsubsection{Lista delle sottocomponenti}

\subsubsubsection{ThemeSelection}
\label{ThemeSelectionDettaglio}
\begin{itemize}
    \item \textbf{Elementi determinanti}:
     \begin{itemize}
        \item System Theme Choice: per selezionare il tema del sistema sul quale gira l'applicazione;       
        \item Theme Preview: elemento che mostra una anteprima del tema;
        \item Update Preferences Button: elemento che permette di applicare il tema scelto.
    \end{itemize}
\end{itemize}


%Settingsconfiguration-FRONTEND
\subsection{SettingsConfiguration}
\subsubsection{Lista delle sottocomponenti}

\subsubsubsection{ChangeLLMConfiguration}
\label{ChangeLLMConfigurationDettaglio}
\begin{itemize}
    \item \textbf{Elementi determinanti}:
     \begin{itemize}
        \item Change LLM Carousel: contiene una LLMCard selezionabile per ogni opzione disponibile di modello LLM;
        \item Confirm Configuration Button: elemento per confermare la scelta di LLM selezionata nel Change LLM Carousel.
    \end{itemize}
\end{itemize}



\subsubsubsection{CurrentConfigurationCarousel}
\label{CurrentConfigurationCarouselDettaglio}
\begin{itemize}
    \item \textbf{Elementi determinanti}:
     \begin{itemize}
        \item Chosen Document Store: una DocumentStoreCard che indica il sistema di archiviazione della configurazione corrente;
        \item Chosen Embedding Model: una EmbeddingModelCard che indica il modello di embeddings della configurazione corrente;
        \item Chosen LLM Model: una LLMCard che indica il modello LLM della configurazione corrente;
        \item Chosen Vector Store: una VectorStoreCard che indica il vector store della configurazione corrente.
    \end{itemize}
\end{itemize}

\subsubsubsection{DocumentStoreCard}
\label{DocumentStoreCardDettaglio}
\begin{itemize}
    \item \textbf{Elementi determinanti}:
     \begin{itemize}
        \item Document Store Cost Indicator: campo che fornisce informazioni sul costo del document store;
        \item Document Store Description: campo che descrive il document store e la organizzazione proprietaria;
        \item Document Store Name: campo che rappresenta il nome del document store;
        \item Document Store Organization: campo che rappresenta il nome dell'organizzazione proprietaria di quel document store;
        \item Document Store Type: campo che indica il tipo di document store.
    \end{itemize}
\end{itemize}


\subsubsubsection{EmbeddingModelCard}
\label{EmbeddingModelCardDettaglio}
\begin{itemize}
    \item \textbf{Elementi determinanti}:
     \begin{itemize}
        \item Embedding Model Cost Indicator: campo che fornisce informazioni sul costo del modello di embedding;
        \item Embedding Model Description: campo che descrive il modello di embedding e la organizzazione proprietaria;
        \item Embedding ModelName: campo che rappresenta il nome del modello di embedding;
        \item Embedding Model Organization: campo che rappresenta il nome dell'organizzazione proprietaria di quel modello di embedding;
        \item Embedding Model Type: campo che indica il tipo di modello di embedding.
        
    \end{itemize}
\end{itemize}


\subsubsubsection{LLMCard}
\label{LLMCardDettaglio}
\begin{itemize}
    \item \textbf{Elementi determinanti}:
     \begin{itemize}
        \item LLM Cost Indicator: campo che fornisce informazioni sul costo del modello LLM;
        \item LLM Description: campo che descrive il modello LLM e la organizzazione proprietaria;
        \item LLM Name: campo che rappresenta il nome del modello LLM;
        \item LLM Organization: campo che rappresenta il nome dell'organizzazione proprietaria di quel modello LLM;
        \item LLM Type: campo che indica il tipo di modello LLM.
        
    \end{itemize}
\end{itemize}


\subsubsubsection{VectorStoreCard} 
\label{VectorStoreCardDettaglio}
\begin{itemize}
    \item \textbf{Elementi determinanti}:
     \begin{itemize}
        \item Vector Store Cost Indicator: campo che fornisce informazioni sul costo del vector store;
        \item Vector Store Description: campo che descrive il vector store e la organizzazione proprietaria;
        \item Vector Store Name: campo che rappresenta il nome del vector store;
        \item Vector Store Organization: campo che rappresenta il nome dell'organizzazione proprietaria di quel vector store;
        \item Vector Store Type: campo che indica il tipo di vector store.
    \end{itemize}
\end{itemize}



%SetUp(Primo avvio)-FRONTEND
\subsection{SetUp(Primo avvio)}
\subsubsection{Lista delle sottocomponenti}

\subsubsubsection{ConfirmConfiguration} 
\label{ConfirmConfigurationDettaglio}
\begin{itemize}
    \item \textbf{Elementi determinanti}:
     \begin{itemize}
        \item Confirm Configuration Choices Button: elemento che permette di confermare le scelte di vector store, document store, modello di embeddings e LLM al primo avvio dell'applicazione.
    \end{itemize}
\end{itemize}


\subsubsubsection{DocumentStoreCard} 
Vedi \vedi{DocumentStoreCardDettaglio}.

\subsubsubsection{DocumentStoreInit} 
\label{DocumentStoreInitDettaglio}
\begin{itemize}
    \item \textbf{Elementi determinanti}:
     \begin{itemize}
        \item Document Store Choices: componente che contiene una DocumentStoreCard selezionabile per ogni sistema di archiviazione dei documenti disponibile.
    \end{itemize}
\end{itemize}

\subsubsubsection{EmbeddingModelCard} 
Vedi \vedi{EmbeddingModelCardDettaglio}.


\subsubsubsection{EmbeddingModelInit} 
\label{EmbeddingModelInitDettaglio}
\begin{itemize}
    \item \textbf{Elementi determinanti}:
     \begin{itemize}
        \item Embedding Model Choices: componente che contiene una EmbeddingModelCard selezionabile per ogni modello di embeddings disponibile.
    \end{itemize}
\end{itemize}



\subsubsubsection{LLMCard} 
Vedi \vedi{LLMCardDettaglio}.

\subsubsubsection{LLMModelInit} 
\label{LLMModelInitDettaglio}
\begin{itemize}
    \item \textbf{Elementi determinanti}:
     \begin{itemize}
        \item LLM Model Choices: componente che contiene una LLMCard selezionabile per ogni modello LLM disponibile.
    \end{itemize}
\end{itemize}


\subsubsubsection{VectorStoreCard} 
Vedi \vedi{VectorStoreCardDettaglio}.

\subsubsubsection{VectorStoreInit} 
\label{VectorStoreInitDettaglio}
\begin{itemize}
    \item \textbf{Elementi determinanti}:
     \begin{itemize}
        \item Vector Store Choices: componente che contiene una VectorStoreCard selezionabile per ogni vector store disponibile.
    \end{itemize}
\end{itemize}


%Sidebar-FRONTEND
\subsection{SideBar}
\subsubsection{Lista delle sottocomponenti}

\subsubsubsection{NavigationMenu} 
\label{NavigationMenuDettaglio}
\begin{itemize}
    \item \textbf{Elementi determinanti}:
     \begin{itemize}
        \item Chatbot Nav Button: per raggiungere la pagina Chatbot;
        \item Dashboard Nav Button: per raggiungere la Dashboard dell'applicazione;
        \item Documents Nav Button: per raggiungere la pagine Documents.
    \end{itemize}
\end{itemize}

\subsubsubsection{SettingShortcut} 
\label{SettingShortcutDettaglio}
\begin{itemize}
    \item \textbf{Elementi determinanti}:
     \begin{itemize}
        \item Settings Nav Button: per raggiungere le impostazioni dell'applicazione.
    \end{itemize}
\end{itemize}


\newpage
   
\section{Progettazione di dettaglio backend}



 % Per ogni componente:
    %    - diagramma di dettaglio
    %    Indicare per ogni sottocomponente:
    %        - attributi (nome: tipo)
    %        - metodi (firma, descrizione)
    % - interfacce implementate
\subsection{AskChatbot}
\subsubsection{Diagramma delle classi}

\begin{figure}[H]
    \centering        
    \rotatebox{90}{\includegraphics[width=1.2\textwidth]{img/AskChatbot.png}}
    \caption{Diagramma delle classi della componente AskChatbot}
\end{figure}


\subsubsection{Lista delle sottocomponenti}

\subsubsubsection{AskChatbotController}
\label{AskChatbotControllerDettaglio}
\begin{itemize}
    \item \textbf{\textit{Attributi\pg}}:
    \begin{itemize}
        \item \code{useCase: AskChatbotUseCase}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{askChatbot(message:string, ChatId:int): MessageResponse}\\
        Metodo che ritorna un MessageResponse rappresentante la risposta da parte del chatbot ad un messaggio dell'utente sotto forma di string, appartenente alla chat identificata dall'intero chatId. Nel caso in cui il chatId sia vuoto e venga inoltre generata correttamente una risposta, viene creata una nuova chat;
        %\item \code{toChatIdFrom(chatIdInt:int): ChatId}\\
        %Metodo che trasforma un intero in un ChatId;
        %\item \code{toMessage(message: string): Message}\\
        %Metodo che trasforma una stringa un Message.
        
    \end{itemize}
\end{itemize}


\subsubsubsection{AskChatbotLangchain}
\label{AskChatbotLangchainDettaglio}
\begin{itemize}
    \item \textbf{Implementa}: AskChatbotPort;
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{chain\pg: langchain.Chain};
        \item \code{chatHistoryManager: ChatHistoryManager}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{askChatbot(message:Message, chatId:ChatId): MessageResponse}\\
        Implementazione del metodo astratto di AskChatbotPort per ottenere una risposta dal chatbot ad un messaggio appartenente ad una chat identificata da un ChatId. 
    \end{itemize}
\end{itemize}

\subsubsubsection{AskChatbotPort}
\label{AskChatbotPortDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{askChatbot(message: Message, chatId: ChatId): MessageResponse}\\
        Metodo astratto per ottenere una risposta dal chatbot ad un messaggio appartenente ad una chat identificata da un ChatId. Nel caso in cui il chatId sia vuoto e venga inoltre generata correttamente una risposta, viene creata una nuova chat.
    \end{itemize}
\end{itemize}

\subsubsubsection{AskChatbotService}
\label{AskChatbotServiceDettaglio}
\begin{itemize}
    \item \textbf{Implementa}: AskChatbotUseCase;
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{askChatbotoutPort: AskChatbotPort};
        \item \code{persistChatOutPort: PersistChatPort}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{askChatbot(message:Message, chatId:ChatId): MessageResponse}\\
        Implementazione del metodo astratto di AskChatbotUseCase per ottenere tramite outPort una risposta dal chatbot ad un messaggio appartenente ad una chat identificata da un ChatId. Nel caso in cui il chatId sia vuoto e venga inoltre generata correttamente una risposta, viene creata una nuova chat.
    \end{itemize}
\end{itemize}

\subsubsubsection{AskChatbotUseCase}
\label{AskChatbotUseCaseDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{askChatbot(message:Message, chatId:ChatId): MessageResponse}\\
        Metodo astratto per ottenere una risposta dal chatbot ad un messaggio appartenente ad una chat identificata da un ChatId. Nel caso in cui il chatId sia vuoto e venga inoltre generata correttamente una risposta, viene creata una nuova chat.
    \end{itemize}
\end{itemize}

\subsubsubsection{ChatHistoryManager}
\label{ChatHistoryManagerDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{getChatHistory(chatId:int): langchain.PostgresChatMessageHistory}\\
        Metodo per ottenere una langchain.PostgresChatMessageHistory rappresentante il contesto di una chat identificata da un ChatId.
    \end{itemize}
\end{itemize}


\subsubsubsection{ChatId}
\label{ChatIdDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{id: int}.
    \end{itemize}
\end{itemize}


\subsubsubsection{ChatOperationResponse}
\label{ChatOperationResponseDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{chatId: ChatId};
        \item \code{message: string};
        \item \code{status: boolean}.
    \end{itemize}
\end{itemize}

\subsubsubsection{Message}
\label{MessageDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{content: string};
        \item \code{relevantDocument: List<DocumentId>};
        \item \code{sender: MessageSender};
        \item \code{timestamp: datetime}.
    \end{itemize}
\end{itemize}

\subsubsubsection{MessageResponse}
\label{MessageResponseDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}  
        \item \code{chatId: ChatId};
        \item \code{message: Message};
        \item \code{status: boolean}.
    \end{itemize}
\end{itemize}


\subsubsubsection{MessageSender (Enumeration)}
\label{MessageSenderDettaglio}
\begin{itemize}
    \item \textbf{Valori}:
    \begin{itemize}
        \item \code{Chatbot};
        \item \code{User}.
    \end{itemize}
\end{itemize}

\subsubsubsection{PersistChatPort}
\label{PersistChatPortDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{persistChat( messages:List<Message>, chatId:ChatId): ChatOperationResponse}\\
        Metodo astratto che prende una lista di Messages e la rende persistente, resituendo un ChatOperationResponse, che rappresenta l'esito della operazione.
    \end{itemize}
\end{itemize}

\subsubsubsection{PostgresChat}
\label{PostgresChatDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{id: int};
        \item \code{messages: List<PostgresMessage>};
        \item \code{title: string}.     
    \end{itemize}    
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{toChat():Chat}\\
        Metodo che ritorna un oggetto Chat.
    \end{itemize}
\end{itemize}


\subsubsubsection{PostgresChatOperationResponse}
\label{PostgresChatOperationResponseDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{chatId: int};
        \item \code{message: string};
        \item \code{status: boolean}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{toChatOperationResponse():} \code{ChatOperationResponse}\\
        Metodo che ritorna l'esito dell'operazione effettuata sottoforma di ChatOperationResponse.
    \end{itemize}
\end{itemize}


\subsubsubsection{PostgresMessage}
\label{PostgresMessageDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{content: string};
        \item \code{relevantDocument: List<string>};        
        \item \code{sender: PostgresMessageSenderType};
        \item \code{timestamp: datetime}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{toMessage(): Message}\\
        Metodo che permette di passare da PostgresMessage a un oggetto Message.
    \end{itemize}
\end{itemize}

\subsubsubsection{PostgresMessageSenderType(Enumeration)}
\label{PostgresMessageSenderTypeDettaglio}
\begin{itemize}
    \item \textbf{Valori}:
    \begin{itemize}
        \item \code{AI};
        \item \code{human}.
    \end{itemize}
\end{itemize}

\subsubsubsection{PostgresPersistChat}
\label{PostgresPersistChatDettaglio}
\begin{itemize}
    \item \textbf{Implementa}: PersistChatPort;
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{postgresChatORM: PostgresChatORM}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{persistChat(messages:List<Message>, chatId: ChatId): ChatOperationResponse}\\
        Metodo che implementa il metodo persistChat di PersistChatPort; prende una lista di Messages e la rende persistente, restituendo un ChatOperationResponse, che rappresenta l'esito della operazione.
        \item \code{toPostgresMessageFrom(message:Message): PostgresMessage}\\
        Metodo che permette di passare da un oggetto Message ad un oggetto persistente PostgresMessage.
    \end{itemize}
\end{itemize}





\subsubsubsection{PostgresChatORM}
\label{PostgresChatORMDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{createChat(): PostgresChatOperationResponse}\\
        Metodo per creare una nuova PostgresChat sul database Postgres utilizzato per la storicizzazione della chat;

        \item \code{deleteChats(chatIds:List<int>): List<PostgresChatOperationResponse>}\\
        Metodo per eliminare chat sul database Postgres, utilizzato per la storicizazzione delle chat. Ritorna l'esito dell'operazione con una lista di PostgresChatOperationResponse;
        
        \item \code{getChatMessages(chatId:int): PostgresChat}\\
        Metodo per ottenere una PostgresChat dal database Postgres utilizzato per la storicizzazione delle chat a partire da un intero rappresentante l'id della chat;

        \item \code{getChats(chatFilter:string): List<PostgresChatPreview>}\\
        Metodo per ottenere una lista di PostgresChatPreview dal database Postgres utilizzato per la storicizzazione delle chat, eventualmente filtrando la ricerca attraverso chatFilter;

        \item \code{persistChat(messages:List<PostgresMessage>, chatId:int):}\\ \code{ PostgresChatOperationResponse}\\
        Metodo che prende una lista di PostgresMessages e la rende persistente utilizzando il metodo saveMessages. Restituisce un PostgresChatOperationResponse, che rappresenta l'esito della operazione.
        
        \item \code{renameChat(chatId:int, title:string): PostgresChatOperationResponse}\\
        Metodo per rinominare con title una chat identificata tramite chatId sul database Postgres utilizzato per la storicizzazione delle chat. Ritorna l'esito dell'operazione con un PostgresChatOperationResponse;
        
        \item \code{saveMessages(messages:List<PostgresMessage>, chatId:int):}\\ \code{PostgresChatOperationResponse}\\
        Metodo per salvare una lista di PostgresMessages. Restituisce l'esito dell'operazione come PostgresChatOperationResponse.
        
        
    \end{itemize}
\end{itemize}




 \subsection{ChangeConfiguration}
 \subsubsection{Diagramma delle classi}

 \begin{figure}[H]
    \centering        
    \includegraphics[width=17cm]{img/ChangeConfiguration.png}
    \caption{Diagramma delle classi della componente ChangeConfiguration}
\end{figure}



 \subsubsection{Lista delle sottocomponenti}
 


 \subsubsubsection{ChangeConfigurationController}
\label{ChangeConfigurationControllerDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{useCase: ChangeConfigurationUseCase}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{changeLLMModel(LLMModel:string): ConfigurationOperationResponse}\\
        Metodo che si occupa di effettuare il cambio di configurazione del LLMModel identificato da una stringa e ritorna l'esito della operazione come ConfigurationOperationResponse.
    \end{itemize}
\end{itemize}

\subsubsubsection{ChangeConfigurationPort}
\label{ChangeConfigurationPortDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{changeLLMModel(LLMModel:LLMModelType): ConfigurationOperationResponse}\\
        Metodo astratto che si occupa di effettuare il cambio di configurazione del modello LLM con LLMModelType e ritorna l'esito della operazione come ConfigurationOperationResponse.
    \end{itemize}
\end{itemize}

\subsubsubsection{ChangeConfigurationPostgres}
\label{ChangeConfigurationPostgresDettaglio}
\begin{itemize}
    \item \textbf{Implementa}: ChangeConfigurationPort;
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{postgresConfigurationORM: PostgresConfigurationORM}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{changeLLMModel(LLMModel:LLMModelType): ConfigurationOperationResponse}\\
        Implementazione del metodo astratto di ChangeConfigurationPort per eseguire il cambio di configurazione del LLMModel. Ritorna l'esito della operazione come ConfigurationOperationResponse;
        \item \code{toPostgresLLMModelTypeFrom(LLMModel:LLMModelType):}\code{ PostgresLLMModelType}\\
        Metodo che ottiene un PostgresLLMModelType a partire da un LLMModelType.
    \end{itemize}
\end{itemize}



\subsubsubsection{ChangeConfigurationService}
\label{ChangeConfigurationServiceDettaglio}
\begin{itemize}
    \item \textbf{Implementa}: ChangeConfigurationUseCase;
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{outPort: ChangeConfigurationPort}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{changeLLMModel(LLMModel:LLMModelType): ConfigurationOperationResponse}\\
        Implementazione del metodo astratto di ChangeConfigurationUseCase per eseguire il cambio di configurazione del LLMModel. Ritorna l'esito della operazione come ConfigurationOperationResponse.
    \end{itemize}
\end{itemize}



\subsubsubsection{ChangeConfigurationUseCase}
\label{ChangeConfigurationUseCaseDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{changeLLMModel(LLMModel:LLMModelType): ConfigurationOperationResponse}\\
        Metodo astratto per eseguire il cambio di configurazione del LLMModel. Ritorna l'esito della operazione come ConfigurationOperationResponse.
    \end{itemize}
\end{itemize}

\subsubsubsection{ConfigurationOperationResponse}
\label{ConfigurationOperationResponseDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{message: string};
        \item \code{status: boolean}.
    \end{itemize}
    
\subsubsubsection{PostgresConfigurationOperationResponse}
\label{PostgresConfigurationOperationResponseDettaglio}
    \begin{itemize}
        
        \item \textbf{Attributi}:
        \begin{itemize}
        \item \code{message: string};
        \item \code{status: boolean}.
        \end{itemize}
        \item \textbf{Metodi}:
        \begin{itemize}
            \item \code{toConfigurationOperationResponse(): ConfigurationOperationResponse}\\
            Metodo per ottenere un ConfigurationOperationResponse a partire dal PostgresChatOperationResponse.
        \end{itemize}
        
    \end{itemize}
    
\end{itemize}
    

    \subsubsubsection{PostgresConfigurationORM}
    \label{PostgresConfigurationORMDettaglio}
    \begin{itemize}
        \item \textbf{Metodi}:
        \begin{itemize}
            \item \code{changeLLMModel(userId:int, LLMModel:PostgresLLMModelType):}\\ \code{ PostgresConfigurationOperationResponse}\\
            Metodo che esegue il cambio di configurazione del LLMModel con un PostgresLLMModelType. Ritorna l'esito della operazione come PostgresConfigurationOperationResponse;

            \item \code{getConfiguration(userId:int): PostgresConfiguration}\\
            Metodo per ottenere la configurazione del sistema; ricava le configurazioni di userId, vector store, modello di embedding, LLM e metodo di storicizzazione dei documenti. Ritorna un oggetto PostgresConfiguration;
            
            \item \code{getConfigurationChoices(userId:int): PostgresConfigurationChoice}\\
            Metodo che restituisce la scelta di configurazione dell'utente come oggetto PostgresConfigurationChoice;

            \item \code{getDocumentStoreOptions(): List<PostgresDocumentStoreConfiguration>}\\
            Metodo che restituisce una lista delle possibili alternative di configurazione di storage per i documenti sottoforma di lista di PostgresDocumentStoreConfiguration;

            \item \code{getEmbeddingModelOptions(): List<PostgresEmbeddingModelConfiguration>}\\
            Metodo che restituisce le possibili scelte di configurazione per il modello di embeddingm sottoforma di una lista di PostgresEmbeddingModelConfiguration;

            \item \code{getLLMModelOptions(): List<PostgresLLMModelConfiguration>}\\
            Metodo che restituisce le possibili scelte di modelli LLM sottoforma di  lista di PostgresLLMModelConfiguration;

            \item \code{getVectorStoreOptions(): List<PostgresVectorStoreConfiguration>:}\\
            Metodo che restituisce la lista delle possibili alternative di configurazione di vector store sottoforma di lista di PostgresVectorStoreConfiguration.

            \item \code{setConfiguration(userId:int, LLMModel:PostgresLLMModelType,} \\\code{ DocumentStore:PostgresDocumentStoreType, VectorStore:PostgresVectorStoreType,}\\ \code{EmbeddingModel:PostgresEmbeddingModelType):}\\ \code{ PostgresConfigurationOperationResponse}\\
            Metodo per impostare le configurazioni di vector store, modello di embedding, LLM e metodo di storicizzazione dei documenti.
        \end{itemize}
    \end{itemize}




\subsection{ConcealDocuments}
\subsubsection{Diagramma delle classi}
\begin{figure}[H]
    \centering        
    \includegraphics[width=16.5cm]{img/ConcealDocs.png}
    \caption{Diagramma delle classi della componente ConcealDocuments}
\end{figure}


\subsubsection{Lista delle sottocomponenti}

\subsubsubsection{ConcealDocumentsController}
\label{ConcealDocumentsControllerDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{useCase: ConcealDocumentsUseCase}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{concealDocuments(documentIds:List<string>):}\\ \code{List<DocumentOperationResponse>}\\
        Metodo che si occupa di trasformare le stringhe di id in DocumentId e inoltrare l'occultamento dei documenti a ConcealDocumentsUseCase;
    \end{itemize}
\end{itemize}


\subsubsubsection{ConcealDocumentsPort}
\label{ConcealDocumentsPortDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{concealDocuments(documentIds:List<DocumentId>):}\\ \code{List<DocumentOperationResponse>}\\
        Metodo astratto per occultare una lista di documenti a partire dal loro DocumentId, dialogando con il vector store. Ritorna una lista di DocumentOperationResponse, che indica l'esito dell'operazione per ogni documento.
    \end{itemize}
\end{itemize}

\subsubsubsection{ConcealDocumentsService}
\label{ConcealDocumentsServiceDettaglio}
\begin{itemize}
    \item \textbf{Implementa}: ConcealDocumentsUseCase;
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{outPort: ConcealDocumentsPort}.  
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{concealDocuments(documentIds:List<DocumentId>):}\\ \code{List<DocumentOperationResponse>}\\
        Implementazione del metodo astratto di ConcealDocumentsUseCase per occultare una lista di documenti a partire dal loro DocumentId. Ritorna una lista di DocumentOperationResponse, che indica l'esito dell'operazione per ogni documento.
    \end{itemize}
\end{itemize}

\subsubsubsection{ConcealDocumentsUseCase}
\label{ConcealDocumentsUseCaseDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{concealDocuments(documentIds:List<DocumentId>):}\\ \code{List<DocumentOperationResponse>}\\
        Metodo astratto per occultare una lista di documenti a partire dal loro DocumentId. Ritorna una lista di DocumentOperationResponse, che indica l'esito dell'operazione per ogni documento.
    \end{itemize}
\end{itemize}


\subsubsubsection{ConcealDocumentsVectorStore}
\label{ConcealDocumentsVectorStoreDettaglio}
\begin{itemize}
    \item \textbf{Implementa}: ConcealDocumentsPort;
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{vectorStoreManager: VectorStoreManager}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{concealDocuments(documentIds:List<DocumentId>):}\\ \code{List<DocumentOperationResponse>}\\
        Implementazione del metodo astratto di ConcealDocumentsPort per occultare una lista di documenti a partire dal loro DocumentId, dialogando con il vector store. Ritorna una lista di DocumentOperationResponse, che indica l'esito dell'operazione per ogni documento.
    \end{itemize}
\end{itemize}

\subsubsubsection{DocumentId}
\label{DocumentIdDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{id: string}.
    \end{itemize}
\end{itemize}

\subsubsubsection{DocumentOperationResponse}
\label{DocumentOperationResponseDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{documentId: DocumentId};
        \item \code{message: string};
        \item \code{status: boolean}.
    \end{itemize}
\end{itemize}

\subsubsubsection{VectorStoreChromaDBManager}
\label{VectorStoreChromaDBManagerDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{chroma: chromadb.PersistentClient}; 
        \item \code{collection: chromadbCollection}.
    \end{itemize}
    \item \textbf{Implementa}: VectorStoreManager;
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{concealDocuments(documentsId:List<string>):}\\ \code{List<VectorStoreDocumentOperationResponse>}\\
        Implementazione del metodo astratto di VectorStoreManager per occultare in ChromaDB gli embeddings di una lista di documenti a partire da una lista di stringhe che rappresentano i documentIds dei documenti, ritornando una lista di VectorStoreDocumentOperationResponse;

        \item \code{deleteDocumentsEmbeddings(documentsIds:List<string>):}\\ \code{List<VectorStoreDocumentOperationResponse>}\\
        Implementazione del metodo astratto di VectorStoreManager per eliminare da ChromaDB gli embeddings di una lista di documenti a partire da una lista di stringhe che rappresentano i documentIds dei documenti, ritornando una lista di VectorStoreDocumentOperationResponse;

        \item \code{enableDocuments(documentsId:List<string>):}\\ \code{List<VectorStoreDocumentOperationResponse>}\\
        Implementazione del metodo astratto di VectorStoreManager per abilitare in ChromaDB gli embeddings di una lista di documenti a partire da una lista di stringhe che rappresentano i documentIds dei documenti, ritornando una lista di VectorStoreDocumentOperationResponse;

        \item \code{getDocumentsStatus(documentIds:List<string>):}\\ \code{List<VectorStoreDocumentStatusResponse>}\\
        Implementazione del metodo astratto di VectorStoreManager per ottenere da ChromaDB gli status di una lista di documenti dai loro metadati a partire da una lista di stringhe che rappresentano i documentIds dei documenti, ritornandoli in una lista di VectorStoreDocumentStatusResponse;      

        \item \code{uploadEmbeddings(documentsIds:List<string>, documentsChunks:}\\ 
        \code{List<List<LangchainCoreDocument>>, documentEmbeddings:}\\ 
        \code{List<List<List<float>>>): List<VectorStoreDocumentOperationResponse>}\\ 
        Implementazione del metodo astratto di VectorStoreManager per effettuare in ChromaDB l'upload degli embeddings di un documento. Ritorna un VectorStoreDocumentOperationResponse;
        \item \code{getRetriever(embeddingModel:LangchainEmbeddingModel): langchain.BaseRetriever}\\
        Implementazione del metodo astratto di VectorStoreManager per ottenere un langchain.BaseRetriever da un vector store ChromaDB.
    \end{itemize}
\end{itemize}

\subsubsubsection{VectorStoreDocumentOperationResponse}
\label{VectorStoreDocumentOperationResponseDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{documentId: string};
        \item \code{message: string};
        \item \code{status: boolean}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
       
       \item \code{toDocumentOperationResponse(): DocumentOperationResponse}\\
       Metodo che crea e ritorna un DocumentOperationResponse.
    \end{itemize}
\end{itemize}

\subsubsubsection{VectorStoreManager}
\label{VectorStoreManagerDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{concealDocuments(documentsId:List<string>):}\\ \code{List<VectorStoreDocumentOperationResponse>}\\
        Metodo astratto per occultare gli embeddings di una lista di documenti a partire da una lista di stringhe che rappresentano i documentIds dei documenti, ritornando una lista di VectorStoreDocumentOperationResponse;

        \item \code{deleteDocumentsEmbeddings(documentsIds:List<string>):}\\ \code{List<VectorStoreDocumentOperationResponse>}\\
        Metodo astratto per eliminare gli embeddings di una lista di documenti a partire da una lista di stringhe che rappresentano i documentIds dei documenti, ritornando una lista di VectorStoreDocumentOperationResponse;

        \item \code{enableDocuments(documentsId:List<string>):}\\ \code{List<VectorStoreDocumentOperationResponse>}\\
        Metodo astratto per abilitare gli embeddings di una lista di documenti a partire da una lista di stringhe che rappresentano i documentIds dei documenti, ritornando una lista di VectorStoreDocumentOperationResponse;

        \item \code{getDocumentsStatus(documentIds:List<string>):}\\ \code{List<VectorStoreDocumentStatusResponse>}\\
        Metodo astratto per ottenere gli status di una lista di documenti dai loro metadati a partire da una lista di stringhe che rappresentano i documentIds dei documenti, ritornandoli in una lista di VectorStoreDocumentStatusResponse;

        \item \code{uploadEmbeddings(documentsIds:List<string>, documentsChunks:}\\ 
        \code{List<List<LangchainCoreDocument>>,documentEmbeddings:}\\ 
        \code{List<List<List<float>>>):List<VectorStoreDocumentOperationResponse>}\\ 
        Metodo astratto per effettuare l'upload degli embeddings di un documento. Ritorna un VectorStoreDocumentOperationResponse;
      
        \item \code{getRetriever(embeddingModel:LangchainEmbeddingModel): langchain.BaseRetriever}\\
        Metodo astratto per ottenere un langchain.BaseRetriever.
    \end{itemize}
\end{itemize}

\subsubsubsection{VectorStorePineconeManager}
\label{VectorStorePineconeManagerDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{dimension: int};
        \item \code{index: string};
        \item \code{pinecone: pinecone.Pinecone}.
        
    \end{itemize}
    \item \textbf{Implementa}: VectorStoreManager;
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{concealDocuments(documentsId:List<string>):}\\ \code{List<VectorStoreDocumentOperationResponse>}\\
        Implementazione del metodo astratto di VectorStoreManager per occultare in Pinecone gli embeddings di una lista di documenti a partire da una lista di stringhe che rappresentano i documentIds dei documenti, ritornando una lista di VectorStoreDocumentOperationResponse;

        \item \code{deleteDocumentsEmbeddings(documentsIds:List<string>):}\\ \code{List<VectorStoreDocumentOperationResponse>}\\
        Implementazione del metodo astratto di VectorStoreManager per eliminare da Pinecone gli embeddings di una lista di documenti a partire da una lista di stringhe che rappresentano i documentIds dei documenti, ritornando una lista di VectorStoreDocumentOperationResponse;

        \item \code{enableDocuments(documentsId:List<string>):}\\ \code{List<VectorStoreDocumentOperationResponse>}\\
        Implementazione del metodo astratto di VectorStoreManager per abilitare in Pinecone gli embeddings di una lista di documenti a partire da una lista di stringhe che rappresentano i documentIds dei documenti, ritornando una lista di VectorStoreDocumentOperationResponse;

        \item \code{getDocumentsStatus(documentIds:List<string>):}\\ \code{List<VectorStoreDocumentStatusResponse>}\\
        Implementazione del metodo astratto di VectorStoreManager per ottenere da Pinecone gli status di una lista di documenti dai loro metadati a partire da una lista di stringhe che rappresentano i documentIds dei documenti, ritornandoli in una lista di VectorStoreDocumentStatusResponse;

        \item \code{uploadEmbeddings(documentsIds:List<string>, documentsChunks:}\\ 
        \code{List<List<LangchainCoreDocument>>,documentEmbeddings:}\\ 
        \code{List<List<List<float>>>):List<VectorStoreDocumentOperationResponse>}\\ 
        Implementazione del metodo astratto di VectorStoreManager per effettuare in Pinecone l'upload degli embeddings di un documento. Ritorna un VectorStoreDocumentOperationResponse;

        \item \code{getRetriever(embeddingModel:LangchainEmbeddingModel): langchain.BaseRetriever}\\
        Implementazione del metodo astratto di VectorStoreManager per ottenere un langchain.BaseRetriever da un vector store Pinecone.
    \end{itemize}
\end{itemize}



%ConfigurationManager
\subsection{ConfigurationManager}
\subsubsection{Diagramma delle classi}

\begin{figure}[H]
    \centering        
    \includegraphics[width=16.5cm]{img/ConfigurationManager.png}
    \caption{Diagramma delle classi della componente ConfigurationManager}
\end{figure}


\subsubsection{Lista delle sottocomponenti}


\subsubsubsection{ConfigurationManager}
\label{ConfigurationManagerDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{ORM: PostgresConfigurationORM}. 
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{getAskChatbotPort(): AskChatbotPort}\\ 
        Metodo per ottenere la porta in uscita della componente AskChatbot;

        \item \code{getConcealDocumentsPort(): ConcealDocumentsPort}\\ 
        Metodo per ottenere la porta in uscita della componente ConcealDocuments;

        \item \code{getDeleteDocumentsPort(): DeleteDocumentsPort}\\ 
        Metodo per ottenere una delle porte in uscita della componente DeleteDocuments;

        \item \code{getDeleteEmbeddingsPort(): DeleteEmbeddingsPort}\\ 
        Metodo per ottenere una delle porte in uscita della componente DeleteDocuments;

        \item \code{getDocumentsContentPort(): GetDocumentsContentPort}\\ 
        Metodo per ottenere la porta in uscita delle componenti EmbedDocuments e GetDocumentContent;

        \item \code{getDocumentsUploaderPort(): DocumentsUploaderPort}\\ 
        Metodo per ottenere la porta in uscita della componente UploadDocuments;

        \item \code{getEmbeddingsUploaderPort(): EmbeddingsUploaderPort}
        Metodo per ottenere la porta in uscita della componente EmbedDocuments e UploadDocuments;

        \item \code{getEnableDocumentsPort(): EnableDocumentsPort}\\
        Metodo per ottenere la porta in uscita della componente EnableDocuments;

        \item \code{getGetDocumentsMetadataPort(): GetDocumentsMetadataPort}\\ 
        Metodo per ottenere una delle porte in uscita della componente GetDocuments;

        \item \code{getGetDocumentsStatusPort(): GetDocumentsStatusPort}\\        
        Metodo per ottenere una delle porte in uscita delle componenti EmbedDocuments, GetDocuments e GetDocumentContent.

        

    \end{itemize}
\end{itemize}


\subsubsubsection{PostgresConfiguration}
\label{PostgresConfigurationDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{documentStore: PostgresDocumentStoreConfiguration};
        \item \code{embeddingModel: PostgresEmbeddingModelConfiguration};
        \item \code{id: int};
        \item \code{LLMModel: PostgresLLMModelConfiguration};
        \item \code{vectorStore: PostgresVectorStoreConfiguration}. 
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{toConfiguration(): Configuration}\\
        Metodo che ricava un oggetto Configuration dal PostgresConfiguration
    \end{itemize}
\end{itemize}

\subsubsubsection{PostgresConfigurationORM}
Vedi \vedi{PostgresConfigurationORMDettaglio};


\subsubsubsection{PostgresDocumentStoreConfiguration}
\label{PostgresDocumentStoreConfigurationDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{costIndicator: string};
        \item \code{description: string};
        \item \code{name: PostgresDocumentStoreType};
        \item \code{organization: string};
        \item \code{type: string}.  
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{toDocumentStoreConfiguration(): DocumentStoreConfiguration}\\ 
        Metodo che permette di ottenere un DocumentStoreConfiguration a partire dal PostgresDocumentStoreConfiguration.
    \end{itemize}
\end{itemize}

\subsubsubsection{PostgresDocumentStoreType(Enum)}
\label{PostgresDocumentStoreTypeDettaglio}
\begin{itemize}
    \item \textbf{Valori}:
    \begin{itemize}
        \item \code{AWS}. 
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{toDocumentStoreType(): DocumentStoreType}\\ 
        Metodo che permette di ottenere un DocumentStoreType a partire dal PostgresDocumentStoreType(Enum).
    \end{itemize}
\end{itemize}



\subsubsubsection{PostgresEmbeddingModelConfiguration}
\label{PostgresEmbeddingModelConfigurationDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{costIndicator: string};
        \item \code{description: string};
        \item \code{name: PostgresEmbeddingModelType};
        \item \code{organization: string};
        \item \code{type: string}.  
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{toEmbeddingModelConfiguration(): EmbeddingModelConfiguration}\\ 
        Metodo che permette di ottenere un EmbeddingModelConfiguration a partire dal PostgresEmbeddingModelConfiguration.
    \end{itemize}
\end{itemize}

\subsubsubsection{PostgresEmbeddingModelType(Enum)}
\label{PostgresEmbeddingModelTypeDettaglio}
\begin{itemize}
    \item \textbf{Valori}:
    \begin{itemize}
        \item \code{HUGGINGFACE};
        \item \code{OPENAI}. 
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{toEmbeddingModelType(): EmbeddingModelType}\\ 
        Metodo che permette di ottenere un EmbeddingModelType a partire dal PostgresEmbeddingModelType(Enum).
    \end{itemize}
\end{itemize}



\subsubsubsection{PostgresLLMModelConfiguration}
\label{PostgresLLMModelConfigurationDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{costIndicator: string};
        \item \code{description: string};
        \item \code{name: PostgresLLMModelType};
        \item \code{organization: string};
        \item \code{type: string}.  
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{toLLMModelConfiguration(): LLMModelConfiguration}\\ 
        Metodo che permette di ottenere un LLMModelConfiguration a partire dal PostgresLLMModelConfiguration.
    \end{itemize}
\end{itemize}

\subsubsubsection{PostgresLLMModelType(Enum)}
\label{PostgresLLMModelTypeDettaglio}
\begin{itemize}
    \item \textbf{Valori}:
    \begin{itemize}
        \item \code{HUGGINGFACE};
        \item \code{OPENAI}. 
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{toLLMModelType(): LLMModelType}\\ 
        Metodo che permette di ottenere un LLMModelType a partire dal PostgresLLMModelType(Enum).
    \end{itemize}
\end{itemize}


\subsubsubsection{PostgresVectorStoreConfiguration}
\label{PostgresVectorStoreConfigurationDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{costIndicator: string};
        \item \code{description: string};
        \item \code{name: PostgresVectorStoreType};
        \item \code{organization: string};
        \item \code{type: string}.  
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{toVectorStoreConfiguration(): VectorStoreConfiguration}\\ 
        Metodo che permette di ottenere un VectorStoreConfiguration a partire dal PostgresVectorStoreConfiguration.
    \end{itemize}
\end{itemize}

\subsubsubsection{PostgresVectorStoreType(Enum)}
\label{PostgresVectorStoreTypeDettaglio}
\begin{itemize}
    \item \textbf{Valori}:
    \begin{itemize}
        \item \code{CHROMA DB};
        \item \code{PINECONE}. 
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{toVectorStoreType(): VectorStoreType}\\ 
        Metodo che permette di ottenere un VectorStoreType a partire dal PostgresVectorStoreType(Enum).
    \end{itemize}
\end{itemize}





\subsection{DeleteChats}

\subsubsection{Diagramma delle classi}
\begin{figure}[H]
    \centering        
    \includegraphics[width=16.5cm]{img/DeleteChat.png}
    \caption{Diagramma delle classi della componente DeleteChats}
\end{figure}

\subsubsection{Lista delle sottocomponenti}

\subsubsubsection{ChatId}
Vedi \vedi{ChatIdDettaglio}.

\subsubsubsection{ChatOperationResponse}
Vedi \vedi{ChatOperationResponseDettaglio};


\subsubsubsection{DeleteChatsController}
\label{DeleteChatsControllerDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{useCase: DeleteChatsUseCase}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{deleteChats(chatIdsList:List<int>):}\\ \code {List<ChatOperationResponse>}\\
        Metodo che elimina tramite useCase una lista di chat identificate da una lista di interi, ritornando una lista di ChatOperationResponse.
    
    \end{itemize}
\end{itemize}


\subsubsubsection{DeleteChatsPort}
\label{DeleteChatsPortDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{deleteChats(chatIdsList:List<ChatId>):}\\ \code{ List<ChatOperationResponse>}\\
        Metodo astratto per per eliminare una lista di chat identificate da una lista di ChatId, ritornando una lista di ChatOperationResponse.
    \end{itemize}
\end{itemize}


\subsubsubsection{DeleteChatsPostgres}
\label{DeleteChatsPostgresDettaglio}
\begin{itemize}
    \item \textbf{Implementa}: DeleteChatsPort;
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{postgresORM: PostgresChatORM}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{deleteChats(chatIdsList:List<ChatId>):}\\ \code{ List<ChatOperationResponse>}\\
        Implementazione del metodo astratto di DeleteChatsPort per eliminare una lista di chat identificate da una lista di ChatId, ritornando una lista di ChatOperationResponse.
    \end{itemize}
\end{itemize}

\subsubsubsection{DeleteChatsService}
\label{DeleteChatsServiceDettaglio}
\begin{itemize}
    \item \textbf{Implementa}: DeleteChatsUseCase;
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{outPort: DeleteChatsPort}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{deleteChats(chatIdsList:List<ChatId>):}\\ \code{ List<ChatOperationResponse>}\\
        Implementazione del metodo astratto di DeleteChatsUseCase per eliminare tramite outPort una lista di chat identificate da una lista di ChatId, ritornando una lista di ChatOperationResponse.
    \end{itemize}
\end{itemize}

\subsubsubsection{DeleteChatsUseCase}
\label{DeleteChatsUseCaseDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{deleteChats(chatIdsList:List<ChatId>):}\\ \code{List<ChatOperationResponse>}\\
        Metodo astratto per eliminare una lista di chat identificate da una lista di ChatId, ritornando una lista di ChatOperationResponse.
    \end{itemize}
\end{itemize}



\subsubsubsection{PostgresChatOperationResponse}
Vedi \vedi{PostgresChatOperationResponseDettaglio};




\subsubsubsection{PostgresChatORM}
Vedi \vedi{PostgresChatORMDettaglio}.





%DELETEDOCS
\subsection{DeleteDocuments}
\subsubsection{Diagramma delle classi}

\begin{figure}[H]
    \centering        
    \rotatebox{90}{\includegraphics[width=1.45\textwidth]{img/DeleteDocs.png}}
    \caption{Diagramma delle classi della componente DeleteDocuments}
\end{figure}


\begin{comment}
    

\begin{sidewaysfigure}
    \includegraphics[scale=0.4]{img/DeleteDocs.png}
\caption{Diagramma delle classi della componente DeleteDocuments}
\end{sidewaysfigure}

\end{comment}
\subsubsection{Lista delle sottocomponenti}


\subsubsubsection{AWSDocumentOperationResponse}
\label{AWSDocumentOperationResponseDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{documentId: string};
        \item \code{message: string};
        \item \code{status: boolean}.
    \end{itemize}
    \item \textbf{Metodi}:
    \item \begin{itemize}
        \item \item \code{toDocumentOperationResponse(): DocumentOperationResponse:}\\
        Metodo per ottenere un oggetto DocumentOperationResponse dal AWSDocumentOperationResponse.
    \end{itemize}
\end{itemize}

\subsubsubsection{AWSS3Manager}
\label{AWSS3ManagerDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{awsBucketName: string};
        \item \code{\textit{boto3\pg}: boto3.session.Session}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{deleteDocuments(documentsId:List<string>):}\\ \code{ List<AWSDocumentOperationResponse>}\\
        Metodo per eliminare un documento a partire da una stringa corrispondente al documentId del documento tramite boto3, ritornando un AWSDocumentOperationResponse;
        \item \code{getDocumentById(documentId:string): AWSDocument}\\
        Metodo per ottenere un AWSDocument a partire da una stringa corrispondente al documentId del documento tramite boto3;
        \item \code{getDocumentsMetadata(documentFilter:string): List<AWSDocumentMetadata>}\\
        Metodo per ottenere una lista di AWSDocumentMetaData a partire da una eventuale filtro stringa tramite boto3; 
        \item \code{uploadDocuments(documents:List<AWSDocument>, forceUpload:boolean):}\\ \code{ List<AWSDocumentOperationResponse>} \\ 
        Metodo per caricare una lista di AWSDocument tramite boto3, con flag forceUpload per forzare il caricamento di documenti già presenti nel sistema attraverso sostituzione, ritornando una lista di AWSDocumentOperationResponse.
    \end{itemize}
\end{itemize}


\subsubsubsection{DeleteDocuments}
\label{DeleteDocumentsDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{outPort: DeleteDocumentsPort}. 
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{deleteDocuments(documentsIds:List<DocumentId>):}\\ \code{List<DocumentOperationResponse>}\\
        Metodo per eliminare una lista di documenti tramite outPort dal sistema di archiviazione a partire dai loro id.
    \end{itemize}
\end{itemize}

\subsubsubsection{DeleteDocumentsAWSS3}
\label{DeleteDocumentsAWSS3Dettaglio}
\begin{itemize}
    \item \textbf{Implementa}: DeleteDocumentsPort;
    \item \textbf{Attributi}:
    \begin{itemize}
        \item awsS3Manager: AWSS3Manager.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{deleteDocuments(documentIds:List<DocumentId>):}\\ \code{List<DocumentOperationResponse>}\\
        Implementazione del metodo astratto di DeleteDocumentsPort per eliminare una lista di documenti da AWS S3 a partire dai loro id.
    \end{itemize}
\end{itemize}


\subsubsubsection{DeleteDocumentsController}
\label{DeleteDocumentsControllerDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{useCase: DeleteDocumentsUseCase}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{deleteDocuments(documentIds:List<string>):}\\ \code{List<DocumentOperationResponse>}\\
        Metodo che si occupa di trasformare la lista di stringhe in lista di DocumentId e inoltrare la richiesta di eliminazione dei documenti a DeleteDocumentsUseCase.
    \end{itemize}
\end{itemize}

\subsubsubsection{DeleteDocumentsEmbeddings}
\label{DeleteDocumentsEmbeddingsDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{outPort: DeleteEmbeddingsPort}. 
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{deleteDocumentsEmbeddings(documentIds:List<DocumentId>):}\\ \code{List<DocumentOperationResponse>}\\
        Metodo per eliminare gli embeddings di una lista di documenti, a partire dai loro id, tramite outPort dal vector store.
    \end{itemize}
\end{itemize}

\subsubsubsection{DeleteDocumentsPort}
\label{DeleteDocumentsPortDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{deleteDocuments(documentIds:List<DocumentId>):}\\ \code{List<DocumentOperationResponse>}\\
        Metodo astratto per eliminare una lista di documenti dal sistema di embeddings a partire dai loro id.
    \end{itemize}
\end{itemize}

\subsubsubsection{DeleteDocumentsService}
\label{DeleteDocumentsServiceDettaglio}
\begin{itemize}
    \item \textbf{Implementa}: DocumentsUseCase;
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{documentsDeleter: DeleteDocuments};
        \item \code{deleteDocumentsEmbeddings: DeleteDocumentsEmbeddings}. 
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{deleteDocuments(documentsIds:List<DocumentId>):}\\ \code{List<DocumentOperationResponse>}\\
        Implementazione del metodo astratto di DeleteDocumentsUseCase per eliminare una lista di documenti e i loro embeddings a partire dai loro id.
    \end{itemize}
\end{itemize}


\subsubsubsection{DeleteDocumentsUseCase}
\label{DeleteDocumentsUseCaseDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{deleteDocuments(documentsIds:List<DocumentId>):}\\ \code{List<DocumentOperationResponse>}\\
        Metodo astratto per eliminare una lista di documenti a partire dai loro id.
    \end{itemize}
\end{itemize}


\subsubsubsection{DeleteEmbeddingsPort}
\label{DeleteEmbeddingsPortDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{deleteDocumentsEmbeddings(documentIds:List<DocumentId>):}\\ \code{List<DocumentOperationResponse>}\\
        Metodo astratto per eliminare gli embeddings di una lista di documenti dal vector store a partire dai loro id.
    \end{itemize}
\end{itemize}

\subsubsubsection{DeleteEmbeddingsVectorStore}
\label{DeleteEmbeddingsVectorStoreDettaglio}
\begin{itemize}
    \item \textbf{Implementa}: DeleteEmbeddingsPort;
    \item \textbf{Attributi}:
    \begin{itemize}
        \item vectorStoreManager: VectorStoreManager.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{deleteDocumentsEmbeddings(documentIds:List<DocumentId>):}\\ \code{List<DocumentOperationResponse>}\\
        Implementazione del metodo astratto di DeleteEmbeddingsPort per eliminare gli embeddings di una lista di documenti dal vector store a partire dai loro id.
    \end{itemize}
\end{itemize}

\subsubsubsection{DocumentId}
Vedi \vedi{DocumentIdDettaglio}.

\subsubsubsection{DocumentOperationResponse}
Vedi \vedi{DocumentOperationResponseDettaglio}.

\subsubsubsection{VectorStoreChromaDBManager}
Vedi \vedi{VectorStoreChromaDBManagerDettaglio}.

\subsubsubsection{VectorStoreDocumentOperationResponse}
Vedi \vedi{VectorStoreDocumentOperationResponseDettaglio}.


\subsubsubsection{VectorStoreManager}
Vedi \vedi{VectorStoreManagerDettaglio}.

\subsubsubsection{VectorStorePineconeManager}
Vedi \vedi{VectorStorePineconeManagerDettaglio}.



\subsection{EmbedDocuments}
\subsubsection{Diagramma delle classi}


\begin{figure}[H]
    \centering        
    \rotatebox{90}{\includegraphics[keepaspectratio, height=16cm, width=1.3\textwidth]{img/EmbedDocs0.png}}
    \caption{Diagramma delle classi componente EmbedDocuments (continua nei prossimi diagrammi)}
\end{figure}



\begin{figure}[H]
    \centering        
    \includegraphics[width=14.5cm]{img/EmbedDocs1.png}
    \caption{Diagramma delle classi componente EmbedDocuments (continua nel prossimo diagramma)}
\end{figure}




\begin{figure}[H]
    \centering        
    \includegraphics[width=15.5cm]{img/EmbedDocs2.png}
    \caption{Diagramma delle classi componente EmbedDocuments (continua nel prossimo diagramma)}
\end{figure}


\begin{figure}[H]
    \centering        
    \rotatebox{90}{\includegraphics[keepaspectratio, height=16.3cm, width=1.55\textwidth]{img/EmbedDocs3.png}}
    \caption{Diagramma delle classi componente EmbedDocuments}
\end{figure}





\begin{comment}
    



\begin{figure}[H]
    \centering        
    \rotatebox{90}{\includegraphics[width=1.45\textwidth]{img/UploadDocs2.png}}
    \caption{Diagramma delle classi componente UploadDocuments}
\end{figure}



\begin{figure}[H]
    \centering        
    \includegraphics[width=16cm]{img/E}
    \caption{Diagramma 1 delle classi della componente EmbedDocuments}
\end{figure}

\begin{figure}[H]
    \centering        
    \includegraphics[scale=0.5]{img/EmbedDocs2.png}
    \caption{Diagramma 2 delle classi della componente EmbedDocuments}
\end{figure}


\begin{figure}[H]
    \centering        
    \includegraphics[width=16.5cm]{img/EmbedDocs3.png}
    \caption{Diagramma 3 delle classi della componente EmbedDocuments}
\end{figure}

\begin{figure}[H]
    \centering        
    \includegraphics[width=16.5cm]{img/EmbedDocs4.png}
    \caption{Diagramma 4 delle classi della componente EmbedDocuments}
\end{figure}
\end{comment}


\subsubsection{Lista delle sottocomponenti}

\subsubsubsection{AWSDocument}
\label{AWSDocumentDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{content: bytes};
        \item \code{id: string};
        \item \code{size: float};
        \item \code{uploadTime: timestamp}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{toPlainDocument(): PlainDocument}\\
        Metodo che ritorna un PlainDocument.
    \end{itemize}
\end{itemize}   

\subsubsubsection{AWSS3Manager}
Vedi \vedi{AWSS3ManagerDettaglio}.

\subsubsubsection{Chunkerizer}
\label{ChunkerizerDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{extractText(document:Document):}\\ \code{ List<langchain.Document>}\\
        Metodo per suddividere in chunks una lista di langchain.Document, ritornandoli attraverso una lista di langchain.Document.
        
        \item \code{getTextExtractorFrom(documentType:string):}\\ \code{ TextExtractor}\\
        Metodo che ritorna il tipo di TextExtractor da usare.
    \end{itemize}  
\end{itemize}

\subsubsubsection{DocumentId}
Vedi \vedi {DocumentIdDettaglio}.

\subsubsubsection{DocumentOperationResponse}
Vedi \vedi{DocumentOperationResponseDettaglio}.

\subsubsubsection{DocumentStatus}
\label{DocumentStatusDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{status: Status}.
    \end{itemize}
\end{itemize}

\subsubsubsection{DOCXTextExtractor}
\label{DOCXTextExtractorDettaglio}
\begin{itemize}
    \item \textbf{Implementa}: TextExtractor;
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{extractText(document:DocumentContent): List<langchain.Document>}\\
        Implementazione del metodo astratto di TextExtractor per estrarre il testo da un DOCX sotto forma di langchain.Document a partire da un DocumentContent.
    \end{itemize}
\end{itemize}

\subsubsubsection{EmbeddingsCreator}
\label{EmbeddingsCreatorDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{langchainEmbeddingModel: LangchainEmbeddingModel}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{embedDocument(documents:List<langchain.Document>): List<List<float>>}\\
        Metodo per generare una lista di embeddings a partire da una lista di langchain.Document: per ogni chunk di langchain.Document presente nella lista viene generata una lista di float che rappresenta gli embeddings corrispondenti.
    \end{itemize}
\end{itemize}

\subsubsubsection{EmbeddingsUploader}
\label{EmbeddingsUploaderDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{outPort: EmbeddingsUploaderPort}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{uploadEmbeddings(documents:List<Document>):}\\ \code{List<DocumentOperationResponse>}\\
        Metodo per effettuare la generazione e il caricamento degli embeddings di una lista di Document tramite outPort in un vector store, ritornando infine una lista di DocumentOperationResponse.
    \end{itemize}
\end{itemize}

\subsubsubsection{EmbeddingsUploaderFacadeLangchain}
\label{EmbeddingsUploaderFacadeLangchainDettaglio}
\begin{itemize}
    \item \textbf{Implementa}: EmbeddingsUploaderPort;
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{chunkerizer: Chunkerizer};
        \item \code{embeddingsCreator: EmbeddingsCreator};
        \item \code{embeddingsUploaderVectorStore: EmbeddingsUploaderVectorStore}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{uploadEmbeddings(documents:List<Document>):}\\ \code{List<DocumentOperationResponse>}\\
        Implementazione del metodo astratto di EmbeddingsUploaderPort per la generazione e il caricamento di embeddings di una lista di Document nel vector store tramite l'utilizzo di un pattern facade, ritornando infine una lista di DocumentOperationResponse.\\
        Le operazioni all'interno della facade vengono svolte nel seguente ordine:
        \begin{enumerate}
            \item Estrazione del testo dai documenti tramite documentToText;
            \item Suddivisione in chunks del testo estratto dai documenti tramite chunkerizer;
            \item Generazione degli embeddings a partire dai chunks tramite embeddingsCreator;
            \item Caricamento degli embeddings creati nel vector store tramite embeddingsUploaderVectorStore.
        \end{enumerate}
    \end{itemize}
\end{itemize}

\subsubsubsection{EmbeddingsUploaderPort}
\label{EmbeddingsUploaderPortDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{uploadEmbeddings(documents:List<Document>):}\\ \code{List<DocumentOperationResponse>}\\
        Metodo astratto per effettuare la generazione e il caricamento degli embeddings di una lista di Document in un vector store.
    \end{itemize}
\end{itemize}

\subsubsubsection{EmbeddingsUploaderVectorStore}
\label{EmbeddingsUploaderVectorStoreDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{vectorStoreManager: VectorStoreManager}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{uploadEmbeddings(documents:List<LangchainDocument>):}\\\code{List<VectorStoreDocumentOperationResponse>}\\
        Metodo per effettuare l'upload di una lista di LangchainDocument nel vector store tramite vectorStoreManager, ritornando una lista di VectorStoreDocumentOperationResponse.
    \end{itemize}
\end{itemize}


\subsubsubsection{EmbedDocumentsController}
\label{EmbedDocumentsControllerDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{useCase: EmbedDocumentsUseCase}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{embedDocuments(documentsIds:List<DocumentIds>):}\\ \code{List<DocumentOperationResponse>}\\
        Metodo che si occupa di trasformare le stringhe di id in DocumentId e inoltrare la generazione degli embeddings dei documenti a EmbedDocumentsUseCase.
        %\item \code{toDocument(document:NewDocument): Document}\\
        %Metodo che trasforma un NewDocument della presentation logic in un Document della business logic.
    \end{itemize}
\end{itemize}


\subsubsubsection{EmbedDocumentsService}
\label{EmbedDocumentsServiceDettaglio}
\begin{itemize}
    \item \textbf{Implementa}: EmbedDocumentsUseCase;
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{embeddingsUploader: EmbeddingsUploader};
        \item \code{getDocumentsContent: GetDocumentsContent};
        \item \code{getDocumentsStatus: GetDocumentsStatus}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{embedDocuments(documentsIds:List<DocumentIds>):}\\ \code{List<DocumentOperationResponse>}\\
        Implementazione del metodo astratto di EmbedDocumentsUseCase, per il recupero dei documenti e il loro contenuto attraverso getDocuments, e la generazione degli embeddings della lista dei documenti recuperati tramite embeddingsUploader. Ritorna una lista di DocumentOperationResponse, indicando per ogni documento l'esito della generazione degli embeddings.
    \end{itemize}
\end{itemize}



\subsubsubsection{EmbedDocumentsUseCase}
\label{EmbedDocumentsUseCaseDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{embedDocuments(documentsIds:List<DocumentIds>):}\\ \code{List<DocumentOperationResponse>}\\
        Metodo astratto per generare gli embeddings di una lista di documenti a partire dal loro DocumentId. Ritorna una lista di DocumentOperationResponse, che indica l'esito dell'operazione per ogni documento.
    \end{itemize}
\end{itemize}


\subsubsubsection{GetDocumentsContent}
\label{GetDocumentsContentDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{outPort: GetDocumentsContentPort}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{getDocumentsContent(documentsIds:List<DocumentId>):}\\ \code{List<PlainDocument>}\\
        Metodo per recuperare il contenuto di una lista di Document tramite outPort dal sistema di archiviazione documenti a partire da una lista di id.
    \end{itemize}
\end{itemize}

\subsubsubsection{GetDocumentsContentAWSS3}
\label{GetDocumentsContentAWSS3Dettaglio}
\begin{itemize}
    \item \textbf{Implementa}: DocumentsContentPort;
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{awsS3Manager: AWSS3Manager}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{getDocumentsContent(documentsIds:List<DocumentId>): List<PlainDocument>}\\
        Implementazione del metodo astratto di GetDocumentsContentPort per recuperare il contenuto di una lista di documenti dal sistema di archiviazione a partire dal loro id;
        \item \code{toPlainDocumentFrom(document:AWSDocument): PlainDocument}\\
        Metodo che trasforma un AWSDocument in un Document della business logic.
    \end{itemize}
\end{itemize}



\subsubsubsection{GetDocumentsContentPort}
\label{GetDocumentsContentPortDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{getDocumentsContent(documentsIds:List<DocumentId>):}\\ \code{List<PlainDocument>}\\
        Metodo astratto per recuperare il contenuto di una lista di documenti dal sistema di archiviazione a partire dal loro id.
    \end{itemize}
\end{itemize}


\subsubsubsection{GetDocumentsStatus}
\label{GetDocumentsStatusDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{outPort: GetDocumentsStatusPort}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{getDocumentsStatus(documentsIds:List<DocumentId>)}\\ \code{List<DocumentStatus>}\\
        Metodo per recuperare gli status di una lista di documenti tramite outPort dal vector store a partire dai loro id.
    \end{itemize}
\end{itemize}

\subsubsubsection{GetDocumentsStatusPort}
\label{GetDocumentsStatusPortDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{getDocumentsStatus(documentsIds:List<DocumentId>):}\\ \code{List<DocumentStatus>}\\
        Metodo astratto per recuperare gli status di una lista di documenti a partire dal loro id.
    \end{itemize}
\end{itemize}


\subsubsubsection{GetDocumentsStatusVectorStore}
\label{GetDocumentsStatusVectorStoreDettaglio}
\begin{itemize}
    \item \textbf{Implementa}: GetDocumentsStatusPort;
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{vectorStoreManager: VectorStoreManager}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{getDocumentsStatus(documentsIds:List<DocumentId>):}\\ \code{List<DocumentStatus>}\\
        Implementazione del metodo astratto di GetDocumentsStatusVectorStore per recuperare gli status di una lista di documenti a partire dal loro id.
    \end{itemize}
\end{itemize}



\subsubsubsection{HuggingFaceEmbeddingModel}
\label{HuggingFaceEmbeddingModelDettaglio}
\begin{itemize}
    \item \textbf{Implementa}: LangchainEmbeddingModel;
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{embeddingsDimension: int};
        \item \code{model: langchain.Embedding}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{embedDocument(documentChunks:List<string>): List<List<float>>}\\
        Implementazione del metodo astratto di LangchainEmbeddingModel per generare gli embeddings di un insieme di chunks di stringhe tramite un modello di embeddings di HuggingFace: per ogni chunk in lista viene generata una lista di float che rappresenta gli embeddings;
        \item \code{getEmbeddingFunction(): langchain.Embedding}\\
        Implementazione del metodo astratto per ottenere il campo \code{model}.
    \end{itemize}
\end{itemize}


\subsubsubsection{LangchainDocument}
\label{LangchainDocumentDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{documentId: string};
        \item \code{embeddings: List<List<float>>};
        \item \code{text: List<langchain.Document>}.
    \end{itemize}
\end{itemize}

\subsubsubsection{LangchainEmbeddingModel}
\label{LangchainEmbeddingModelDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{embedDocument(documentChunks: List<string>): List<List<float>>}\\
        Metodo astratto per generare gli embeddings di un insieme di chunks sotto forma di lista di stringhe: per ogni chunk in lista viene generata una lista di float che rappresenta gli embeddings;
        \item \code{getEmbeddingFunction(): langchain.Embedding}\\
        Metodo astratto per ottenere il campo \code{model}.
    \end{itemize}
\end{itemize}

\subsubsubsection{OpenAIEmbeddingModel}
\label{OpenAIEmbeddingModelDettaglio}
\begin{itemize}
    \item \textbf{Implementa}: LangchainEmbeddingModel;
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{embeddingsDimension: int};
        \item \code{model: langchain.Embedding}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{embedDocument(documentChunks:List<string>): List<List<float>>}\\
        Implementazione del metodo astratto di LangchainEmbeddingModel per generare gli embeddings di un insieme di chunks di stringhe tramite un modello di embeddings OpenAI: per ogni chunk in lista viene generata una lista di float che rappresenta gli embeddings;
        \item \code{getEmbeddingFunction(): langchain.Embedding}\\
        Implementazione del metodo astratto per ottenere il campo \code{model}.
    \end{itemize}
\end{itemize}

\subsubsubsection{PDFTextExtractor}
\label{PDFTextExtractorDettaglio}
\begin{itemize}
    \item \textbf{Implementa}: TextExtractor;
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{extractText(document:DocumentContent): List<langchain.Document>}\\
        Implementazione del metodo astratto di TextExtractor per estrarre il testo da un PDF sotto forma di langchain.Document a partire da un DocumentContent.
    \end{itemize}
\end{itemize}



\subsubsubsection{Status (Enumeration)}
\label{StatusDettaglio}
\begin{itemize}
    \item \textbf{Valori}:
    \begin{itemize}
        \item \code{Concealed};
        \item \code{Enabled};
        \item \code{Inconsistent};
        \item \code{Not Embedded}.
    \end{itemize}
\end{itemize}

\subsubsubsection{TextExtractor}
\label{TextExtractorDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{extractText(document:DocumentContent): List<langchain.Document>}\\
        Metodo astratto per estrarre il testo sotto forma di langchain.Document a partire da un DocumentContent.
    \end{itemize}
\end{itemize}

\begin{comment}
    Non usata

\subsubsubsection{DocumentToText}
\label{DocumentToTextDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{extractText(document:Document): List<langchain.Document>}\\
        Metodo per estrarre il testo sotto forma di langchain.Document a partire da un Document;
        \item \code{getTextExtractorFrom(documentType:string): TextExtractor}\\
        Metodo per ottenere un TextExtractor a partire dal tipo del documento, indicato sotto forma di stringa.
    \end{itemize}
\end{itemize}
\end{comment}






\subsubsubsection{VectorStoreChromaDBManager}
Vedi \vedi{VectorStoreChromaDBManagerDettaglio}.

\subsubsubsection{VectorStoreDocumentOperationResponse}
Vedi \vedi{VectorStoreDocumentOperationResponseDettaglio}.


\subsubsubsection{VectorStoreDocumentStatusResponse}
\label{VectorStoreDocumentStatusResponseDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{documentStatus: string};
        \item \code{id: string}.
    \end{itemize}
\end{itemize}



\subsubsubsection{VectorStoreManager}
Vedi \vedi{VectorStoreManagerDettaglio}.

\subsubsubsection{VectorStorePineconeManager}
Vedi \vedi{VectorStorePineconeManagerDettaglio}.






\subsection{EnableDocuments}
\subsubsection{Diagramma delle classi}
\begin{figure}[H]
    \centering        
    \includegraphics[width=16.5cm]{img/EnableDocs.png}
    \caption{Diagramma delle classi della componente EnableDocuments}
\end{figure}

\subsubsection{Lista delle sottocomponenti}




\subsubsubsection{DocumentId}
Vedi \vedi{DocumentIdDettaglio}.


\subsubsubsection{DocumentOperationResponse}
Vedi \vedi{DocumentOperationResponseDettaglio}.


\subsubsubsection{EnableDocumentsController}
\label{EnableDocumentsControllerDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{useCase: EnableDocumentsUseCase}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{enableDocuments(documentsIds:List<string>):}\\ \code{List<DocumentOperationResponse>}\\
        Metodo che si occupa di trasformare le stringhe di id in DocumentId e inoltrare la riabilitazione dei documenti a EnableDocumentsUseCase;
    \end{itemize}
\end{itemize}


\subsubsubsection{EnableDocumentsPort}
\label{EnableDocumentsPortDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{enableDocuments(documentsIds:List<DocumentId>):}\\ \code{List<DocumentOperationResponse>}\\
        Metodo astratto per riabilitare una lista di documenti a partire dal loro DocumentId, dialogando con il vector store. Ritorna una lista di DocumentOperationResponse, che indica l'esito dell'operazione per ogni documento.
    \end{itemize}
\end{itemize}

\subsubsubsection{EnableDocumentsService}
\label{EnableDocumentsServiceDettaglio}
\begin{itemize}
    \item \textbf{Implementa}: EnableDocumentsUseCase;
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{outPort: EnableDocumentsPort}.  
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{enableDocuments(documentsIds:List<DocumentId>):}\\ \code{List<DocumentOperationResponse>}\\
        Implementazione del metodo astratto di EnableDocumentsUseCase per riabilitare una lista di documenti a partire dal loro DocumentId. Ritorna una lista di DocumentOperationResponse, che indica l'esito dell'operazione per ogni documento.
    \end{itemize}
\end{itemize}

\subsubsubsection{EnableDocumentsUseCase}
\label{EnableDocumentsUseCaseDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{enableDocuments(documentsIds:List<DocumentId>):}\\ \code{List<DocumentOperationResponse>}\\
        Metodo astratto per riabilitare una lista di documenti a partire dal loro DocumentId. Ritorna una lista di DocumentOperationResponse, che indica l'esito dell'operazione per ogni documento.
    \end{itemize}
\end{itemize}


\subsubsubsection{EnableDocumentsVectorStore}
\label{EnableDocumentsVectorStoreDettaglio}
\begin{itemize}
    \item \textbf{Implementa}: EnableDocumentsPort;
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{vectorStoreManager: VectorStoreManager}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{enableDocuments(documentsIds:List<DocumentId>):}\\ \code{List<DocumentOperationResponse>}\\
        Implementazione del metodo astratto di EnableDocumentsPort per riabilitare una lista di documenti a partire dal loro DocumentId, dialogando con il vector store. Ritorna una lista di DocumentOperationResponse, che indica l'esito dell'operazione per ogni documento.
    \end{itemize}
\end{itemize}

\subsubsubsection{VectorStoreChromaDBManager}
Vedi \vedi{VectorStoreChromaDBManagerDettaglio}.


\subsubsubsection{VectorStoreDocumentOperationResponse}
Vedi \vedi{VectorStoreDocumentOperationResponseDettaglio}.

\subsubsubsection{VectorStoreManager}
Vedi \vedi{VectorStoreManagerDettaglio}.

\subsubsubsection{VectorStorePineconeManager}
Vedi \vedi{VectorStorePineconeManagerDettaglio}.



\subsection{GetChatMessages}
\subsubsection{Diagramma delle classi}

    \begin{figure}[H]
    \centering        
    \includegraphics[width=16.5cm]{img/GetChatMessages.png}
    \caption{Diagramma delle classi della componente GetChatMessages}
\end{figure}
\subsubsection{Lista delle sottocomponenti}




\subsubsubsection{Chat}
\label{ChatDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{id: ChatId};
        \item \code{messages: List<Message>};
        \item \code{title: string}.
    \end{itemize}
\end{itemize}

\subsubsubsection{ChatId}
Vedi \vedi{ChatIdDettaglio}.

\subsubsubsection{GetChatMessagesController}
\label{GetChatMessagesControllerDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{useCase: GetChatMessagesUseCase}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{getChatMessages(chatId:int): Chat}\\
        Metodo che ritorna una Chat tramite useCase a partire da un intero rappresentante l'id della chat. 
    \end{itemize}
\end{itemize}


\subsubsubsection{GetChatMessagesPort}
\label{GetChatMessagesPortDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{getChatMessages(chatId:ChatId): Chat}\\
        Metodo astratto per ottenere una Chat a partire da un ChatId.
    \end{itemize}
\end{itemize}


\subsubsubsection{GetChatMessagesPostgres}
\label{GetChatMessagesPostgresDettaglio}
\begin{itemize}
    \item \textbf{Implementa}: GetChatMessagesPort;
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{postgresChatORM: PostgresChatORM}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{getChatMessages(chatId:ChatId): Chat}\\
        Implementazione del metodo astratto di GetChatMessagesPort per ottenere una Chat a partire da un ChatId.
        
        %\item \code{toChatFrom(in postgresChat:PostgresChat): Chat}\\
        %Metodo che trasforma un oggetto di persistence PostgresChat in un oggetto di business Chat;
        %\item \code{toMessageFrom(in postgresMessage:PostgresMessage): Message}\\
        %Metodo che trasforma un oggetto di persistence PostgresMessage in un oggetto di business Message.
    
    \end{itemize}
\end{itemize}




\subsubsubsection{GetChatMessagesService}
\label{GetChatMessagesServiceDettaglio}
\begin{itemize}
    \item \textbf{Implementa}: GetChatMessagesUseCase;
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{outPort: GetChatMessagesPort}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{getChatMessages(chatId:ChatId): Chat}\\
        Implementazione del metodo astratto di GetChatMessagesUseCase per ottenere una Chat a partire da un ChatId.
    \end{itemize}
\end{itemize}

\subsubsubsection{GetChatMessagesUseCase}
\label{GetChatMessagesUseCaseDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{getChatMessages(chatId:ChatId): Chat}\\
        Metodo astratto per ottenere una Chat a partire da un ChatId.
    \end{itemize}
\end{itemize}


\begin{comment}
    

\subsubsubsection{ChatInfo}
\label{ChatInfoDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{chatId: ChatId}
        \item \code{title: string};
        \item \code{timestamp: timestamp}.
    \end{itemize}
\end{itemize}

\end{comment}



\subsubsubsection{Message}
Vedi \vedi{MessageDettaglio}.

\subsubsubsection{MessageSender}
Vedi \vedi{MessageSenderDettaglio}.


\subsubsubsection{PostgresChat}
Vedi \vedi{PostgresChatDettaglio}.

\subsubsubsection{PostgresChatORM}
Vedi \vedi{PostgresChatORMDettaglio}.

\subsubsubsection{PostgresMessage}
Vedi \vedi{PostgresMessageDettaglio}.



%GETCHATS


\subsection{GetChats}
\subsubsection{Diagramma delle classi}


\begin{figure}[H]
    \centering        
    \includegraphics[width=16.5cm]{img/GetChat.png}
    \caption{Diagramma delle classi della componente GetChats}
\end{figure}
\subsubsection{Lista delle sottocomponenti}

\subsubsubsection{ChatFilter}
\label{ChatFilterDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{searchFilter: string}.
    \end{itemize}
\end{itemize}

\subsubsubsection{ChatId}
Vedi \vedi{ChatIdDettaglio}.


\subsubsubsection{ChatPreview}
\label{ChatPreviewDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{id: ChatId};
        \item \code{lastMessage: Message};
        \item \code{title: string}.
    \end{itemize}
\end{itemize}



\subsubsubsection{GetChatsController}
\label{GetChatsControllerDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{useCase: GetChatsUseCase}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{getChats(searchFilter: string): List<ChatPreview>}\\
        Metodo che ritorna una lista di ChatPreview tramite useCase, eventualmente filtrando la ricerca tramite searchFilter. 
    \end{itemize}
\end{itemize}

\subsubsubsection{GetChatsPort}
\label{GetChatsPortDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{getChats(chatFilter:ChatFilter): List<ChatPreview>}\\
        Metodo astratto per ottenere una lista di ChatPreview, filtrando eventualmente la ricerca tramite chatFilter.
    \end{itemize}
\end{itemize}

\subsubsubsection{GetChatsPostgres}
\label{GetChatsPostgresDettaglio}
\begin{itemize}
    \item \textbf{Implementa}: GetChatsPort;
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{postgresChatORM: PostgresChatORM}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{getChats(chatFilter:ChatFilter): List<ChatPreview>}\\
        Implementazione del metodo astratto di GetChatPort per ottenere una lista di ChatPreview tramite postgresChatORM, filtrando eventualmente la ricerca tramite chatFilter.
        
    \end{itemize}
\end{itemize}


\subsubsubsection{GetChatsService}
\label{GetChatsServiceDettaglio}
\begin{itemize}
    \item \textbf{Implementa}: GetChatsUseCase;
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{outPort: GetChatsPort}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{getChats(chatFilter:ChatFilter): List<ChatPreview>}\\
        Implementazione del metodo astratto di GetChatsUseCase per ottenere una lista di ChatPreview tramite outPort, filtrando eventualmente la ricerca tramite chatFilter.
    \end{itemize}
\end{itemize}


\subsubsubsection{GetChatsUseCase}
\label{GetChatsUseCaseDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{getChats(chatFilter:ChatFilter): List<ChatPreview>}\\
        Metodo astratto per ottenere una lista di ChatPreview, filtrando eventualmente la ricerca tramite chatFilter.
    \end{itemize}
\end{itemize}


\subsubsubsection{Message}
Vedi \vedi{MessageDettaglio}.

\subsubsubsection{MessageSender}
Vedi \vedi{MessageSenderDettaglio}.



\subsubsubsection{PostgresChatORM}
Vedi \vedi{PostgresChatORMDettaglio}.


\subsubsubsection{PostgresChatPreview}
\label{PostgresChatPreviewDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{id: int};
        \item \code{title: string};
       % \item \code{timestamp: timestamp};
        \item \code{lastMessage: PostgresMessage}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \item \code{toChatPreviewFrom():}\\ \code{ChatPreview}
        Metodo per ottenere una ChatPreview a partire dal PostgresChatPreview.
    \end{itemize}
\end{itemize}


\subsubsubsection{PostgresMessage}
Vedi \vedi{PostgresMessageDettaglio}.


\subsubsubsection{PostgresMessageSenderType}
Vedi \vedi{PostgresMessageSenderTypeDettaglio}.

%GETCONFIGURATION

\subsection{GetConfiguration}
\subsubsection{Diagramma delle classi}

\begin{figure}[H]
    \centering        
    \includegraphics[width=17cm]{img/GetConfiguration.png}
    \caption{Diagramma delle classi della componente GetConfiguration}
\end{figure}


\subsubsection{Lista delle sottocomponenti}

\subsubsubsection{Configuration}
\label{ConfigurationDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{embeddingModel: EmbeddingModelConfiguration};
        \item \code{documentStore: DocumentStoreConfiguration};
        \item \code{LLMModel: LLMModelConfiguration};
        \item \code{vectorStore: VectorStoreConfiguration}.
    \end{itemize}
\end{itemize}



\subsubsubsection{DocumentStoreConfiguration}
\label{DocumentStoreConfigurationDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{costIndicatore: string};
        \item \code{description: string};
        \item \code{name: DocumentStoreType};
        \item \code{organization: string};
        \item \code{type: string}.
    \end{itemize}
\end{itemize}


\subsubsubsection{DocumentStoreType (Enumeration)}
\label{DocumentStoreTypeDettaglio}
\begin{itemize}
    \item \textbf{Valori}:
    \begin{itemize}
        \item \code{AWS}. 
    \end{itemize}
\end{itemize}


\subsubsubsection{EmbeddingModelConfiguration}
\label{EmbeddingModelConfigurationDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{costIndicator: string};
        \item \code{description: string};
        \item \code{name: EmbeddingModelType};
        \item \code{organization: string};
        \item \code{type: string}.  
    \end{itemize}
\end{itemize}

\subsubsubsection{EmbeddingModelType (Enumeration)}
\label{EmbeddingModelTypeDettaglio}
\begin{itemize}
    \item \textbf{Valori}:
    \begin{itemize}
        \item \code{HUGGINGFACE};
        \item \code{OPENAI}. 
    \end{itemize}
\end{itemize}


\subsubsubsection{GetConfigurationController}
\label{GetConfigurationControllerDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{useCase: GetConfigurationUseCase}.  
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{getConfiguration(): Configuration}\\
        Metodo che si occupa di ritornare la configurazione di vector store, document store, embedding e LLM model tramite oggetto Configuration.
    \end{itemize}
\end{itemize}





\subsubsubsection{GetConfigurationPort}
\label{GetConfigurationPortDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{getConfiguration(): Configuration}\\
        Metodo atratto che ritorna la configurazione di vector store, document store, embedding e LLM model tramite oggetto Configuration.
    \end{itemize}
\end{itemize}


\subsubsubsection{GetConfigurationPostgres}
\label{GetConfigurationPostgresDettaglio}
\begin{itemize}
    \item \textbf{Implementa}: GetConfigurationPort;
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{postgresConfigurationORM: PostgresConfigurationORM}.  
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{getConfiguration(): Configuration}\\
        Implementazione del metodo astratto di GetConfigurationPort per ottenere la configurazione di vector store, document store, embedding e LLM model ritornando un oggetto Configuration.
    \end{itemize}
\end{itemize}


\subsubsubsection{GetConfigurationService}
\label{GetConfigurationServiceDettaglio}
\begin{itemize}
    \item \textbf{Implementa}: GetConfigurationUseCase;
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{outPort: GetConfigurationPort}.  
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{getConfiguration(): Configuration}\\
        Implementazione del metodo astratto di GetConfigurationUseCase per la configurazione di vector store, document store, embedding e LLM model ritornando un oggetto Configuration.
    \end{itemize}
\end{itemize}


\subsubsubsection{GetConfigurationUseCase}
\label{GetConfigurationUseCaseDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{getConfiguration(): Configuration}\\
        Metodo atratto che ritorna la configurazione di vector store, document store, embedding e LLM model tramite oggetto Configuration.
    \end{itemize}
\end{itemize}



\subsubsubsection{LLMModelConfiguration}
\label{LLMModelConfigurationDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{costIndicator: string};
        \item \code{description: string};
        \item \code{name: LLMModelType};
        \item \code{organization: string};
        \item \code{type: string}.  
    \end{itemize}
\end{itemize}

\subsubsubsection{LLMModelType (Enumeration)}
\label{LLMModelTypeDettaglio}
\begin{itemize}
    \item \textbf{Valori}:
    \begin{itemize}
        \item \code{HUGGINGFACE};
        \item \code{OPENAI}. 
    \end{itemize}
\end{itemize}


\subsubsubsection{PostgresConfiguration}
Vedi \vedi{PostgresConfigurationDettaglio}.

\subsubsubsection{PostgresConfigurationORM}
Vedi \vedi{PostgresConfigurationORMDettaglio}.

\subsubsubsection{PostgresDocumentStoreConfiguration}
Vedi \vedi{PostgresDocumentStoreConfigurationDettaglio}.

\subsubsubsection{PostgresDocumentStoreType}
Vedi \vedi{PostgresDocumentStoreTypeDettaglio}.


\subsubsubsection{PostgresEmbeddingModelConfiguration}
Vedi \vedi{PostgresEmbeddingModelConfigurationDettaglio}.

\subsubsubsection{PostgresEmbeddingModelType}
Vedi \vedi{PostgresEmbeddingModelTypeDettaglio}.

\subsubsubsection{PostgresLLMModelConfiguration}
Vedi \vedi{PostgresLLMModelConfigurationDettaglio}.

\subsubsubsection{PostgresLLMModelType}
Vedi \vedi{PostgresLLMModelTypeDettaglio}.


\subsubsubsection{PostgresVectorStoreConfiguration}
Vedi \vedi{PostgresVectorStoreConfigurationDettaglio}.

\subsubsubsection{PostgresVectorStoreType}
Vedi \vedi{PostgresVectorStoreTypeDettaglio}.


\subsubsubsection{VectorStoreConfiguration}
\label{VectorStoreConfigurationDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{costIndicator: string};
        \item \code{description: string};
        \item \code{name: VectorStoreType};
        \item \code{organization: string};
        \item \code{type: string}.  
    \end{itemize}    
\end{itemize}

\subsubsubsection{VectorStoreType (Enumeration)}
\label{VectorStoreTypeDettaglio}
\begin{itemize}
    \item \textbf{Valori}:
    \begin{itemize}
        \item \code{CHROMA DB};
        \item \code{PINECONE}. 
    \end{itemize}
\end{itemize}


%GETCONFIGURATIONOPTIONS


\subsection{GetConfigurationOptions}
\subsubsection{Diagramma delle classi}
\begin{figure}[H]
    \centering        
    \rotatebox{90}{\includegraphics[width=1.2\textwidth]{img/GetConfigurationOptions.png}}
    \caption{Diagramma delle classi della componente GetConfigurationOptions}
\end{figure}


%\begin{figure}[H]
    %\centering        
   % \includegraphics[width=16.5cm]{img/GetConfigurationOptions.png}
    %\caption{Diagramma delle classi della componente GetConfigurationOptions}
%\end{figure}


\subsubsection{Lista delle sottocomponenti}




\subsubsubsection{ConfigurationOptions}
\label{ConfigurationOptionsDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{documentStoreOptions: List<DocumentStoreConfiguration>};
        \item \code{embeddingModelOptions: List<EmbeddingModelConfiguration>};
        \item \code{LLMModelOptions: List<LLMModelConfiguration>};
        \item \code{vectorStoreOptions: List<VectorStoreConfiguration>}.  
    \end{itemize}    
\end{itemize}


\subsubsubsection{DocumentStoreConfiguration}
Vedi \vedi{DocumentStoreConfigurationDettaglio}.

\subsubsubsection{DocumentStoreType}
Vedi \vedi{DocumentStoreTypeDettaglio}.

\subsubsubsection{EmbeddingModelConfiguration}
Vedi \vedi{EmbeddingModelConfigurationDettaglio}.

\subsubsubsection{EmbeddingModelType}
Vedi \vedi{EmbeddingModelTypeDettaglio}.


\subsubsubsection{GetConfigurationOptions}
\label{GetConfigurationOptionsDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{useCase: GetConfigurationOptionsUseCase}.
    \end{itemize} 
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{getConfigurationOptions(): ConfigurationOptions}\\
        Metodo che si occupa di ritornare le opzioni disponibili per le configurazioni di vector store, document store, embedding model e LLM model.
    \end{itemize}   
\end{itemize}


\subsubsubsection{GetConfigurationOptionsPort}
\label{GetConfigurationOptionsPortDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{getConfigurationOptions(): ConfigurationOptions}\\
        Metodo atratto che si occupa di ritornare le opzioni disponibili per le configurazioni di vector store, document store, embedding model e LLM model.
    \end{itemize}   
\end{itemize}



\subsubsubsection{GetConfigurationOptionsPostgres}
\label{GetConfigurationOptionsPostgresDettaglio}
\begin{itemize}
    \item \textbf{Implementa}: GetConfigurationOptionsPort;
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{postgresConfigurationORM: PostgresConfigurationORM}.
    \end{itemize} 
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{getConfigurationOptions(): ConfigurationOptions}\\
        Implementazione del metodo astratto di GetConfigurationOptionsPort che ritorna le opzioni disponibili per le configurazioni di vector store, document store, embedding model e LLM model.
    \end{itemize}   
\end{itemize}


\subsubsubsection{GetConfigurationOptionsService}
\label{GetConfigurationOptionsServiceDettaglio}
\begin{itemize}
    \item \textbf{Implementa}: GetConfigurationOptionsUseCase;
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{outPort: GetConfigurationOptionsPort}.
    \end{itemize} 
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{getConfigurationOptions(): ConfigurationOptions}\\
        Implementazione del metodo astratto di GetConfigurationOptionsUseCase che ritorna le opzioni disponibili per le configurazioni di vector store, document store, embedding model e LLM model.
    \end{itemize}   
\end{itemize}



\subsubsubsection{GetConfigurationOptionsUseCase}
\label{GetConfigurationOptionsUseCaseDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{getConfigurationOptions(): ConfigurationOptions}\\
        Metodo astratto per ritornare le opzioni disponibili per le configurazioni di vector store, document store, embedding model e LLM model.
    \end{itemize}   
\end{itemize}




\subsubsubsection{LLMModelConfiguration}
Vedi \vedi{LLMModelConfigurationDettaglio}

\subsubsubsection{LLMModelType}
Vedi \vedi{LLMModelTypeDettaglio}.

\subsubsubsection{PostgresConfigurationORM}
Vedi \vedi{PostgresConfigurationORMDettaglio}.

\subsubsubsection{PostgresDocumentStoreConfiguration}
Vedi \vedi{PostgresDocumentStoreConfigurationDettaglio}.

\subsubsubsection{PostgresDocumentStoreType}
Vedi \vedi{PostgresDocumentStoreTypeDettaglio}.

\subsubsubsection{PostgresEmbeddingModelConfiguration}
Vedi \vedi{PostgresEmbeddingModelConfigurationDettaglio}.

\subsubsubsection{PostgresEmbeddingModelType}
Vedi \vedi{PostgresEmbeddingModelTypeDettaglio}.

\subsubsubsection{PostgresLLMModelConfiguration}
Vedi \vedi{PostgresLLMModelConfigurationDettaglio}.

\subsubsubsection{PostgresLLMModelType}
Vedi \vedi{PostgresLLMModelTypeDettaglio}.

\subsubsubsection{PostgresVectorStoreConfiguration}
Vedi \vedi{PostgresVectorStoreConfigurationDettaglio}.

\subsubsubsection{PostgresVectorStoreType}
Vedi \vedi{PostgresVectorStoreTypeDettaglio}.

\subsubsubsection{VectorStoreConfiguration}
Vedi \vedi{VectorStoreConfigurationDettaglio}.

\subsubsubsection{VectorStoreType}
Vedi \vedi{VectorStoreTypeDettaglio}.



%GETDOCUMENTCONTENT

\subsection{GetDocumentContent}
\subsubsection{Diagramma delle classi}

\begin{figure}[H]
    \centering        
    \rotatebox{90}{\includegraphics[width=1.45\textwidth]{img/GetDocContent.png}}
    \caption{Diagramma delle classi componente GetDocumentContent}
\end{figure}



\subsubsection{Lista delle sottocomponenti}


\subsubsubsection{AWSDocument}
Vedi \vedi{AWSDocumentDettaglio}.

\subsubsubsection{AWSS3Manager}
Vedi \vedi{AWSS3ManagerDettaglio}.

\subsubsubsection{Document}
Vedi \vedi{DocumentDettaglio}.

\subsubsubsection{DocumentContent}
Vedi \vedi{DocumentContentDettaglio}.

\subsubsubsection{DocumentId}
Vedi \vedi{DocumentIdDettaglio}.

\subsubsubsection{DocumentMetadata}
Vedi \vedi{DocumentMetadataDettaglio}.

\subsubsubsection{DocumentStatus}
Vedi \vedi{DocumentStatusDettaglio}.

\subsubsubsection{DocumentType (Enumeration)}
Vedi \vedi{DocumentTypeDettaglio}.


\subsubsubsection{GetDocumentContentController}
\label{GetDocumentContentControllerDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{useCase: GetDocumentsContentUseCase}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{getDocumentContent(documentId:String): Document}\\
        Metodo che si occupa di trasformare la stringa id in DocumentId e inoltrare la richiesta di recupero del documento a GetDocumentsUseCase.
    \end{itemize}
\end{itemize}

\subsubsubsection{GetDocumentsContentFacadeService}
\label{GetDocumentsContentFacadeServiceDettaglio}
\begin{itemize}
    \item \textbf{Implementa}: GetDocumentsContentUseCase;
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{getDocumentsContent: GetDocumentsContent};
        \item \code{getDocumentsStatus: GetDocumentsStatus}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{getDocumentsContent(documentId: Lisr<DocumentId>): Listt<Document>}\\
        Implementazione del metodo astratto di GetDocumentUseCase. Le operazioni all'interno della facade vengono svolte nel seguente ordine:
        \begin{enumerate}
            \item Recupero della lista di status dei documenti dal vector store;
            \item Recupero dei documenti e il loro contenuto dal sistema di archiviazione;
            \item Costruzione di una lista di oggetti Document a partire dagli output dei passaggi precedenti.
        \end{enumerate}
    \end{itemize}
\end{itemize}

\subsubsubsection{GetDocumentsContent}
Vedi \vedi {GetDocumentsContentDettaglio}.

\subsubsubsection{GetDocumentsContentAWSS3}
Vedi \vedi{GetDocumentsContentAWSS3Dettaglio}.

\subsubsubsection{GetDocumentsContentPort}
Vedi \vedi{GetDocumentsContentPortDettaglio}.


\subsubsubsection{GetDocumentsStatus}
Vedi \vedi{GetDocumentsStatusDettaglio}.



\subsubsubsection{GetDocumentsStatusPort}
Vedi \vedi{GetDocumentsStatusPortDettaglio}.


\subsubsubsection{GetDocumentsStatusVectorStore}
Vedi \vedi{GetDocumentsStatusVectorStoreDettaglio}.


\subsubsubsection{GetDocumentsContentUseCase}
\label{GetDocumentsContentUseCaseDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{getDocumentsContent(documentId:List<DocumentId>): List<Document>}\\
        Metodo astratto per recuperare tutte le informazioni di una lista di documenti, compresi i loro contenuti, a partire da una lista dei loro id.
    \end{itemize}
\end{itemize}

\subsubsubsection{PlainDocument}
Vedi \vedi{PlainDocumentDettaglio}.


\subsubsubsection{Status (Enumeration)}
Vedi \vedi{StatusDettaglio}.

\subsubsubsection{VectorStoreChromaDBManager}
Vedi \vedi{VectorStoreChromaDBManagerDettaglio}.

\subsubsubsection{VectorStoreDocumentStatusResponse}
Vedi \vedi{VectorStoreDocumentStatusResponseDettaglio}.



\subsubsubsection{VectorStoreManager}
Vedi \vedi{VectorStoreManagerDettaglio}.

\subsubsubsection{VectorStorePineconeManager}
Vedi \vedi{VectorStorePineconeManagerDettaglio}.


%GETDOCUMENTS


\subsection{GetDocuments}
\subsubsection{Diagramma delle classi}
\begin{figure}[H]
    \centering        
    \rotatebox{90}{\includegraphics[width=1.45\textwidth]{img/GetDocs.png}}
    \caption{Diagramma delle classi componente GetDocuments}
\end{figure}


\subsubsection{Lista delle sottocomponenti}


\subsubsubsection{AWSDocumentMetadata}
\label{AWSDocumentMetadataDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{id: string};
        \item \code{size: float};
        \item \code{uploadTime: datetime}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{toDocumentMetadataFrom():}\\ \code{DocumentMetadata}\\
        Metodo che trasforma un AWSDocumentMetadata della persistence in un DocumentMetadata della business logic.
    \end{itemize}
\end{itemize}

\subsubsubsection{AWSS3Manager}
Vedi \vedi{AWSS3ManagerDettaglio}.


\subsubsubsection{DocumentFilter}
\label{DocumentFilterDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{searchFilter: string}.
    \end{itemize}
\end{itemize}

\subsubsubsection{DocumentId}
Vedi \vedi{DocumentIdDettaglio}.


\subsubsubsection{DocumentMetadata}
\label{DocumentMetadataDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{id: DocumentId};
        \item \code{size: float};
        \item \code{type: DocumentType};
        \item \code{uploadTime: datetime}.
    \end{itemize}
\end{itemize}

\subsubsubsection{DocumentStatus}
Vedi \vedi{DocumentStatusDettaglio}.

\subsubsubsection{DocumentType (Enumeration)}
\label{DocumentTypeDettaglio}
\begin{itemize}
    \item \textbf{Valori}:
    \begin{itemize}
        \item \code{DOCX};
        \item \code{PDF}.
    \end{itemize}
\end{itemize}

\subsubsubsection{ElaborationException}
\label{ElaborationExceptionDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{message: string}.
    \end{itemize}
\end{itemize}


\subsubsubsection{GetDocumentsController}
\label{GetDocumentsControllerDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{useCase: GetDocumentsUseCase}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{getDocuments(searchFilter:string = ""): List<LightDocument>}\\
        Metodo che si occupa di inoltrare la richiesta di ricerca di documenti a GetDocumentsUseCase, trasformando la stringa filter in oggetto di business SearchFilter.
    \end{itemize}
\end{itemize}

\subsubsubsection{GetDocumentsFacadeService}
\label{GetDocumentsFacadeServiceDettaglio}
\begin{itemize}
    \item \textbf{Implementa}: GetDocumentsUseCase;
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{getDocumentMetadatas: GetDocumentMetadatas};
        \item \code{getDocumentsStatus: GetDocumentsStatus}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{getDocuments(documentFilter:DocumentFilter): List<LightDocument>}\\
        Implementazione del metodo astratto di GetDocumentsUseCase per ricercare documenti a partire da un filtro di ricerca, tramite l'utilizzo di un pattern facade.\\
        Le operazioni all'interno della facade vengono svolte nel seguente ordine:
        \begin{enumerate}
            \item Recupero dei documenti che soddisfano la ricerca dal sistema di archiviazione;
            \item Recupero degli status dei documenti ritornati dal passo precedente;
            \item Creazione di oggetti LightDocument a partire dai risultati dei passi precedenti.
        \end{enumerate}
    \end{itemize}
\end{itemize}

\subsubsubsection{GetDocumentsListAWSS3}
\label{GetDocumentsListAWSS3Dettaglio}
\begin{itemize}
    \item \textbf{Implementa}: GetDocumentsMetadataPort;
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{awsS3Manager: AWSS3Manager}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{getDocumentsMetadata(documentFilter:DocumentFilter):}\\ \code{List<DocumentMetadata>}\\
        Implementazione del metodo astratto di GetDocumentsMetadataPort per ricercare documenti tramite outPort nel sistema di archiviazione a partire da un filtro.
        
    \end{itemize}
\end{itemize}

\subsubsubsection{GetDocumentsMetadata}
\label{GetDocumentsMetadataDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{outPort: GetDocumentsMetadataPort}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{getDocumentsMetadata(documentFilter:DocumentFilter):}\\ \code{List<DocumentMetadata>}\\
        Metodo per ricercare documenti tramite outPort nel sistema di archiviazione a partire da un filtro.
    \end{itemize}
\end{itemize}

\subsubsubsection{GetDocumentsMetadataPort}
\label{GetDocumentsMetadataPortDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{getDocumentsMetadata(documentFilter:DocumentFilter):}\\ \code{List<DocumentMetadata>}\\
        Metodo astratto per ricercare documenti nel sistema di archiviazione a partire da un filtro di ricerca.
    \end{itemize}
\end{itemize}


\subsubsubsection{GetDocumentsStatus}
Vedi \vedi{GetDocumentsStatusDettaglio}.

\subsubsubsection{GetDocumentsStatusPort}
Vedi \vedi{GetDocumentsStatusPortDettaglio}.

\subsubsubsection{GetDocumentsStatusVectorStore}
Vedi \vedi{GetDocumentsStatusVectorStoreDettaglio}.

\subsubsubsection{GetDocumentsUseCase}
\label{GetDocumentsUseCaseDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{getDocuments(documentFilter:DocumentFilter): List<LightDocument>}\\
        Metodo astratto per ricercare documenti a partire da un filtro di ricerca.
    \end{itemize}
\end{itemize}


\subsubsubsection{LightDocument}
\label{LightDocumentDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{metadata: DocumentMetadata};
        \item \code{status: DocumentStatus}.
    \end{itemize}
\end{itemize}


\subsubsubsection{Status (Enumeration)}
Vedi \vedi{StatusDettaglio}.

\subsubsubsection{VectorStoreChromaDBManager}
Vedi \vedi{VectorStoreChromaDBManagerDettaglio}.

\subsubsubsection{VectorStoreDocumentStatusResponse}
Vedi \vedi{VectorStoreDocumentStatusResponseDettaglio}.



\subsubsubsection{VectorStoreManager}
Vedi \vedi{VectorStoreManagerDettaglio}.

\subsubsubsection{VectorStorePineconeManager}
Vedi \vedi{VectorStorePineconeManagerDettaglio}.



%RENAMECHAT


\subsection{RenameChat}
\subsubsection{Diagramma delle classi}
\begin{figure}[H]
    \centering        
    \includegraphics[width=16.5cm]{img/RenameChat.png}
    \caption{Diagramma delle classi componente RenameChat}
\end{figure}

\subsubsection{Lista delle sottocomponenti}

\subsubsubsection{ChatId}
Vedi \vedi{ChatIdDettaglio}.

\subsubsubsection{ChatOperationResponse}
Vedi \vedi{ChatOperationResponseDettaglio}.

\subsubsubsection{RenameChatController}
\label{RenameChatControllerDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{useCase: RenameChatUseCase}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{renameChat(chatId:int, title:string): ChatOperationResponse}\\
        Metodo che rinomina tramite useCase una chat identificate da un intero, ritornando un ChatOperationResponse.
        %\item \code{toChatIdFrom(chatIdInt:int): ChatId}\\
        %Metodo che crea e ritorna un ChatId a partire da un intero. 
    \end{itemize}
\end{itemize}


\subsubsubsection{RenameChatPort}
\label{RenameChatPortDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{renameChat(chatId:ChatId, title:string): ChatOperationResponse}\\
        Metodo astratto per rinominare con title una chat identificata da un ChatId, ritornando un ChatOperationResponse rappresentante l'esito dell'operazione.
    \end{itemize}
\end{itemize}

\subsubsubsection{RenameChatPostgres}
\label{RenameChatPostgresDettaglio}
\begin{itemize}
    \item \textbf{Implementa}: RenameChatPort;
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{outPort: PostgresChatORM}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{renameChat(chatId:ChatId, title:string): ChatOperationResponse}\\
        Implementazione del metodo astratto di RenameChatPort per rinominare con title una chat identificata da un ChatId, ritornando un ChatOperationResponse rappresentante l'esito dell'operazione.
    \end{itemize}
\end{itemize}



\subsubsubsection{RenameChatService}
\label{RenameChatServiceDettaglio}
\begin{itemize}
    \item \textbf{Implementa}: RenameChatUseCase;
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{outPort: RenameChatPort}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{renameChat(chatId:ChatId, title:string): ChatOperationResponse}\\
        Implementazione del metodo astratto di RenameChatUseCase per rinominare con title tramite outPort una chat identificata da un ChatId, ritornando un ChatOperationResponse rappresentante l'esito dell'operazione.
    \end{itemize}
\end{itemize}

\subsubsubsection{RenameChatUseCase}
\label{RenameChatUseCaseDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{renameChat(chatId:ChatId, title:string): ChatOperationResponse}\\
        Metodo astratto per che rinominare con title una chat identificata da un ChatId, ritornando un ChatOperationResponse rappresentante l'esito dell'operazione.
    \end{itemize}
\end{itemize}


\subsubsubsection{PostgresChatOperationResponse}
Vedi \vedi{PostgresChatOperationResponseDettaglio}.



\subsubsubsection{PostgresChatORM}
Vedi \vedi{PostgresChatORMDettaglio}.


%SETCONFIGURATION
\subsection{SetConfiguration}
\subsubsection{Diagramma delle classi}
\begin{figure}[H]
    \centering        
    \includegraphics[width=16.5cm]{img/SetConfiguration.png}
    \caption{Diagramma delle classi componente SetConfiguration}
\end{figure}

\subsubsection{Lista delle sottocomponenti}


\subsubsubsection{ConfigurationOperationResponse}
Vedi \vedi{ConfigurationOperationResponseDettaglio}.

\subsubsubsection{PostgresConfigurationOperationResponse}
Vedi \vedi{PostgresConfigurationOperationResponseDettaglio}.

\subsubsubsection{PostgresConfigurationORM}
Vedi \vedi{PostgresConfigurationORMDettaglio}.

\subsubsubsection{SetConfigurationController}
\label{SetConfigurationControllerDettaglio}
\begin{itemize}
    \item \textbf{Attributi}: \code{useCase: SetConfigurationUseCase};
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{setConfiguration(LLModel:string, DocumentStore:string,}\\\code{ VectorStore:string EmbeddingModel:string): ConfigurationOperationResponse}\\
        Metodo che si occupa di inizializzare la configurazione del sistema al primo avvio, passando stringhe che rappresentano rispettivamente LLModel, document store, vector store ed embedding model. Ritorna un ConfigurationOperationResponse rappresentante l'esito dell'operazione.
    \end{itemize}
\end{itemize}

\subsubsubsection{SetConfigurationPort}
\label{SetConfigurationPortDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{setConfiguration(LLModel:LLMModelType, DocumentStore:DocumentStoreType,}\\ \code{ VectorStore:VectorStoreType, EmbeddingModel:EmbeddingModelType):}\\ \code{ConfigurationOperationResponse}\\
        Metodo astratto per inizializzare la configurazione del sistema al primo avvio passando LLMModelType, DocumentStoreType, VectorStoreType ed EmbeddingModelType. Ritorna un ConfigurationOperationResponse.
    \end{itemize}
\end{itemize}

\subsubsubsection{SetConfigurationPostgres}
\label{SetConfigurationPostgresDettaglio}
\begin{itemize}
    \item \textbf{Implementa}: SetConfigurationPort;
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{postgresConfigurationORM: PostgresConfigurationORM}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{setConfiguration(LLModel:LLMModelType, DocumentStore:DocumentStoreType,}\\ \code{ VectorStore:VectorStoreType, EmbeddingModel:EmbeddingModelType):}\\ \code{ConfigurationOperationResponse}\\
        Implementazione del metodo astratto di SetConfigurationPort inizializzare la configurazione del sistema al primo avvio passando LLMModelType, DocumentStoreType, VectorStoreType ed EmbeddingModelType. Ritorna l'esito dell'operazione con un ConfigurationOperationResponse;
        \item \code{toPostgresDocumentStoreTypeFrom(DocumentStore:DocumentStoreType): PostgresDocumentStoreType}\\
        Metodo per convertire un DocumentStoreType in PostgresDocumentStoreType;
        \item \code{toPostgresEmbeddingModelFrom(EmbeddingModel: EmbeddingModelType): PostgresEmbeddingModelType}\\
        Metodo per convertire un EmbeddingModelType in PostgresEmbeddingModelType;
        \item \code{toPostgresLLMModelTypeFrom(LLMModel:LLMModelType): PostgresLLMModelType}\\
        Metodo per convertire un LLLMModelType in PostgresLLMModelType;
        \item \code{toPostgresVectorStoreTypeFrom(VectorStore:VectorStoreType): PostgresVectorStoreType}\\
        Metodo per convertire un VectorStoreType in PostgresVectorStoreType.

    \end{itemize}
\end{itemize}

\subsubsubsection{SetConfigurationService}
\label{SetConfigurationServiceDettaglio}
\begin{itemize}
    \item \textbf{Implementa}: SetConfigurationUseCase;
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{outPort: SetConfigurationPort}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{setConfiguration(LLModel:LLMModelType, DocumentStore:DocumentStoreType,}\\ \code{ VectorStore:VectorStoreType, EmbeddingModel:EmbeddingModelType):}\\ \code{ConfigurationOperationResponse}\\
        Implementazione del metodo astratto di SetConfigurationUseCase per inizializzare la configurazione del sistema al primo avvio tramite outPort. Ritorna l'esito dell'operazione con un ConfigurationOperationResponse.
    \end{itemize}
\end{itemize}



\subsubsubsection{SetConfigurationUseCase}
\label{SetConfigurationUseCaseDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{setConfiguration(LLModel:LLMModelType, DocumentStore:DocumentStoreType,}\\ \code{ VectorStore:VectorStoreType, EmbeddingModel:EmbeddingModelType):}\\ \code{ConfigurationOperationResponse}\\
        Metodo astratto per inizializzare la configurazione del sistema al primo avvio, ritornando l'esito come ConfigurationOperationResponse.
    \end{itemize}
\end{itemize}





%UPLOADDOCUMENTS


\subsection{UploadDocuments}
\subsubsection{Diagramma delle classi}
\vspace{3em}

\begin{figure}[H]
    \centering        
    \includegraphics[width=17cm]{img/UploadDocs0.png}
    \caption{Diagramma delle classi componente UploadDocuments (continua nei prossimi diagrammi)}
\end{figure}
\vspace{3em}
\begin{figure}[H]
    \centering        
    \includegraphics[width=15cm]{img/UploadDocs1.png}
    \caption{Diagramma delle classi componente UploadDocuments (continua nel prossimo diagramma)}
\end{figure}
\vspace{3em}
\begin{figure}[H]
    \centering        
    \rotatebox{90}{\includegraphics[keepaspectratio, height=16.3cm, width=1.6\textwidth]{img/UploadDocs2.png}}
    \caption{Diagramma delle classi componente UploadDocuments}
\end{figure}

\subsubsection{Lista delle sottocomponenti}

\subsubsubsection{AWSDocument}
Vedi \vedi{AWSDocumentDettaglio}.

\subsubsubsection{AWSDocumentOperationResponse}
Vedi \vedi{AWSDocumentOperationResponseDettaglio}.

\subsubsubsection{AWSS3Manager}
Vedi \vedi{AWSS3ManagerDettaglio}.

\subsubsubsection{Chunkerizer}
Vedi \vedi{ChunkerizerDettaglio}.

\subsubsubsection{Document}
\label{DocumentDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{plainDocument: PlainDocument};
        \item \code{documentStatus: DocumentStatus}.
    \end{itemize}
\end{itemize}

\subsubsubsection{DocumentContent}
\label{DocumentContentDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{content: bytes}.
    \end{itemize}
\end{itemize}


\subsubsubsection{DocumentId}
Vedi \vedi{DocumentIdDettaglio}.

\subsubsubsection{DocumentMetadata}
Vedi \vedi{DocumentMetadataDettaglio}.

\subsubsubsection{DocumentOperationResponse}
Vedi \vedi{DocumentOperationResponseDettaglio}.

\subsubsubsection{DocumentStatus}
Vedi \vedi{DocumentStatusDettaglio}.

\subsubsubsection{DocumentType (Enumeration)}
Vedi \vedi{DocumentTypeDettaglio}.

\subsubsubsection{DocumentsUploader}
\label{DocumentsUploaderDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{outPort: DocumentsUploaderPort}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{uploadDocuments(documents:List<Document>, forceUpload:boolean):}\\ \code{ List<DocumentOperationResponse>}\\ 
        Metodo per effettuare il caricamento di una lista di Document tramite outPort sul sistema di archiviazione, con flag per forzare il caricamento di documenti già presenti nel sistema attraverso sostituzione, ritornando infine una lista di DocumentOperationResponse.
    \end{itemize}
\end{itemize}

\subsubsubsection{DocumentUploaderAWSS3}
\label{DocumentUploaderAWSS3Dettaglio}
\begin{itemize}
    \item \textbf{Implementa}: DocumentsUploaderPort;
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{awsS3Manager: AWSS3Manager}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{uploadDocuments(documents:List<Document>, forceUpload:boolean):}\\ \code{List<DocumentOperationResponse>}\\
        Implementazione del metodo astratto di DocumentsUploaderPort per il caricamento di una lista di Document nel sistema di archiviazione tramite awsS3Manager, con flag per  forzare il caricamento di documenti già presenti nel sistema attraverso sostituzione, ritornando infine una lista di DocumentOperationResponse;
        \item \code{toAWSDocumentFrom(document:Document): AWSDocument}\\
        Metodo che trasforma un Document in un AWSDocument.
    \end{itemize}
\end{itemize}

\subsubsubsection{DocumentsUploaderPort}
\label{DocumentsUploaderPortDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{uploadDocuments(documents:List<Document>, forceUpload:boolean):}\\ \code{List<DocumentOperationResponse>}\\
        Metodo astratto per effettuare il caricamento di una lista di Document in un sistema di archiviazione documenti, con flag per forzare il caricamento di documenti già presenti nel sistema attraverso sostituzione.
    \end{itemize}
\end{itemize}


\subsubsubsection{DOCXTextExtractor}
Vedi \vedi{DOCXTextExtractorDettaglio}.

\subsubsubsection{EmbeddingsCreator}
Vedi \vedi{EmbeddingsCreatorDettaglio}.


\subsubsubsection{EmbeddingsUploader}
Vedi \vedi{EmbeddingsUploaderDettaglio}.


\subsubsubsection{EmbeddingsUploaderFacadeLangchain}
Vedi \vedi{EmbeddingsUploaderFacadeLangchainDettaglio}.

\subsubsubsection{EmbeddingsUploaderPort}
Vedi \vedi{EmbeddingsUploaderPortDettaglio}.

\subsubsubsection{EmbeddingsUploaderVectorStore}
Vedi \vedi{EmbeddingsUploaderVectorStoreDettaglio}.

\subsubsubsection{HuggingFaceEmbeddingModel}
Vedi \vedi{HuggingFaceEmbeddingModelDettaglio}.

\subsubsubsection{LangchainDocument}
Vedi \vedi{LangchainDocumentDettaglio}.

\subsubsubsection{LangchainEmbeddingModel}
Vedi \vedi {LangchainEmbeddingModelDettaglio}.


\subsubsubsection{NewDocument}
\label{NewDocumentDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{content: bytes};
        \item \code{documentId: string};
        \item \code{size: float};
        \item \code{type: string}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{toDocument(): Document}\\
        Metodo che trasforma un NewDocument della presentation logic in un Document della business logic.
        
    \end{itemize}
\end{itemize}

\subsubsubsection{OpenAIEmbeddingModel}
Vedi \vedi{OpenAIEmbeddingModelDettaglio}.

\subsubsubsection{PDFTextExtractor}
Vedi \vedi{PDFTextExtractorDettaglio}.


\subsubsubsection{PlainDocument}
\label{PlainDocumentDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{content: DocumentContent};
        \item \code{metadata: DocumentMetadata}.
    \end{itemize}
\end{itemize}


\subsubsubsection{Status (Enumeration)}
Vedi \vedi{StatusDettaglio}.

\subsubsubsection{TextExtractor}
Vedi \vedi{TextExtractorDettaglio}.



\subsubsubsection{UploadDocumentsController}
\label{UploadDocumentsControllerDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{useCase: UploadDocumentsUseCase}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{uploadDocuments(newDocuments:List<NewDocument>):}\\ \code{List<DocumentOperationResponse>}\\
        Metodo che effettua l'upload di una lista di NewDocument tramite useCase, ritornando una lista di DocumentOperationResponse.        
    \end{itemize}
\end{itemize}



\subsubsubsection{UploadDocumentsService}
\label{UploadDocumentsServiceDettaglio}
\begin{itemize}
    \item \textbf{Implementa}: UploadDocumentsUseCase;
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{documentUploader: DocumentsUploader};
        \item \code{embeddingsUploader: EmbeddingsUploader}.  
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{uploadDocuments(documents:List<Document>, forceUpload:boolean):}\\ \code{ List<DocumentOperationResponse>}\\
        Implementazione del metodo astratto di UploadDocumentsUseCase, per il caricamento di una lista di Documents tramite documentsUploader nel sistema di archiviazione documenti, con flag per forzare il caricamento di documenti già presenti nel sistema attraverso sostituzione, occupandosi inoltre della generazione e caricamento dei relativi embeddings dei documenti tramite embeddingsUploader in un vector store, ritornando una lista di DocumentOperationResponse che tenga conto di entrambe le risposte delle due sotto-operazioni precedentemente descritte ed eseguite.
    \end{itemize}
\end{itemize}


\subsubsubsection{UploadDocumentsUseCase}
\label{UploadDocumentsUseCaseDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{uploadDocuments(documents:List<Document>, forceUpload:boolean):}\\ \code{ List<DocumentOperationResponse>}\\
        Metodo astratto per caricare una lista di Document nel sistema, con possibilità di forzare un caricamento di un documento già presente tramite una flag, ritornando una lista di DocumentOperationResponse.
    \end{itemize}
\end{itemize}





\subsubsubsection{VectorStoreChromaDBManager}
Vedi \vedi{VectorStoreChromaDBManagerDettaglio}.

\subsubsubsection{VectorStoreDocumentOperationResponse}
Vedi \vedi{VectorStoreDocumentOperationResponseDettaglio}.


\subsubsubsection{VectorStoreManager}
Vedi \vedi{VectorStoreManagerDettaglio}.

\subsubsubsection{VectorStorePineconeManager}
Vedi \vedi{VectorStorePineconeManagerDettaglio}.


\end{document}