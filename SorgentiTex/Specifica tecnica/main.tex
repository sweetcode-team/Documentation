\documentclass[10pt, a4paper]{article}

\input{parameters}

\usepackage{style}
\usepackage{headerfooter}
\usepackage{comment}

\title{\titolo}
\author{SWEetCode}

\begin{document}

% PRIMA PAGINA
\include{firstpage}

% REGISTRO DELLE VERSIONI
\include{registroversioni}
\newpage

% INDICE
\tableofcontents
\newpage
\listoffigures
\newpage
\listoftables
\newpage

% INTRODUZIONE
\section{Introduzione}
\subsection{Obiettivo del documento}
L'obiettivo che ci si pone nella realizzazione di questo documento è descrivere le scelte tecnologiche e l'architettura del prodotto \textit{Knowledge Managment AI}. Verrà seguito un approccio top-down, partendo dall'architettura del sistema passando poi all'architettura delle componenti ed infine alla progettazione di dettaglio.

\subsection{Glossario}
Per evitare ambiguità ed incomprensioni relative al linguaggio e ai termini utilizzati nella documentazione del progetto viene presentato un Glossario.
I termini ambigui o tecnici-specifici presenti nello stesso, vengono identificati nei corrispondenti documenti con un pedice |g| e con una scrittura in corsivo.
All'interno dei documenti viene identificata con tale scrittura solo e soltanto la prima occorrenza presente nel testo di un termine definito nel Glossario.

\subsection{Riferimenti}
   \subsubsection{Riferimenti normativi}
   \begin{itemize}
    \item \textit{(Norme di progetto v2.0.0(0))};
    \item \textit{Regolamento del progetto didattico}: \\
        \url{https://www.math.unipd.it/~tullio/IS-1/2023/Dispense/PD2.pdf}\\
        (Ultimo accesso: 2024-02-26);
    \item \textit{Standard ISO/IEC 9126}:\\
        \url{https://it.wikipedia.org/wiki/ISO/IEC_9126}\\
        (Ultimo accesso: 2024-02-26).
    \end{itemize}
    
    \subsubsection{Riferimenti informativi}
    \begin{itemize}
        \item \textit{(Analisi dei requisiti v2.0.0(0))};
        \item \textit{Capitolato C1}: \textit{Knowledge Management AI}
        \begin{itemize}
            \item \url{https://www.math.unipd.it/~tullio/IS-1/2023/Progetto/C1.pdf}\\
            (Ultimo accesso: 2024-02-26);
            \item \url{https://www.math.unipd.it/~tullio/IS-1/2023/Progetto/C1p.pdf}\\
            (Ultimo accesso: 2024-02-26).
        \end{itemize}
        \item \textit{Dispense su Dependency Injection}: \\
            \url{https://www.math.unipd.it/~rcardin/swea/2022/Design%20Pattern%20Architetturali%20-%20Dependency%20Injection.pdf}\\
            (Ultimo accesso: 2024-02-26);
        \item \textit{Dispense su OOP}: \\
            \url{https://www.math.unipd.it/~rcardin/swea/2023/Object-Oriented%20Progamming%20Principles%20Revised.pdf}\\
            (Ultimo accesso: 2024-02-26);
        \item \textit{Dispense su Diagrammi delle classi}: \\
            \url{https://www.math.unipd.it/~rcardin/swea/2023/Diagrammi%20delle%20Classi.pdf}\\
            (Ultimo accesso: 2024-02-26);
        \item \textit{Dispense su Pattern architetturali}: \\
            \url{https://www.math.unipd.it/~rcardin/swea/2022/Software%20Architecture%20Patterns.pdf}\\
            (Ultimo accesso: 2024-02-26);
        \item \textit{Dispense su Pattern creazionali}: \\
            \url{https://www.math.unipd.it/~rcardin/swea/2022/Design%20Pattern%20Creazionali.pdf}\\
            (Ultimo accesso: 2024-02-26);
        \item \textit{Dispense su Pattern strutturali}: \\
            \url{https://www.math.unipd.it/~rcardin/swea/2022/Design%20Pattern%20Strutturali.pdf}\\
            (Ultimo accesso: 2024-02-26);
        \item \textit{Dispense su Principi SOLID}: \\
            \url{https://www.math.unipd.it/~rcardin/swea/2021/SOLID%20Principles%20of%20Object-Oriented%20Design_4x4.pdf}\\
            (Ultimo accesso: 2024-02-26);
        \item \textit{Dispense sulla Progettazione software (argomento T6)}: \\
            \url{https://www.math.unipd.it/~tullio/IS-1/2023/Dispense/T6.pdf}\\
            (Ultimo accesso: 2024-02-26);
        \item \textit{Dispense sulla Qualità del software (argomento T7)}: \\
            \url{https://www.math.unipd.it/~tullio/IS-1/2023/Dispense/T7.pdf}\\
            (Ultimo accesso: 2024-02-26);
        \item \textit{Repository su Architettura esagonale}: \\
            \url{https://github.com/rcardin/hexagonal}\\
            (Ultimo accesso: 2024-02-26);
            \url{https://github.com/rcardin/hexagonal-java/}\\
            (Ultimo accesso: 2024-02-26);
        \item \textit{Repository Ingegneria del software professor Cardin}: \\
            \url{https://github.com/rcardin/swe-imdb}\\
            (Ultimo accesso: 2024-02-26);
        \item Riferimenti a scelte tecnologiche:
        \begin{itemize}
            \item \textit{AWS S3}: \\
                \url{https://aws.amazon.com/it/s3/}\\
                (Ultimo accesso: 2024-02-26);
            \item \textit{ChromaDB}: \\
                \url{https://www.trychroma.com/}\\
                (Ultimo accesso: 2024-02-26);
            \item \textit{Docker}: \\
                \url{https://www.docker.com/}\\
                (Ultimo accesso: 2024-02-26);
            \item \textit{Flask}: \\
                \url{https://flask.palletsprojects.com/en/3.0.x/}\\
            (Ultimo accesso: 2024-02-26);
            \item \textit{HuggingFace}: \\
                \url{https://huggingface.co/}\\
                (Ultimo accesso: 2024-02-26);
            \item \textit{Langchain}: \\
                \url{https://python.langchain.com/docs/get_started/introduction}\\
                (Ultimo accesso: 2024-02-26);
            \item \textit{Next.js}: \\
                \url{https://nextjs.org/}\\
                (Ultimo accesso: 2024-02-26);
            \item \textit{OpenAI}: \\
                \url{https://openai.com/}\\
                (Ultimo accesso: 2024-02-26);
            \item \textit{Pinecone}: \\
                \url{https://www.pinecone.io/}\\
                (Ultimo accesso: 2024-02-26);
            \item \textit{Postgres}: \\
                \url{https://www.postgresql.org/}\\
                (Ultimo accesso: 2024-02-26);
            \item \textit{Python}: \\
                \url{https://www.python.org/}\\
                (Ultimo accesso: 2024-02-26);
            \item \textit{Typescript}: \\
                \url{https://www.typescriptlang.org/}\\
                (Ultimo accesso: 2024-02-26);
        \end{itemize}
        \item \textit{(Glossario v2.0.0(0))};
        \item \textit{(Piano di progetto v2.0.0(0))};
        \item \textit{(Piano di qualifica v2.0.0(0))};
        \item \textit{Verbali esterni ed interni}.
    \end{itemize}


\newpage
\section{Tecnologie utilizzate}
In questa sezione vengono elencate e descritte le tecnologie utilizzate nello sviluppo, illustrando le motivazioni a sostegno di ogni scelta e le alternative scartate.

\subsection{Flask}
Flask è un micro framework per applicazioni web. È stato scelto per la sua leggerezza e la sua flessibilità, rispetto ad altri framework come Django che potrebbero risultare troppo pesanti per le esigenze del progetto.

\begin{itemize}
\item \textbf{Vantaggi:}
\begin{itemize}
\item \textbf{Leggerezza:} Flask è noto per la sua leggerezza, il che significa che ha poche dipendenze. Questo lo rende perfetto per progetti più piccoli dove non è necessario un carico pesante di funzionalità, a differenza di Django che include molte funzionalità out-of-the-box che potrebbero non essere necessarie;
\item \textbf{Flessibilità:} Flask offre una grande flessibilità, permettendo agli sviluppatori di strutturare le loro applicazioni come preferiscono, a differenza di Django che segue un approccio più rigido e strutturato;
\item \textbf{Facilità d'uso:} Flask è facile da usare e da imparare, rendendolo ideale per i principianti;
\item \textbf{Meno overhead rispetto a Django:} A causa della sua leggerezza e flessibilità, Flask può avere meno overhead rispetto a un framework più pesante come Django;
\item \textbf{Maggiore controllo rispetto a Django:} Flask offre agli sviluppatori un maggiore controllo sulle funzionalità delle loro applicazioni, a differenza di Django che fornisce molte funzionalità predefinite che potrebbero non essere necessarie o desiderate.
\end{itemize}
\item \textbf{Svantaggi:}
\begin{itemize}
\item \textbf{Manca di alcune funzionalità out-of-the-box:} Flask è un microframework, il che significa che potrebbe non avere tutte le funzionalità che potrebbero essere necessarie per un'applicazione più complessa;
\item \textbf{Potrebbe richiedere più tempo per sviluppare applicazioni complesse:} A causa della sua natura minimalista, gli sviluppatori potrebbero dover scrivere più codice per realizzare funzionalità che in altri framework potrebbero essere disponibili out-of-the-box;
\item \textbf{Richiede più configurazione rispetto a Django:} Flask richiede più configurazione rispetto ad altri framework come Django, che hanno più funzionalità integrate;
\item \textbf{Supporto della comunità più piccolo rispetto a Django:} Anche se Flask ha una comunità attiva, non è grande come quella di Django. Questo potrebbe significare meno risorse di apprendimento e supporto disponibili.
\end{itemize}
\end{itemize}
\textbf{Versione scelta:} Flask 3.0.2.

\subsubsection{Python}
Python è un linguaggio di programmazione ad alto livello, interpretato, interattivo, orientato agli oggetti e di script. È progettato per essere altamente leggibile. Rispetto ad altri linguaggi come Java o C++, Python offre una sintassi più semplice e pulita, rendendo il codice più leggibile e mantenibile.

\begin{itemize}
\item \textbf{Vantaggi:}
\begin{itemize}
\item \textbf{Facilità d'uso:} Python ha una sintassi molto pulita e facile da leggere, il che rende il linguaggio molto facile da imparare per i nuovi programmatori;
\item \textbf{Versatilità:} Python può essere utilizzato per una vasta gamma di applicazioni, tra cui sviluppo web, data analysis, machine learning, intelligenza artificiale, creazione di GUI e scripting di sistema;
\item \textbf{Grande comunità:} Python ha una grande comunità di sviluppatori che contribuiscono attivamente alla sua manutenzione e miglioramento. Ciò significa che ci sono molte risorse disponibili per l'apprendimento e la risoluzione dei problemi;
\item \textbf{Librerie ricche rispetto a Java o C++:} Python ha una vasta gamma di librerie e framework, che possono aiutare a semplificare lo sviluppo e a ridurre il tempo di sviluppo, a differenza di altri linguaggi come Java o C++ che potrebbero non avere una gamma così ampia di librerie disponibili;
\item \textbf{Sintassi più semplice rispetto a Java o C++:} Python ha una sintassi più semplice e pulita, il che rende il codice più leggibile e mantenibile rispetto a linguaggi come Java o C++.
\end{itemize}
\item \textbf{Svantaggi:}
\begin{itemize}
\item \textbf{Velocità:} Python non è il linguaggio più veloce a causa della sua natura interpretata e può non essere la scelta migliore per le applicazioni che richiedono prestazioni elevate;
\item \textbf{Gestione della memoria:} Python utilizza un garbage collector per la gestione della memoria, che può non essere efficiente come la gestione manuale della memoria in linguaggi come C++;
\item \textbf{Non è fortemente tipizzato:} A differenza di linguaggi come Java o C++, Python non è un linguaggio fortemente tipizzato. Questo può portare a errori di runtime che sarebbero stati catturati al momento della compilazione in un linguaggio fortemente tipizzato.
\end{itemize}
\end{itemize}
\textbf{Versione scelta:} Python 3.9.

\subsection{Next.js}
Next.js è un framework per applicazioni web basato su React. È stato scelto per la sua efficienza e per le sue funzionalità di rendering lato server. Rispetto ad altri framework come Angular, Next.js offre una maggiore efficienza e facilità d'uso, rendendolo ideale per questo progetto.

\begin{itemize}
\item \textbf{Vantaggi:}
\begin{itemize}
\item \textbf{Efficienza rispetto ad Angular:} Next.js è noto per la sua efficienza, il che significa che le applicazioni create con Next.js sono veloci e performanti, a differenza di Angular che può essere più pesante e meno efficiente;
\item \textbf{Rendering lato server:} Next.js offre funzionalità di rendering lato server, il che significa che può migliorare le prestazioni dell'applicazione e l'ottimizzazione dei motori di ricerca;
\item \textbf{Facilità d'uso rispetto ad Angular:} Next.js è facile da usare e da imparare, specialmente per coloro che sono già familiari con React, a differenza di Angular che può avere una curva di apprendimento più ripida;
\item \textbf{Supporto per TypeScript:} A differenza di molti altri framework, Next.js offre un supporto integrato per TypeScript, il che può migliorare l'affidabilità e la robustezza del codice.
\end{itemize}
\item \textbf{Svantaggi:}
\begin{itemize}
\item \textbf{Overhead rispetto a React da solo:} Next.js può aggiungere un certo overhead a un'applicazione a causa delle sue funzionalità aggiuntive, il che può non essere necessario per le applicazioni più semplici;
\item \textbf{Complessità:} A causa delle sue funzionalità aggiuntive, Next.js può essere più complesso da configurare e gestire rispetto a React da solo;
\item \textbf{Richiede più risorse rispetto a React da solo:} A causa delle sue funzionalità aggiuntive, Next.js può richiedere più risorse di sistema rispetto a React da solo.
\end{itemize}
\end{itemize}
\textbf{Versione scelta:} Next.js 14.1.

\subsubsection{Typescript}
Typescript è un super-set di JavaScript che aggiunge tipi statici e oggetti orientati alla programmazione. È stato scelto per la sua affidabilità e robustezza. Rispetto a JavaScript, TypeScript offre un controllo dei tipi più rigoroso, il che può aiutare a prevenire errori di runtime.

\begin{itemize}
\item \textbf{Vantaggi:}
\begin{itemize}
\item \textbf{Affidabilità rispetto a JavaScript:} Typescript offre un controllo dei tipi a tempo di compilazione, il che significa che gli errori possono essere rilevati e corretti prima dell'esecuzione, a differenza di JavaScript che è un linguaggio interpretato e gli errori possono essere rilevati solo a runtime;
\item \textbf{Robustezza:} Typescript supporta le funzionalità di programmazione orientata agli oggetti, il che può rendere il codice più robusto e facile da gestire;
\item \textbf{Interoperabilità:} Typescript è un super-set di JavaScript, il che significa che qualsiasi codice JavaScript valido può essere utilizzato in Typescript;
\item \textbf{Supporto per le annotazioni di tipo:} A differenza di JavaScript, TypeScript supporta le annotazioni di tipo, il che può migliorare la leggibilità del codice e facilitare la manutenzione.
\end{itemize}
\item \textbf{Svantaggi:}
\begin{itemize}
\item \textbf{Curva di apprendimento rispetto a JavaScript:} Typescript può essere più difficile da imparare rispetto a JavaScript a causa delle sue funzionalità aggiuntive;
\item \textbf{Compilazione:} A differenza di JavaScript, TypeScript deve essere compilato in JavaScript prima di poter essere eseguito, il che può aggiungere un passaggio aggiuntivo nel processo di sviluppo.
\end{itemize}
\end{itemize}
\textbf{Versione scelta:} Typescript 5.3.3.

\subsection{Docker}
Docker è una piattaforma open source che automatizza la distribuzione, la scalabilità e l'isolamento delle applicazioni utilizzando la virtualizzazione a livello di sistema operativo. È stato scelto per la sua efficienza e portabilità. Rispetto ad altre soluzioni come Vagrant, Docker offre una maggiore efficienza e facilità d'uso.

\begin{itemize}
\item \textbf{Vantaggi:}
\begin{itemize}
\item \textbf{Efficienza rispetto a Vagrant:} Docker consente di eseguire più applicazioni in modo isolato sulla stessa infrastruttura hardware, migliorando l'efficienza e riducendo i costi, a differenza di Vagrant che può richiedere più risorse di sistema;
\item \textbf{Portabilità:} Con Docker, le applicazioni e le loro dipendenze possono essere confezionate come un'unità portatile chiamata container, che può essere eseguita su qualsiasi macchina che supporti Docker;
\item \textbf{Isolamento:} Docker isola le applicazioni in container separati, il che significa che ogni applicazione può avere le proprie dipendenze e non interferire con le altre applicazioni;
\item \textbf{Supporto per la CI/CD:} Docker può essere facilmente integrato in pipeline di integrazione continua e distribuzione continua (CI/CD), il che può semplificare il processo di sviluppo e distribuzione.
\end{itemize}
\item \textbf{Svantaggi:}
\begin{itemize}
\item \textbf{Complessità rispetto a Vagrant:} Docker può aggiungere una certa complessità a un progetto a causa della necessità di gestire i container e le loro dipendenze, a differenza di Vagrant che può essere più semplice da configurare e gestire;
\item \textbf{Curva di apprendimento:} Docker ha una curva di apprendimento ripida e può richiedere un certo tempo per essere padroneggiato;
\item \textbf{Compatibilità:} Non tutti i sistemi operativi supportano Docker nativamente, il che può limitare la sua utilità in alcuni ambienti.
\end{itemize}
\end{itemize}
\textbf{Versione scelta:} Docker Desktop 4.28.0.

\subsection{Langchain}
Langchain è un framework che facilita l'interazione tra modelli di apprendimento automatico e risorse esterne come database o altri servizi web. È stato scelto per la sua comodità e flessibilità. Rispetto ad altri framework come TensorFlow o PyTorch, Langchain offre una maggiore facilità d'uso e una migliore integrazione con le risorse esterne.

\begin{itemize}
\item \textbf{Vantaggi:}
\begin{itemize}
\item \textbf{Comodità rispetto a TensorFlow o PyTorch:} Langchain semplifica l'interazione tra modelli di apprendimento automatico e risorse esterne, fornendo moduli e integrazioni, a differenza di TensorFlow o PyTorch che potrebbero richiedere più codice e sforzo per integrare con risorse esterne;
\item \textbf{Flessibilità:} Langchain supporta una varietà di modelli di apprendimento automatico e risorse esterne, rendendolo adatto a una vasta gamma di applicazioni;
\item \textbf{Facilità d'uso rispetto a TensorFlow o PyTorch:} Langchain è facile da usare e da imparare, rendendolo ideale per i principianti, a differenza di TensorFlow o PyTorch che possono avere una curva di apprendimento più ripida;
\item \textbf{Supporto per una varietà di risorse esterne:} A differenza di molti altri framework, Langchain offre un supporto integrato per una varietà di risorse esterne, il che può semplificare lo sviluppo e l'integrazione.
\end{itemize}
\item \textbf{Svantaggi:}
\begin{itemize}
\item \textbf{Limitazioni:} Non tutte le funzionalità sono disponibili in tutte le lingue supportate da Langchain;
\item \textbf{Documentazione:} La documentazione di Langchain potrebbe non essere così completa o aggiornata come quella di altri framework.
\end{itemize}
\end{itemize}
\textbf{Versione scelta:} Langchain 0.1.9.

\subsubsection{Pinecone}
Pinecone è un database di vettori che consente di effettuare ricerche di similarità su larga scala. È stato scelto per la sua efficienza e precisione. Rispetto ad altri database di vettori come Faiss o Annoy, Pinecone offre una maggiore efficienza e una migliore precisione nelle ricerche di similarità.

\begin{itemize}
\item \textbf{Vantaggi:}
\begin{itemize}
\item \textbf{Efficienza rispetto a Faiss o Annoy:} Pinecone è progettato per effettuare ricerche di similarità su larga scala in modo efficiente, a differenza di Faiss o Annoy che potrebbero non essere ottimizzati per ricerche su larga scala;
\item \textbf{Precisione rispetto a Faiss o Annoy:} Pinecone offre un'alta precisione nelle ricerche di similarità, il che lo rende ideale per applicazioni che richiedono un alto grado di precisione, a differenza di Faiss o Annoy che potrebbero non offrire la stessa precisione;
\item \textbf{Facilità d'uso:} Pinecone è facile da usare e da imparare, rendendolo ideale per i principianti;
\item \textbf{Scalabilità:} A differenza di molti altri database di vettori, Pinecone è progettato per scalare con le esigenze dell'applicazione, il che può semplificare la gestione delle risorse.
\end{itemize}
\item \textbf{Svantaggi:}
\begin{itemize}
\item \textbf{Costo rispetto a Faiss o Annoy:} Pinecone può essere costoso da utilizzare per applicazioni su larga scala, a differenza di Faiss o Annoy che sono open source e gratuiti da utilizzare;
\item \textbf{Limitazioni:} Pinecone potrebbe non supportare tutte le funzionalità di ricerca di similarità che potrebbero essere necessarie per alcune applicazioni.
\end{itemize}
\end{itemize}
\textbf{Versione scelta:} Pinecone Client 3.1.0.

\subsubsection{ChromaDB}
ChromaDB è un database di vettori locale open-source. È stato scelto per la sua integrazione con Langchain e la sua popolarità tra i database di vettori locali. Rispetto ad altri database di vettori locali come Faiss o Annoy, ChromaDB offre una migliore integrazione con Langchain e una maggiore popolarità.

\begin{itemize}
\item \textbf{Vantaggi:}
\begin{itemize}
\item \textbf{Integrazione con Langchain rispetto a Faiss o Annoy:} ChromaDB è ben integrato con Langchain, il che facilita l'interazione tra i due, a differenza di Faiss o Annoy che potrebbero richiedere più codice e sforzo per integrare con Langchain;
\item \textbf{Popolarità rispetto a Faiss o Annoy:} ChromaDB è il database di vettori locale open-source più popolare, il che significa che ha una grande comunità di sviluppatori e molte risorse disponibili, a differenza di Faiss o Annoy che potrebbero non avere una comunità di sviluppatori così grande;
\item \textbf{Facilità d'uso:} ChromaDB è facile da usare e da imparare, rendendolo ideale per i principianti;
\item \textbf{Supporto per una varietà di tipi di dati:} A differenza di molti altri database di vettori, ChromaDB supporta una varietà di tipi di dati, il che può semplificare la gestione dei dati.
\end{itemize}
\item \textbf{Svantaggi:}
\begin{itemize}
\item \textbf{Limitazioni:} Non tutte le funzionalità sono disponibili in tutte le lingue supportate da ChromaDB;
\item \textbf{Documentazione:} La documentazione di ChromaDB potrebbe non essere così completa o aggiornata come quella di altri database.
\end{itemize}
\end{itemize}
\textbf{Versione scelta:} ChromaDB 0.4.24.

\subsubsection{OpenAI}
OpenAI è una piattaforma di apprendimento automatico che offre una varietà di modelli, tra cui GPT-3 e GPT-4. La scelta di utilizzare OpenAI sia per il Large Language Model (LLM) che per gli embeddings è motivata dalla sua reputazione consolidata nel campo dell'apprendimento automatico e dalla sua completa integrazione con Langchain. Rispetto all’addestramento di modelli personalizzati con TensorFlow o PyTorch, l’utilizzo dei modelli pre-addestrati di OpenAI offre una maggiore facilità d’uso.

\begin{itemize}
\item \textbf{Vantaggi:}
\begin{itemize}
\item \textbf{Popolarità rispetto a TensorFlow o PyTorch:} OpenAI è molto conosciuto nel campo dell'apprendimento automatico, il che significa che ha una grande comunità di sviluppatori e molte risorse disponibili, a differenza di TensorFlow o PyTorch che potrebbero non avere una comunità di sviluppatori così grande;
\item \textbf{Integrazione:} OpenAI ha un'integrazione completa con Langchain, il che facilita l'interazione tra i due, a differenza di TensorFlow o PyTorch che potrebbero richiedere più codice e sforzo per integrare con Langchain;
\item \textbf{Flessibilità:} OpenAI offre la possibilità di scegliere tra diversi modelli semplicemente cambiando un parametro, a seconda delle esigenze e della disponibilità dell'utente finale.
\end{itemize}
\item \textbf{Svantaggi:}
\begin{itemize}
\item \textbf{Costo:} L'utilizzo di OpenAI può essere costoso, soprattutto per le applicazioni su larga scala, a differenza di TensorFlow o PyTorch che sono open source e gratuiti da utilizzare;
\item \textbf{Limitazioni:} Non tutte le funzionalità sono disponibili in tutti i modelli offerti da OpenAI.
\end{itemize}
\end{itemize}
\textbf{Versione modello LLM scelto:} gpt-3.5-turbo-instruct. \\
\textbf{Versione modello di embeddings scelto:} text-embedding-3-small.

\subsubsection{HuggingFace}
HuggingFace è una piattaforma di apprendimento automatico che offre migliaia di modelli open-source, tra cui modelli di linguaggio e modelli di embeddings. La decisione di utilizzare HuggingFace sia per il Large Language Model (LLM) che per gli embeddings è motivata dalla sua flessibilità e dalla possibilità di scaricare i modelli localmente per l’esecuzione offline. Questo offre una maggiore flessibilità rispetto all’addestramento di modelli personalizzati con TensorFlow o PyTorch, che può richiedere risorse computazionali significative e competenze specialistiche.

\begin{itemize}
\item \textbf{Vantaggi:}
\begin{itemize}
\item \textbf{Flessibilità:} HuggingFace offre una vasta gamma di modelli, il che significa che è possibile scegliere il modello più adatto alle proprie esigenze, a differenza di TensorFlow o PyTorch che potrebbero richiedere la configurazione e l'addestramento di modelli personalizzati;
\item \textbf{Località:} HuggingFace offre la possibilità di scaricare i modelli in locale, il che significa che possono essere eseguiti sulle proprie macchine senza la necessità di una connessione internet;
\item \textbf{Facilità d'uso rispetto a TensorFlow o PyTorch:} HuggingFace è facile da usare e da imparare, rendendolo ideale per i principianti, a differenza di TensorFlow o PyTorch che possono avere una curva di apprendimento più ripida.
\end{itemize}
\item \textbf{Svantaggi:}
\begin{itemize}
\item \textbf{Risorse rispetto a TensorFlow o PyTorch:} L'esecuzione dei modelli in locale può richiedere molte risorse hardware, il che può non essere ideale per tutte le macchine, a differenza di TensorFlow o PyTorch che possono essere ottimizzati per l'esecuzione su hardware specifico;
\item \textbf{Complessità:} A causa della vasta gamma di modelli disponibili, può essere difficile scegliere il modello più adatto alle proprie esigenze.
\end{itemize}
\end{itemize}
\textbf{Versione modello LLM scelto:} meta-llama/Llama-2-7b-chat-hf. \\
\textbf{Versione modello di embeddings scelto:} sentence-transformers/all-mpnet-base-v2.

\subsection{AWS S3}
Amazon S3 (Simple Storage Service) è un servizio di storage di oggetti offerto da Amazon Web Services. È stato scelto per la sua scalabilità, affidabilità, e sicurezza. Rispetto ad altre soluzioni di storage come Google Cloud Storage o Azure Blob Storage, AWS S3 offre una maggiore scalabilità e una migliore integrazione con altri servizi AWS.

\begin{itemize}
\item \textbf{Vantaggi:}
\begin{itemize}
\item \textbf{Scalabilità rispetto a Google Cloud Storage o Azure Blob Storage:} Amazon S3 può memorizzare qualsiasi quantità di dati e servire qualsiasi livello di traffico richiesto, a differenza di Google Cloud Storage o Azure Blob Storage che potrebbero avere limiti sulla quantità di dati o sul traffico;
\item \textbf{Affidabilità:} Amazon S3 offre una durabilità dell'11 9's, il che significa che i dati sono estremamente sicuri, a differenza di Google Cloud Storage o Azure Blob Storage che potrebbero non offrire lo stesso livello di durabilità;
\item \textbf{Sicurezza rispetto a Google Cloud Storage o Azure Blob Storage:} Amazon S3 offre potenti funzionalità per proteggere i dati, tra cui controllo degli accessi, crittografia in transito e a riposo, e altro ancora, a differenza di Google Cloud Storage o Azure Blob Storage che potrebbero non offrire le stesse funzionalità di sicurezza.
\end{itemize}
\item \textbf{Svantaggi:}
\begin{itemize}
\item \textbf{Costo rispetto a Google Cloud Storage o Azure Blob Storage:} Il costo di Amazon S3 può aumentare rapidamente con l'aumentare dell'uso, a differenza di Google Cloud Storage o Azure Blob Storage che potrebbero avere costi più prevedibili;
\item \textbf{Complessità:} Amazon S3 ha molte funzionalità e opzioni, il che può renderlo complesso da configurare e gestire, a differenza di Google Cloud Storage o Azure Blob Storage che potrebbero essere più semplici da configurare e gestire.
\end{itemize}
\end{itemize}
\textbf{Versione scelta:} Amazon Simple Storage Service (Amazon S3).

\subsection{Postgres}
Postgres, o PostgreSQL, è un potente sistema di gestione di database relazionali ad oggetti open source. È stato scelto per la sua robustezza, affidabilità e flessibilità. Rispetto ad altri DBMS come MySQL o SQLite, Postgres offre una maggiore robustezza e una migliore supporto per le funzionalità di programmazione orientata agli oggetti.

\begin{itemize}
\item \textbf{Vantaggi:}
\begin{itemize}
\item \textbf{Robustezza rispetto a MySQL o SQLite:} Postgres supporta una vasta gamma di tipi di dati nativi, operatori e funzioni, tra cui JSON, XML e array, a differenza di MySQL o SQLite che potrebbero non supportare tutti questi tipi di dati;
\item \textbf{Affidabilità:} Postgres è noto per la sua affidabilità e integrità dei dati. Offre transazioni atomiche, commit multi-versione (MVCC), punti di controllo, logging di scrittura anticipata (WAL) e una serie di meccanismi di replica, a differenza di MySQL o SQLite che potrebbero non offrire tutte queste funzionalità;
\item \textbf{Flessibilità rispetto a MySQL o SQLite:} Postgres è estensibile, il che significa che gli sviluppatori possono definire i propri tipi di dati, operatori e funzioni. Inoltre, può essere utilizzato sia come un database SQL tradizionale che come una soluzione NoSQL per la memorizzazione di documenti, a differenza di MySQL o SQLite che potrebbero non offrire la stessa flessibilità.
\end{itemize}
\item \textbf{Svantaggi:}
\begin{itemize}
\item \textbf{Complessità rispetto a MySQL o SQLite:} A causa della sua vasta gamma di funzionalità, Postgres può essere più complesso da configurare e gestire rispetto ad altri sistemi di gestione di database come MySQL o SQLite;
\item \textbf{Prestazioni:} Sebbene Postgres sia altamente ottimizzato, le sue prestazioni potrebbero non essere all'altezza di altri database per alcune applicazioni, in particolare quelle che richiedono letture ad alta velocità di grandi quantità di dati.
\end{itemize}
\end{itemize}
\textbf{Versione scelta:} PostgreSQL 16.2.

\newpage
\section{Architettura di sistema}
\subsection{Modello architetturale}
Il sistema è progettato seguendo l'\textbf{architettura esagonale}, un modello architetturale che mira a creare una separazione netta tra la business logic dell'applicazione e i servizi esterni, le fonti di dati e le interfacce utente con cui interagisce.
Questa struttura organizzativa posiziona il nucleo al centro, circondato da "porte" che fungono da interfaccia tra il nucleo e il mondo esterno.

Il \textbf{nucleo} dell'applicazione è il fulcro del sistema, contenente la logica di dominio e le regole di business. La sua progettazione mira a evitare riferimenti diretti a dettagli tecnologici specifici, promuovendo l'indipendenza dal contesto esterno.

Le \textbf{porte} costituiscono il confine tra il nucleo dell'applicazione e il mondo esterno, consentendo una comunicazione strutturata. Esistono due tipi principali di porte:
\begin{itemize}
    \item Inbound Port (o \textbf{Use Case}): consentono al nucleo di essere invocato da componenti esterni attraverso un'interfaccia definita. Rappresentano i punti di accesso al nucleo e isolano la logica di dominio da implementazioni specifiche;
    \item Outbound Port: consentono al nucleo di accedere a funzionalità esterne, come l'interazione con librerie esterne o sistemi di persistenza. Forniscono un'astrazione che preserva l'indipendenza del nucleo da dettagli tecnologici specifici.  
\end{itemize}

I \textbf{services} implementano le inbound port dell'applicazione e fanno parte della business logic. La loro implementazione è concentrata sulla logica di dominio, senza preoccuparsi degli aspetti tecnologici specifici.

Gli \textbf{adapters} costituiscono il livello più esterno dell'applicazione. Esistono due tipi di adapters:
\begin{itemize}
    \item Input Adapters (o \textbf{Controllers}): sono responsabili di invocare operazioni sulle porte in ingresso. Traducono le azioni provenienti dall'esterno in chiamate alle porte in ingresso del nucleo, facilitando la traduzione delle richieste esterne in operazioni comprensibili per il nucleo;
    \item Output Adapters: gestiscono le porte in uscita, traducendo le azioni del nucleo in operazioni comprensibili per il mondo esterno.
\end{itemize}

\subsection{Descrizione delle componenti}
L'architettura generale del sistema è composta da due componenti: frontend e backend.

\subsubsection{Frontend}
Il frontend si occupa di fornire un'interfaccia grafica all'utente per dialogare con il sistema. Inoltra le richieste dell'utente al backend e mostra i risultati ottenuti.
%TODO: approfondire

\subsubsection{Backend}
Il backend si occupa di elaborare le richieste degli utenti, interagendo con i sistemi di persistenza e i servizi esterni.
In particolare, il backend dialoga con il sistema di archiviazione documenti, il vector store, il database delle chat e con i modelli di intelligenza artificiale necessari per il corretto funzionamento dell'applicazione.
%TODO: approfondire

\subsection{Assemblaggio delle componenti}
Le componenti sono assemblate insieme utilizzando Docker Compose. In particolare sono prodotti i
seguenti container Docker:

\begin{itemize}
    \item \textbf{db}: espone l'istanza del database chat nella porta 3000, abilitando il dialogo con il backend;
    \item \textbf{backend}: espone la componente backend nella porta 4000, dando al frontend la possibilità di chiamare le API offerte;
    \item \textbf{frontend}: espone il frontend dell'applicazione web nella porta 80, dando la possibilità all'utente di connettersi e interagire con il sistema.
\end{itemize}

\subsection{Struttura del sistema}

\subsubsection{Frontend}
La struttura organizzativa del frontend segue la struttura standard definita dal framework Next.js.
% TODO: approfondire

\subsubsection{Backend}
La struttura organizzativa del backend segue la seguente struttura:
\code{
\begin{tabbing}
    /backend\=\\
    \> /adapter\=\\
    \> \> /in\=\\
    \> \> \> /web -- controllers\\
    \> \> /out -- implementazioni di Outbound Port\\
    \> /application\\
    \> \> /port\\
    \> \> \> /in -- Inbound Ports (Use Cases)\\
    \> \> \> /out -- Outbound Ports\\
    \> \> \> /service -- implementazioni di Inbound Port\\
    \> /domain -- classi di business
\end{tabbing}
}
Questa struttura riflette il modello architetturale scelto, facilitando il passaggio da progettazione a codifica.


\newpage
\section{Architettura delle componenti} % architettura interna di ciascuna componente
\subsection{Frontend}
% - X ogni componente frontend:
    % - definizione e utilità
    % - route API
    % - elementi grafici (anche a seguito di azioni)
    % - tracciamento requisiti soddisfatti
% - Requisiti implementativi

    %- X ogni sottocomponente della componente:
    %     - nome: definizione e utilità (componente che serve a ...)

\subsection{Backend}
% - X ogni componente backend:
    % - definizione e utilità
    % - route API
    % - metodo HTTP
    % - parametri richiesta HTTP
    % - tabella possibili risposte (status code, condizione, tipo di ritorno(header o body))
    % - tracciamento requisiti soddisfatti
    
    % - X ogni sottocomponente della componente:
    %     - nome: definizione e utilità (interfaccia/classe che serve a ...)
    %     - se sono classi, indicare "interfacce implementate" e/o "classi astratte estese"

\subsubsection{AskChatbot}
\subsubsubsection{Descrizione}
Questa componente ha il compito di ottenere una risposta ad un messaggio da parte del chatbot.
È costituita da:
\begin{itemize}
    \item \textbf{Route API}: /askChatbot;
    \item \textbf{Metodo}: POST;
    \item \textbf{Lista parametri HTTP}: 
    \begin{itemize}
        \item "message": messaggio da parte dell'utente;
        \item "chatId": id della chat a cui appartiene il messaggio.
    \end{itemize}
\end{itemize}
\subsubsubsection{Esiti possibili}
\begin{xltabular}{\textwidth}{c|X|X}
\caption{Esiti possibili AskChatbot}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endfirsthead
\caption[]{Esiti possibili AskChatbot (cont)}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endhead
\multicolumn{3}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
200 & Risposta ottenuta con successo. & - \\
\hline
500 & Risposta del chatbot fallita. & Errore di generazione della risposta del chatbot. \\
\end{xltabular}

\subsubsubsection{Tracciamento dei requisiti}
\begin{itemize}
        \item RF.D.40;
        \item RF.O.47.1;
        \item RF.O.48.
\end{itemize}

\subsubsubsection{Lista sottocomponenti}
\begin{itemize}
    \item \label{AskChatbotController}\textbf{AskChatbotController}: classe controller che si occupa del richiedere una risposta al chatbot ad un messaggio appartente ad una chat allo use case AskChatbotUseCase;
    \item \label{Message}\textbf{Message}: classe di business che rappresenta un messaggio di una chat;
    \item \label{MessageSender}\textbf{MessageSender}: classe di business che rappresenta il mittente di un messaggio;
    \item \label{AskChatbotUseCase}\textbf{AskChatbotUseCase}: interfaccia use case che rappresenta la porta della business logic in entrata per richiedere una risposta al chatbot ad un messaggio appartente ad una chat;
    \item \label{AskChatbotService}\textbf{AskChatbotService}: classe service che implementa lo use case AskChatbotUseCase;
    \item \label{ChatId}\textbf{ChatId}: classe di business che rappresenta l'id di una chat utilizzato nella ricerca;
    \item \label{AskChatbotPort}\textbf{AskChatbotPort}: interfaccia che rappresenta la porta in uscita per effettuare la richiesta di una risposta al chatbot ad un messaggio appartente ad una chat, con storicizzazione all'interno del database delle chat;
    \item \label{AskChatbotLangchain}\textbf{AskChatbotLangchain}: classe che implementa la porta AskChatbotPort, adattando la chiamata di AskChatbotService a classi offerte dal framework Langchain;
    \item \label{ChatHistoryManager}\textbf{ChatHistoryManager}: classe per interagire con le chat come oggetti lanchain.Memory;
    \item \label{ChatbotLangchain}\textbf{ChatbotLangchain}: classe che permette di interagire con un oggetto langchain.Chain;
    \item \label{LangchainLLM}\textbf{LangchainLLM}: classe astratta che permette di interagire con un oggetto langchain.BaseLanguageModel;
    \item \label{OpenAILLM}\textbf{OpenAILLM}: classe che implementa la classe astratta LangchainLLM per interagire con un modello LLM di OpenAI;
    \item \label{HugginFaceLLM}\textbf{HugginFaceLLM}: classe che implementa la classe astratta LangchainLLM per interagire con un modello LLM di HugginFace;
    \item \label{LangchainVectorStore}\textbf{LangchainVectorStore}: classe astratta che permette di interagire con un oggetto langchain.VectorStore;
    \item \label{PineconeVectorStore}\textbf{PineconeVectorStore}: classe che implementa la classe astratta LangchainVectorStore per interagire con un vector store Pinecone;
    \item \label{ChromaDBVectorStore}\textbf{ChromaDBVectorStore}: classe che implementa la classe astratta LangchainVectorStore per interagire con un vector store ChromaDB;
    \item \label{LangchainEmbeddingModel}\textbf{LangchainEmbeddingModel}: classe astratta che permette di interagire con un oggetto langhchain.Embeddings;
    \item \label{OpenAIEmbeddingModel}\textbf{OpenAIEmbeddingModel}: classe che implementa la classe astratta LangchainEmbeddingModel per interagire con un modello di generazione di embeddings di OpenAI;
    \item \label{HuggingFaceEmbeddingModel}\textbf{HuggingFaceEmbeddingModel}: classe che implementa la classe astratta LangchainEmbeddingModel per interagire con un modello di generazione di embeddings di HugginFace;
    \item \label{PostgresORM}\textbf{PostgresORM}: classe che si occupa di effettuare le operazioni su Postgres configurato, cioè il sistema di storicizzazione delle chat dell'applicazione;
    \item \label{PostgresChat}\textbf{PostgresChat}: classe di persistence che rappresenta una chat;
    \item \label{PostgresMessage}\textbf{PostgresMessage}: classe di persistence che rappresenta un messaggio.
\end{itemize}

\begin{comment}
\subsubsection{ChangeConfiguration} %TODO
\subsubsubsection{Descrizione}
Questa componente ha il compito di cambiare la configurazione del sistema.
È costituita da:
\begin{itemize}
    \item \textbf{Route API}: /changeConfiguration;
    \item \textbf{Metodo}: POST;
    \item \textbf{Lista parametri HTTP}: 
    \begin{itemize}
        \item "LLMModel": stringa che rappresenta il modello LLM da configurare.
    \end{itemize}
\end{itemize}
\subsubsubsection{Esiti possibili}
\begin{xltabular}{\textwidth}{c|X|X}
\caption{Esiti possibili ChangeConfiguration}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endfirsthead
\caption[]{Esiti possibili ChangeConfiguration (cont)}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endhead
\multicolumn{3}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
200 & Configurazione avvenuta con successo. & - \\
\hline
500 & Configurazione fallita. & Errore nella configurazione. \\
\end{xltabular}

\subsubsubsection{Tracciamento dei requisiti}
\begin{itemize}
        \item TODO.
\end{itemize}

\subsubsubsection{Lista sottocomponenti}
\begin{itemize}
    \item 
\end{itemize}
\end{comment}

\subsubsection{ConcealDocuments}
\subsubsubsection{Descrizione}
Questa componente ha il compito di occultare gli embeddings dei documenti indicati dall'utente.
È costituita da:
\begin{itemize}
    \item \textbf{Route API}: /concealDocuments;
    \item \textbf{Metodo}: POST;
    \item \textbf{Lista parametri HTTP}: 
    \begin{itemize}
        \item "documentIds": una lista di stringhe che rappresentano gli id dei documenti da occultare.
    \end{itemize}
\end{itemize}
\subsubsubsection{Esiti possibili}
\renewcommand{\arraystretch}{1.5}
\begin{xltabular}{\textwidth}{c|X|X}
\caption{Esiti possibili ConcealDocuments}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endfirsthead
\caption[]{Esiti possibili ConcealDocuments (cont)}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endhead
\multicolumn{3}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
200 & Occultamento avvenuto con successo. & - \\
\hline
500 & Occultamento fallito. & Errore nell'occultamento dei documenti.
\end{xltabular}

\subsubsubsection{Tracciamento dei requisiti}
\begin{itemize}
    \item RF.O.25;
    \item RF.O.26.
\end{itemize}

\subsubsubsection{Lista sottocomponenti}
\begin{itemize}
    \item \label{ConcealDocumentsController}\textbf{ConcealDocumentsController}: classe controller che si occupa del passaggio di una lista di DocumentId allo use case ConcealDocumentsUseCase a partire da una lista di stringhe che rappresentano l'id dei documenti da occultare;
    \item \label{ConcealDocumentsUseCase}\textbf{ConcealDocumentsUseCase}: interfaccia use case che rappresenta la porta della business logic in entrata per effettuare l'occultamento dei documenti;
    \item \label{ConcealDocumentsService}\textbf{ConcealDocumentsService}: classe service che implementa lo use case ConcealDocumentsUseCase;
    \item \label{ConcealDocumentsPort}\textbf{ConcealDocumentsPort}: interfaccia che rappresenta la porta in uscita per effettuare l'occultamento dei documenti nel vector store;
    \item \label{ConcealDocumentsVectorStore}\textbf{ConcealDocumentsVectorStore}: classe adapter che implementa la porta ConcealDocumentsPort, adattando la chiamata di ConcealDocumentsService a VectorStoreManager;
    \item \label{VectorStoreManager}\textbf{VectorStoreManager}: interfaccia che rende disponibile metodi per dialogare con i vector store;
    \item \label{VectorStorePineconeManager}\textbf{VectorStorePineconeManager}: classe che implementa VectorStoreManager, offrendo la possibilità di dialogare con il vector store Pinecone;
    \item \label{VectorStoreChromaDBManager}\textbf{VectorStoreChromaDBManager}: classe che implementa VectorStoreManager,  offrendo la possibilità di dialogare con il vector store Chroma;
    \item \label{VectorStoreDocumentOperationResponse}\textbf{VectorStoreDocumentOperationResponse}: classe che contiene l'esito di un'operazione effettuata su un vector store riguardo un documento.
\end{itemize}

\subsubsection{DeleteChats}
\subsubsubsection{Descrizione}
Questa componente ha il compito di eliminare una lista di chat, aggiornando di conseguenza il database utilizzato per la storicizzazione delle chat.
È costituita da:
\begin{itemize}
    \item \textbf{Route API}: /deleteChats;
    \item \textbf{Metodo}: POST;
    \item \textbf{Lista parametri HTTP}: 
    \begin{itemize}
        \item "chatIds": lista di Id utilizzati per identificare univocamente le chat.
    \end{itemize}
\end{itemize}
\subsubsubsection{Esiti possibili}
\renewcommand{\arraystretch}{1.5}
\begin{xltabular}{\textwidth}{c|X|X}
\caption{Esiti possibili DeleteChats}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endfirsthead
\caption[]{Esiti possibili DeleteChats (cont)}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endhead
\multicolumn{3}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
200 & Eliminazione avvenuta con successo. & - \\
\hline
500 & Eliminazione fallita. & Errore nella eliminazione della chat. \\
\end{xltabular}

\subsubsubsection{Tracciamento dei requisiti}
\begin{itemize}
        \item RF.O.33
        \item RF.O.34
        \item RF.O.34.1
\end{itemize}

\subsubsubsection{Lista sottocomponenti}
\begin{itemize}
    \item \label{DeleteChatsController}\textbf{DeleteChatsController}: classe controller che si occupa del passaggio allo use case CreateChatUseCase di interi rappresentanti gli id di una lista di chat per eseguire la loro eliminazione;
    \item \label{DeleteChatsUseCase}\textbf{DeleteChatsUseCase}: interfaccia use case che rappresenta la porta della business logic in entrata per effettuare l'eliminazione di una lista di chat;
    \item \label{DeleteChatsService}\textbf{DeleteChatsService}: classe service che implementa lo use case DeleteChatsUseCase;
    \item \label{DeleteChatsPort}\textbf{DeleteChatsPort}: interfaccia che rappresenta la porta in uscita per effettuare l'eliminazione di una lista di chat verso il database per la storicizzazione delle chat;
    \item \label{DeleteChatsPostgres}\textbf{DeleteChatsPostgres}: classe che implementa la porta DeleteChatPort, adattando la chiamata di DeleteChatsService a PostgresORM;
    \item \textbf{PostgresORM}: vedi \vedi{PostgresORM}.
\end{itemize}

\subsubsection{DeleteDocuments}
\subsubsubsection{Descrizione}
Questa componente ha il compito di eliminare una lista di documenti e i loro rispettivi embeddings.
È costituita da:
\begin{itemize}
    \item \textbf{Route API}: /deleteDocuments;
    \item \textbf{Metodo}: POST;
    \item \textbf{Lista parametri HTTP}: 
    \begin{itemize}
        \item "documentIds": una lista di stringhe che rappresentano gli id dei documenti da eliminare.
    \end{itemize}
\end{itemize}
\subsubsubsection{Esiti possibili}
\renewcommand{\arraystretch}{1.5}
\begin{xltabular}{\textwidth}{c|X|X}
\caption{Esiti possibili DeleteDocuments}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endfirsthead
\caption[]{Esiti possibili DeleteDocuments (cont)}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endhead
\multicolumn{3}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
200 & Eliminazione avvenuta con successo. & - \\
\hline
500 & Eliminazione fallita. & Errore nell'eliminazione dei documenti.
\end{xltabular}

\subsubsubsection{Tracciamento dei requisiti}
\begin{itemize}
    \item TODO.
\end{itemize}

\subsubsubsection{Lista sottocomponenti}
\begin{itemize}
    \item \label{DeleteDocumentsController}\textbf{DeleteDocumentsController}: classe controller che si occupa del passaggio di una lista di DocumentId allo use case DeleteDocumentsUseCase a partire da una lista di stringhe che rappresentano gli id dei documenti da eliminare;
    \item \label{DeleteDocumentsUseCase}\textbf{DeleteDocumentsUseCase}: interfaccia use case che rappresenta la porta della business logic in entrata per eliminare i documenti;
    \item \label{DeleteDocumentsService}\textbf{DeleteDocumentsService}: classe service che implementa lo use case DeleteDocumentsUseCase;
    \item \label{DeleteDocuments}\textbf{DeleteDocuments}: classe che si occupa di inoltrare la richiesta di eliminare una lista di documenti nella porta esterna DeleteDocumentsPort diretta verso il sistema di archiviazione;
    \item \label{DeleteDocumentsEmbeddings}\textbf{DeleteDocumentsEmbeddings}: classe che si occupa di eliminare gli embeddings di una lista di documenti nella porta esterna DeleteEmbeddingsPort diretta verso il vector store;
    \item \label{DeleteDocumentsPort}\textbf{DeleteDocumentsPort}: interfaccia che rappresenta la porta in uscita per eliminare una lista di documenti dal sistema di archiviazione;
    \item \label{DeleteEmbeddingsPort}\textbf{DeleteEmbeddingsPort}: interfaccia che rappresenta la porta in uscita per eliminare gli embeddings di una lista di documenti dal vector store;
    \item \textbf{DocumentOperationResponse}: vedi \vedi{DocumentOperationResponse};
    \item \label{DeleteDocumentsAWSS3}\textbf{DeleteDocumentsAWSS3}: classe adapter che implementa la porta DeleteDocumentsPort, adattando la chiamata di DeleteDocuments a AWSS3Manager;
    \item \label{AWSS3Manager}\textbf{AWSS3Manager}: classe che si occupa di effettuare le operazioni sul bucket di Amazon S3 configurato, cioè il sistema di archiviazione documenti dell'applicazione;
    \item \label{AWSDocumentOperationResponse}\textbf{AWSDocumentOperationResponse}: classe che contiene l'esito di un'operazione effettuata su un AWS S3 riguardo un documento;
    \item \label{DeleteEmbeddingsVectorStore}\textbf{DeleteEmbeddingsVectorStore}: classe adapter che implementa la porta DeleteEmbeddingsPort, adattando la chiamata di DeleteDocumentsEmbeddings a VectorStoreManager;
    \item \textbf{VectorStoreManager}: vedi \vedi{VectorStoreManager};
    \item \textbf{VectorStorePineconeManager}: vedi \vedi{VectorStorePineconeManager};
    \item \textbf{VectorStoreChromaDBManager}: vedi \vedi{VectorStoreChromaDBManager};
    \item \textbf{VectorStoreDocumentOperationResponse}: vedi \vedi{VectorStoreDocumentOperationResponse}.
\end{itemize}

\subsubsection{EmbedDocuments}
\subsubsubsection{Descrizione}
Questa componente ha il compito di generare e memorizzare gli embeddings dei documenti indicati dall'utente.
È costituita da:
\begin{itemize}
    \item \textbf{Route API}: /embedDocuments;
    \item \textbf{Metodo}: POST;
    \item \textbf{Lista parametri HTTP}: 
    \begin{itemize}
        \item "documentIds": una lista di stringhe che rappresentano gli id dei documenti di cui generare gli embeddings.
    \end{itemize}
\end{itemize}
\subsubsubsection{Esiti possibili}
\renewcommand{\arraystretch}{1.5}
\begin{xltabular}{\textwidth}{c|X|X}
\caption{Esiti possibili EmbedDocuments}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endfirsthead
\caption[]{Esiti possibili EmbedDocuments (cont)}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endhead
\multicolumn{3}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
200 & Generazione embeddings avvenuta con successo. & - \\
\hline
500 & Generazione embeddings fallita. & Errore nella generazione degli embeddings.
\end{xltabular}

\subsubsubsection{Tracciamento dei requisiti}
\begin{itemize}
    \item TODO.
\end{itemize}

\subsubsubsection{Lista sottocomponenti}
\begin{itemize}
    \item \label{EmbedDocumentsController}\textbf{EmbedDocumentsController}: classe controller che si occupa del passaggio di una lista di DocumentId allo use case EmbedDocumentsUseCase a partire da una lista di stringhe che rappresentano l'id dei documenti di cui generare gli embeddings;
    \item \label{EmbedDocumentsUseCase}\textbf{EmbedDocumentsUseCase}: interfaccia use case che rappresenta la porta della business logic in entrata per generare gli embeddings dei documenti;
    \item \label{EmbedDocumentsService}\textbf{EmbedDocumentsService}: classe service che implementa lo use case EmbedDocumentsUseCase;
    \item \label{GetDocuments}\textbf{GetDocuments}: classe che si occupa di inoltrare la richiesta di recuperare i documenti nella porta esterna diretta verso il sistema di archiviazione;
    \item \label{EmbeddingsUploader}\textbf{EmbeddingsUploader}: classe che si occupa di effettuare la chiamata dell'upload degli embeddings nella porta esterna diretta verso il vector store;
    \item \label{GetDocumentsPort}\textbf{GetDocumentsPort}: interfaccia che rappresenta la porta in uscita per recuperare i documenti dal sistema di archiviazione;
    \item \label{EmbeddingsUploaderPort}\textbf{EmbeddingsUploaderPort}: interfaccia che rappresenta la porta in uscita per effettuare l'upload degli embeddings verso i vector store;
    \item \label{GetDocumentsAWSS3}\textbf{GetDocumentsAWSS3}: classe adapter che implementa la porta GetDocumentsPort, adattando la chiamata di GetDocuments a AWSS3Manager;
    \item \textbf{AWSS3Manager}: vedi \vedi{AWSS3Manager};
    \item \label{AWSDocument}\textbf{AWSDocument}: classe che rappresenta i documenti gestibili da AWSS3Manager;
    \item \label{DocumentOperationResponse}\textbf{DocumentOperationResponse}: classe che contiene l'esito di un'operazione effettuata su un documento;
    \item \label{LangchainDocument}\textbf{LangchainDocument}: classe che rappresenta un documento e i suoi embeddings;
    \item \label{EmbeddingsUploaderFacadeLangchain}\textbf{EmbeddingsUploaderFacadeLangchain}: classe adapter che implementa la porta EmbeddingsUploaderPort, adattando la chiamata di EmbeddingsUploader alla sequenza di operazioni necessarie per il calcolo degli embeddings e il loro upload nel vector store;
    \item \label{DocumentToText}\textbf{DocumentToText}: classe che si occupa di convertire documenti;
    \item \label{TextExtractor}\textbf{TextExtractor}: interfaccia che espone il metodo astratto di estrazione di testo da un documento;
    \item \label{PDFTextExtractor}\textbf{PDFTextExtractor}: classe che implementa l'interfaccia TextExtractor, offrendo un metodo per l'estrazione di testo da documenti PDF;
    \item \label{DOCXTextExtractor}\textbf{DOCXTextExtractor}: classe che implementa l'interfaccia TextExtractor, offrendo un metodo per l'estrazione di testo da documenti docx;
    \item \label{Chunkerizer}\textbf{Chunkerizer}: classe che crea chunks a partire da testo;
    \item \label{EmbeddingsCreator}\textbf{EmbeddingsCreator}: classe che dialoga con il modello di embeddings per creare gli embeddings a partire dai chunk forniti in input;
    \item \textbf{LangchainEmbeddingModel}: vedi \vedi{LangchainEmbeddingModel};
    \item \textbf{OpenAIEmbeddingModel}: vedi \vedi{OpenAIEmbeddingModel};
    \item \textbf{HuggingFaceEmbeddingModel}: classe che implementa LangchainEmbeddingModel offrendo la possibilità di creare embeddings attraverso un embedding model di HuggingFace;
    \item \label{EmbeddingsUploaderVectorStore}\textbf{EmbeddingsUploaderVectorStore}: classe che offre un metodo per eseguire l'upload degli embeddings nel vector store;
    \item \textbf{VectorStoreManager}: vedi \vedi{VectorStoreManager};
    \item \textbf{VectorStorePineconeManager}: vedi \vedi{VectorStorePineconeManager};
    \item \textbf{VectorStoreChromaDBManager}: vedi \vedi{VectorStoreChromaDBManager};
    \item \textbf{VectorStoreDocumentOperationResponse}: vedi \vedi{VectorStoreDocumentOperationResponse}.
\end{itemize}


\subsubsection{EnableDocuments}
\subsubsubsection{Descrizione}
Questa componente ha il compito di riabilitare gli embeddings dei documenti indicati dall'utente.
È costituita da:
\begin{itemize}
    \item \textbf{Route API}: /enableDocuments;
    \item \textbf{Metodo}: POST;
    \item \textbf{Lista parametri HTTP}: 
    \begin{itemize}
        \item "documentIds": una lista di stringhe che rappresentano gli id dei documenti da riabilitare.
    \end{itemize}
\end{itemize}
\subsubsubsection{Esiti possibili}
\renewcommand{\arraystretch}{1.5}
\begin{xltabular}{\textwidth}{c|X|X}
\caption{Esiti possibili EnableDocuments}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endfirsthead
\caption[]{Esiti possibili EnableDocuments (cont)}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endhead
\multicolumn{3}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
200 & Riabilitazione avvenuta con successo. & - \\
\hline
500 & Riabilitazione fallita. & Errore nella riabilitazione dei documenti.
\end{xltabular}

\subsubsubsection{Tracciamento dei requisiti}
\begin{itemize}
    \item RF.O.25;
    \item RF.O.26.
\end{itemize}

\subsubsubsection{Lista sottocomponenti}
\begin{itemize}
    \item \label{EnableDocumentsController}\textbf{EnableDocumentsController}: classe controller che si occupa del passaggio di una lista di DocumentId allo use case EnableDocumentsUseCase a partire da una lista di stringhe che rappresentano l'id dei documenti da riabilitare;
    \item \label{EnableDocumentsUseCase}\textbf{EnableDocumentsUseCase}: interfaccia use case che rappresenta la porta della business logic in entrata per effettuare la riabilitazione dei documenti;
    \item \label{EnableDocumentsService}\textbf{EnableDocumentsService}: classe service che implementa lo use case EnableDocumentsUseCase;
    \item \label{EnableDocumentsPort}\textbf{EnableDocumentsPort}: interfaccia che rappresenta la porta in uscita per effettuare la riabilitazione dei documenti nel vector store;
    \item \label{EnableDocumentsVectorStore}\textbf{EnableDocumentsVectorStore}: classe adapter che implementa la porta EnableDocumentsPort, adattando la chiamata di EnableDocumentsService a VectorStoreManager;
    \item \textbf{VectorStoreManager}: vedi \vedi{VectorStoreManager};
    \item \textbf{VectorStorePineconeManager}: vedi \vedi{VectorStorePineconeManager};
    \item \textbf{VectorStoreChromaDBManager}: vedi \vedi{VectorStoreChromaDBManager};
    \item \textbf{VectorStoreDocumentOperationResponse}: vedi \vedi{VectorStoreDocumentOperationResponse}.
\end{itemize}

\subsubsection{GetChatMessages}
\subsubsubsection{Descrizione}
Questa componente ha il compito di ottenere una chat completa, ovvero che comprende sia le sue informazioni che i suoi messaggi.
È costituita da:
\begin{itemize}
    \item \textbf{Route API}: /getChatMessages;
    \item \textbf{Metodo}: POST;
    \item \textbf{Lista parametri HTTP}: 
    \begin{itemize}
        \item "chatId": id della chat da recuperare.
    \end{itemize}
\end{itemize}
\subsubsubsection{Esiti possibili}
\begin{xltabular}{\textwidth}{c|X|X}
\caption{Esiti possibili GetChatMessages}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endfirsthead
\caption[]{Esiti possibili GetChatMessages (cont)}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endhead
\multicolumn{3}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
200 & Chat recuperata con succcesso. & - \\
\hline
500 & Recupero della Chat fallito. & Errore nella recupero della chat. \\
\end{xltabular}

\subsubsubsection{Tracciamento dei requisiti}
\begin{itemize}
        \item RF.O.39;
        \item RF.O.39.1;
        \item RF.O.39.1.1;
        \item RF.O.39.1.2.
\end{itemize}

\subsubsubsection{Lista sottocomponenti}
\begin{itemize}
    \item \label{GetChatMessagesController}\textbf{GetChatMessagesController}: classe controller che si occupa del richiedere una chat allo use case GetChatMessagesUseCase;
    \item \textbf{ChatId}: vedi \vedi{ChatId};
    \item \label{GetChatMessagesUseCase}\textbf{GetChatMessagesUseCase}: interfaccia use case che rappresenta la porta della business logic in entrata per richiedere una chat;
    \item \label{GetChatMessagesService}\textbf{GetChatMessagesService}: classe service che implementa lo use case GetChatMessagesUseCase;
    \item \label{Chat}\textbf{Chat}: classe di business che rappresenta una chat completa;
    \item \label{ChatInfo}\textbf{ChatInfo}: classe di business che rappresenta le informazioni di una chat;
    \item \textbf{Message}: vedi \vedi{Message};
    \item \textbf{MessageSender}: vedi \vedi{MessageSender};
    \item \label{GetChatMessagesPort}\textbf{GetChatMessagesPort}: interfaccia che rappresenta la porta in uscita per effettuare la richiesta di una chat verso il database per la storicizzazione delle chat;
    \item \label{GetChatMessagesPostgres}\textbf{GetChatMessagesPostgres}: classe che implementa la porta GetChatMessagesPort, adattando la chiamata di GetChatMessagesService a PostgresORM;
    \item \textbf{PostgresORM}: vedi \vedi{PostgresORM};
    \item \textbf{PostgresChat}: vedi \vedi{PostgresChat};
    \item \textbf{PostgresMessage}: vedi \vedi{PostgresMessage};
\end{itemize}

\subsubsection{GetChats}
\subsubsubsection{Descrizione}
Questa componente ha il compito di ottenere una lista di preview di chat, eventualmente filtrando la ricerca.
È costituita da:
\begin{itemize}
    \item \textbf{Route API}: /getChats;
    \item \textbf{Metodo}: POST;
    \item \textbf{Lista parametri HTTP}: 
    \begin{itemize}
        \item "filter": filtro da applicare per la ricerca tra le chat.
    \end{itemize}
\end{itemize}
\subsubsubsection{Esiti possibili}
\begin{xltabular}{\textwidth}{c|X|X}
\caption{Esiti possibili GetChats}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endfirsthead
\caption[]{Esiti possibili GetChats (cont)}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endhead
\multicolumn{3}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
200 & Ricerca avvenuta con successo. & - \\
\hline
500 & Ricerca fallita. & Errore nella ricerca della chat. \\
\end{xltabular}

\subsubsubsection{Tracciamento dei requisiti}
\begin{itemize}
        \item RF.O.30;
        \item RF.O.30.1;
        \item RF.O.30.1.1;
        \item RF.O.30.1.2;
        \item RF.O.30.1.3;
        \item RF.O.30.1.4;
        \item RF.O.38.
\end{itemize}

\subsubsubsection{Lista sottocomponenti}
\begin{itemize}
    \item \label{GetChatsController}\textbf{GetChatsController}: classe controller che si occupa del richiedere le preview delle chat allo use case GetChatsUseCase, con eventuale passaggio di un filtro per eseguire una ricerca;
    \item \label{ChatFilter}\textbf{ChatFilter}: classe di business che rappresenta il filtro utilizzato nella ricerca;
    \item \label{GetChatsUseCase}\textbf{GetChatsUseCase}: interfaccia use case che rappresenta la porta della business logic in entrata per richiedere le chat, eventualmente filtrate;
    \item \label{GetChatsService}\textbf{GetChatsService}: classe service che implementa lo use case GetChatsUseCase;
    \item \label{ChatPreview}\textbf{ChatPreview}: classe di business che rappresenta la preview di una chat;
    \item \textbf{ChatInfo}: vedi \vedi{ChatInfo};
    \item \textbf{ChatId}: vedi \vedi{ChatId};
    \item \label{GetChatsPort}\textbf{GetChatsPort}: interfaccia che rappresenta la porta in uscita per effettuare la richiesta delle chat eventualmente filtrate verso il database per la storicizzazione delle chat;
    \item \label{GetChatsPostgres}\textbf{GetChatsPostgres}: classe che implementa la porta GetChatsPort, adattando la chiamata di GetChatsService a PostgresORM;
    \item \textbf{PostgresORM}: vedi \vedi{PostgresORM}; 
    \item \label{PostgresChatPreview}\textbf{PostgresChatPreview}: classe di persistence che rappresenta la preview di una chat.
\end{itemize}

\begin{comment}
\subsubsection{GetConfiguration}
    \subsubsubsection{Descrizione}
    Questa componente ha il compito di ricavare la configurazione del sistema.
    È costituita da:
    \begin{itemize}
        \item \textbf{Route API}: /getConfiguration;
        \item \textbf{Metodo}: GET;
        \item \textbf{Lista parametri HTTP}: -
    \end{itemize}
    \subsubsubsection{Esiti possibili}
    \begin{xltabular}{\textwidth}{c|X|X}
    \caption{Esiti possibili GetConfiguration}\\
    \textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
    \endfirsthead
    \caption[]{Esiti possibili GetConfiguration (cont)}\\
    \textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
    \endhead
    \multicolumn{3}{r}{{Continua nella pagina successiva}} \\
    \endfoot
    \endlastfoot
    \hline
    200 & Configurazione ricavata con successo. & - \\
    \hline
    500 & Ricavo configurazione fallito. & Errore nel ricavo della configurazione. \\
    \end{xltabular}
    
    \subsubsubsection{Tracciamento dei requisiti}
    \begin{itemize}
            \item TODO.
    \end{itemize}
    
    \subsubsubsection{Lista sottocomponenti}
    \begin{itemize}
        \item 
    \end{itemize}
\end{comment}

\subsubsection{GetDocuments}
\subsubsubsection{Descrizione}
Questa componente ha il compito di ricavare la lista di tutti i documenti presenti nel sistema e di rispondere a ricerche basate sull'id dei documenti.
È costituita da:
\begin{itemize}
    \item \textbf{Route API}: /getDocuments;
    \item \textbf{Metodo}: GET;
    \item \textbf{Lista parametri HTTP}: 
    \begin{itemize}
        \item "searchFilter": stringa che rappresenta il filtro opzionale da applicare alla ricerca dei documenti.
    \end{itemize}
\end{itemize}
\subsubsubsection{Esiti possibili}
\renewcommand{\arraystretch}{1.5}
\begin{xltabular}{\textwidth}{c|X|X}
\caption{Esiti possibili GetDocuments}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endfirsthead
\caption[]{Esiti possibili GetDocuments (cont)}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endhead
\multicolumn{3}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
200 & Ricerca avvenuta con successo. & - \\
\hline
500 & Ricerca fallita. & Errore nella ricerca dei documenti.
\end{xltabular}

\subsubsubsection{Tracciamento dei requisiti}
\begin{itemize}
    \item TODO.
\end{itemize}

\subsubsubsection{Lista sottocomponenti}
\begin{itemize}
    \item \label{DocumentMetadata}\textbf{DocumentMetadata}: classe di business che rappresenta i metadati di un documento;
    \item \label{DocumentType}\textbf{DocumentType}: enumeration che rappresenta i valori che può assumere il tipo di un documento;
    \item \label{DocumentId}\textbf{DocumentId}: classe di business che rappresenta l'id di un documento;
    \item \label{DocumentStatus}\textbf{DocumentStatus}: classe di business che rappresenta lo status di un documento;
    \item \label{Status}\textbf{Status}: enumeration che rappresenta i valori che può assumere lo status di un documento;
    \item \label{LightDocument}\textbf{LightDocument}: classe di business che fornisce una rappresentazione leggera dei documenti, esculdendo il contenuto;
    \item \label{DocumentFilter}\textbf{DocumentFilter}: classe di business che rappresenta il filtro applicabile alla ricerca di documenti;
    \item \label{GetDocumentsController}\textbf{GetDocumentsController}: classe controller che si occupa del passaggio di un oggetto DocumentFilter allo use case GetDocumentsUseCase a partire da una stringa che rappresenta il filtro della ricerca;
    \item \label{GetDocumentsUseCase}\textbf{GetDocumentsUseCase}: interfaccia use case che rappresenta la porta della business logic in entrata per ricercare dei documenti;
    \item \label{GetDocumentsFacadeService}\textbf{GetDocumentsFacadeService}: classe service che implementa lo use case GetDocumentsUseCase.
    \item \label{GetDocumentsMetadata}\textbf{GetDocumentsMetadata}: classe che si occupa di ricavare i metadati di una lista di documenti nella porta esterna GetDocumentsMetadataPort diretta verso il sistema di archiviazione documenti a partire da un filtro di ricerca;
    \item \label{GetDocumentsStatus}\textbf{GetDocumentsStatus}: classe che si occupa di inoltrare la richiesta di recuperare gli status di una lista di documenti nella porta esterna GetDocumentsStatusPort diretta verso il vector store;
    \item \label{GetDocumentsMetadataPort}\textbf{GetDocumentsMetadataPort}: interfaccia che rappresenta la porta in uscita per ricavare i metadati di una lista di documenti dal sistema di archiviazione a partire da un filtro di ricerca;
    \item \label{GetDocumentsStatusVectorStore}\textbf{GetDocumentsStatusVectorStore}: classe adapter che implementa la porta GetDocumentsStatusPort, adattando la chiamata di GetDocumentsStatus a VectorStoreManager;
    \item \label{GetDocumentsListAWSS3}\textbf{GetDocumentsListAWSS3}: classe adapter che implementa la porta GetDocumentsMetadataPort, adattando la chiamata di GetDocumentsMetadata a AWSS3Manager;
    \item \textbf{AWSS3Manager}: vedi \vedi{AWSS3Manager};
    \item \label{AWSDocumentMetadata}\textbf{AWSDocumentMetadata}: classe che rappresenta i metadati di un documento ricavato da AWS;
    \item \textbf{VectorStoreManager}: vedi \vedi{VectorStoreManager};
    \item \textbf{VectorStorePineconeManager}: vedi \vedi{VectorStorePineconeManager};
    \item \textbf{VectorStoreChromaDBManager}: vedi \vedi{VectorStoreChromaDBManager}.
\end{itemize}


\subsubsection{RenameChat}
\subsubsubsection{Descrizione}
Questa componente ha il compito di rinominare una chat, aggiornando di conseguenza il database utilizzato per la storicizzazione delle chat.
È costituita da:
\begin{itemize}
    \item \textbf{Route API}: /renameChat;
    \item \textbf{Metodo}: POST;
    \item \textbf{Lista parametri HTTP}: 
    \begin{itemize}
        \item "chatI": l'Id utilizzato per identificare univocamente una chat;
        \item "title": nuovo titolo da assegnare alla chat.
    \end{itemize}
\end{itemize}
\subsubsubsection{Esiti possibili}
\begin{xltabular}{\textwidth}{c|X|X}
\caption{Esiti possibili RenameChat}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endfirsthead
\caption[]{Esiti possibili RenameChat (cont)}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endhead
\multicolumn{3}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
500 & Rinomina fallita. & Errore nella rinomina della chat. \\
\hline
500 & Rinomina fallita. & Errore nella rinomina della chat: titolo vuoto.\\
\hline
500 & Rinomina fallita. & Errore nella rinomina della chat: titolo già utilizzato per un'altra chat.\\ 
%RICCARDO chiedo
\end{xltabular}

\subsubsubsection{Tracciamento dei requisiti}
\begin{itemize}
        \item RF.O.35
        \item RF.O.36  %e non 36.1
        \item RF.O.37  %uguale
\end{itemize}

\subsubsubsection{Lista sottocomponenti}
\begin{itemize}
    \item \label{RenameChatController}\textbf{RenameChatController}: classe controller che si occupa del passaggio allo use case CreateChatUseCase di un intero rappresentante l'id di una chat e un titolo per eseguire la sua rinomina;
    \item \label{RenameChatUseCase}\textbf{RenameChatUseCase}: interfaccia use case che rappresenta la porta della business logic in entrata per effettuare la rinomina di una chat;
    \item \label{RenameChatService}\textbf{RenameChatService}: classe service che implementa lo use case RenameChatUseCase;
    \item \label{RenameChatPort}\textbf{RenameChatPort}: interfaccia che rappresenta la porta in uscita per effettuare la rinomina di una chat verso il database per la storicizzazione delle chat;
    \item \label{RenameChatPostgres}\textbf{RenameChatPostgres}: classe che implementa la porta RenameChatPort, adattando la chiamata di RenameChatService a PostgresORM;
    \item \textbf{PostgresORM}: vedi \vedi{PostgresORM}. 
\end{itemize}


\subsubsection{UploadDocuments}
\subsubsubsection{Descrizione}
Questa componente ha il compito di memorizzare i documenti inseriti dall'utente nel sistema di archiviazione e calcolare gli embeddings, memorizzandoli nel vector store configurato.
È costituita da:
\begin{itemize}
    \item \textbf{Route API}: /uploadDocuments;
    \item \textbf{Metodo}: POST;
    \item \textbf{Lista parametri HTTP}: 
    \begin{itemize}
        \item "documents": una lista di documenti.
    \end{itemize}
\end{itemize}
\subsubsubsection{Esiti possibili}
\renewcommand{\arraystretch}{1.5}
\begin{xltabular}{\textwidth}{c|X|X}
\caption{Esiti possibili UploadDocuments}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endfirsthead
\caption[]{Esiti possibili UploadDocuments (cont)}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endhead
\multicolumn{3}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
200 & Upload avvenuto con successo. & - \\
\hline
500 & Upload fallito. & Errore nell'upload dei documenti. \\
\hline
500 & Upload fallito. & Errore nel calcolo degli embeddings dei documenti. \\
\end{xltabular}

\subsubsubsection{Tracciamento dei requisiti}
\begin{itemize}
    \item RF.O.21;
    \item RF.O.21.1;
    \item RF.O.21.3;
    \item RF.O.21.4;
    \item RF.O.21.6.
\end{itemize}

\subsubsubsection{Lista sottocomponenti}
\begin{itemize}
    \item \label{NewDocument}\textbf{NewDocument}: classe di presentation che contiene le informazioni relative ai documenti appena inseriti dall'utente, presenti nella richiesta HTTP;
    \item \textbf{DocumentMetadata}: vedi \vedi{DocumentMetadata};
    \item \textbf{DocumentType}: vedi \vedi{DocumentType};
    \item \textbf{DocumentId}: vedi \vedi{DocumentId};
    \item \textbf{DocumentStatus}: vedi \vedi{DocumentStatus};
    \item \textbf{Status}: vedi \vedi{Status};
    \item \label{DocumentContent}\textbf{DocumentContent}: classe di business che rappresenta il contenuto di un documento;
    \item \label{Document}\textbf{Document}: classe di business che rappresenta i documenti completi;
    \item \label{PlainDocument}\textbf{PlainDocument}: classe di business che rappresenta i documenti, compresi i metadati e il contenuto;
    \item \label{UploadDocumentsController}\textbf{UploadDocumentsController}: classe controller che si occupa del passaggio di Documents allo use case UploadDocumentsUseCase a partire da NewDocuments;
    \item \label{UploadDocumentsUseCase}\textbf{UploadDocumentsUseCase}: interfaccia use case che rappresenta la porta della business logic in entrata per effettuare l'upload dei documenti;
    \item \label{UploadDocumentsService}\textbf{UploadDocumentsService}: classe service che implementa lo use case UploadDocumentsUseCase;
    \item \label{DocumentUploader}\textbf{DocumentUploader}: classe che si occupa di effettuare la chiamata dell'upload dei documenti nella porta esterna diretta verso il sistema di archiviazione documenti;
    \item \textbf{EmbeddingsUploader}: vedi \vedi{EmbeddingsUploader};
    \item \label{DocumentUploaderPort}\textbf{DocumentUploaderPort}: interfaccia che rappresenta la porta in uscita per effettuare l'upload dei documenti verso il sistema di archiviazione doucumenti;
    \item \textbf{EmbeddingsUploaderPort}: vedi \vedi{EmbeddingsUploaderPort};
    \item \label{DocumentUploaderAWSS3}\textbf{DocumentUploaderAWSS3}: classe adapter che implementa la porta DocumentUploaderPort, adattando la chiamata di DocumentUploader a AWSS3Manager;
    \item \textbf{AWSDocument}: vedi \vedi{AWSDocument};
    \item \textbf{AWSDocumentOperationResponse}: vedi \vedi{AWSDocumentOperationResponse};
    \item \textbf{DocumentOperationResponse}: vedi \vedi{DocumentOperationResponse};
    \item \textbf{EmbeddingsUploaderFacadeLangchain}: vedi \vedi{EmbeddingsUploaderFacadeLangchain};
    \item \textbf{LangchainDocument}: vedi \vedi{LangchainDocument};
    \item \textbf{AWSS3Manager}: vedi \vedi{AWSS3Manager};
    \item \textbf{DocumentToText}: vedi \vedi{DocumentToText};
    \item \textbf{TextExtractor}: vedi \vedi{TextExtractor};
    \item \textbf{PDFTextExtractor}: vedi \vedi{PDFTextExtractor};
    \item \textbf{DOCXTextExtractor}: vedi \vedi{DOCXTextExtractor};
    \item \textbf{Chunkerizer}: vedi \vedi{Chunkerizer};
    \item \textbf{EmbeddingsCreator}: vedi \vedi{EmbeddingsCreator};
    \item \textbf{LangchainEmbeddingModel}: vedi \vedi{LangchainEmbeddingModel};
    \item \textbf{OpenAIEmbeddingModel}: vedi \vedi{OpenAIEmbeddingModel};
    \item \textbf{HuggingFaceEmbeddingModel}: vedi \vedi{HuggingFaceEmbeddingModel};
    \item \textbf{EmbeddingsUploaderVectorStore}: vedi \vedi{EmbeddingsUploaderVectorStore};
    \item \label{VectorStoreDocumentStatusResponse}\textbf{VectorStoreDocumentStatusResponse}: classe che rappresenta la risposta generata da un vector store, contenente lo status del documento richiesto;
    \item \textbf{VectorStoreManager}: vedi \vedi{VectorStoreManager};
    \item \textbf{VectorStorePineconeManager}: vedi \vedi{VectorStorePineconeManager};
    \item \textbf{VectorStoreChromaDBManager}: vedi \vedi{VectorStoreChromaDBManager};
    \item \textbf{VectorStoreDocumentOperationResponse}: vedi \vedi{VectorStoreDocumentOperationResponse}.
\end{itemize}

\subsubsection{ViewDocumentContent}
\subsubsubsection{Descrizione}
Questa componente ha il compito di recuperare tutte le informazioni di un documento, compreso il suo contenuto.
È costituita da:
\begin{itemize}
    \item \textbf{Route API}: /viewDocumentContent;
    \item \textbf{Metodo}: GET;
    \item \textbf{Lista parametri HTTP}: 
    \begin{itemize}
        \item "documentId": una stringa che rappresenta l'id del documento da recuperare.
    \end{itemize}
\end{itemize}
\subsubsubsection{Esiti possibili}
\renewcommand{\arraystretch}{1.5}
\begin{xltabular}{\textwidth}{c|X|X}
\caption{Esiti possibili ViewDocumentContent}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endfirsthead
\caption[]{Esiti possibili ViewDocumentContent (cont)}\\
\textbf{Codice} & \textbf{Descrizione} & \textbf{Risposta} \\
\endhead
\multicolumn{3}{r}{{Continua nella pagina successiva}} \\
\endfoot
\endlastfoot
\hline
200 & Documento recuperato con successo. & - \\
\hline
500 & Recupero documento fallito. & Errore nel recupero del documento.
\end{xltabular}

\subsubsubsection{Tracciamento dei requisiti}
\begin{itemize}
    \item TODO.
\end{itemize}

\subsubsubsection{Lista sottocomponenti}
\begin{itemize}
    \item \textbf{DocumentMetadata}: vedi \vedi{DocumentMetadata};
    \item \textbf{DocumentType}: vedi \vedi{DocumentType};
    \item \textbf{DocumentId}: vedi \vedi{DocumentId};
    \item \textbf{DocumentStatus}: vedi \vedi{DocumentStatus};
    \item \textbf{Status}: vedi \vedi{Status};
    \item \textbf{DocumentContent}: vedi \vedi{DocumentContent};
    \item \textbf{Document}: vedi \vedi{Document};
    \item \textbf{PlainDocument}: vedi \vedi{PlainDocument};
    \item \label{GetDocumentController}\textbf{GetDocumentController}: classe controller che si occupa del passaggio di un DocumentId allo use case GetDocumentUseCase a partire da una stringa che rappresenta l'id del documento da recuperare;
    \item \label{GetDocumentUseCase}\textbf{GetDocumentUseCase}: interfaccia use case che rappresenta la porta della business logic in entrata per recuperare un documento;
    \item \label{GetDocumentFacadeService}\textbf{GetDocumentFacadeService}: classe service che implementa lo use case GetDocumentUseCase;
    \item \textbf{GetDocuments}: vedi \vedi{GetDocuments};
    \item \textbf{GetDocumentsStatus}: vedi \vedi{GetDocumentsStatus};
    \item \textbf{GetDocumentsPort}: vedi \vedi{GetDocumentsPort};
    \item \label{GetDocumentsStatusPort}\textbf{GetDocumentsStatusPort}: interfaccia che rappresenta la porta in uscita per recuperare gli status di una lista di documenti dal vector store;
    \item \textbf{GetDocumentsAWSS3}: vedi \vedi{GetDocumentsAWSS3};
    \item \textbf{AWSS3Manager}: vedi \vedi{AWSS3Manager};
    \item \textbf{AWSDocument}: vedi \vedi{AWSDocument};
    \item \textbf{GetDocumentsStatusVectorStore}: vedi \vedi{GetDocumentsStatusVectorStore};
    \item \textbf{VectorStoreManager}: vedi \vedi{VectorStoreManager};
    \item \textbf{VectorStorePineconeManager}: vedi \vedi{VectorStorePineconeManager};
    \item \textbf{VectorStoreChromaDBManager}: vedi \vedi{VectorStoreChromaDBManager};
    \item \textbf{VectorStoreDocumentOperationResponse}: vedi \vedi{VectorStoreDocumentOperationResponse}.
\end{itemize}


\subsection{Database} %TODO
    % definisco ogni tabella e la descrivo
    % diagramma ER del db
    % script di creazione db

\subsection{Libreria per la persistenza} %TODO
    % diagramma delle classi
    % x ogni entità ci sarà una classe:
    %     - annotazioni (non ci sono in py, non penso di metterle)
    %     - attributi privati
    %     - costruttori

\newpage

\section{Progettazione di dettaglio}
    % Per ogni componente:
    %    - diagramma di dettaglio
    %    Indicare per ogni sottocomponente:
    %        - attributi (nome: tipo)
    %        - metodi (firma, descrizione)
    % - interfacce implementate

    \subsection{AskChatbot}
    \subsubsection{Diagramma delle classi}
    \subsubsection{Lista delle sottocomponenti}
    
    \subsubsubsection{AskChatbotController}
    \label{AskChatbotControllerDettaglio}
    \begin{itemize}
        \item \textbf{Attributi}:
        \begin{itemize}
            \item \code{useCase: AskChatbotUseCase}.
        \end{itemize}
        \item \textbf{Metodi}:
        \begin{itemize}
            \item \code{askChatbot(message:string, ChatId:int): Message}\\
            Metodo che ritorna un Message rappresentante la risposta da parte del chatbot ad un messaggio dell'utente sotto forma di string, appartenente alla chat identificata dall'intero chatId. Nel caso in cui il chatId sia vuoto e venga inoltre generata correttamente una risposta, viene creata una nuova chat;
            \item \code{toMessageFrom(message: string): Message}\\
            Metodo che trasforma una stringa un Message;
            \item \code{toChatIdFrom(chatIdInt:int): ChatId}\\
            Metodo che trasforma un intero in un ChatId.
        \end{itemize}
    \end{itemize}
    
    \subsubsubsection{ChatId}
    \label{ChatIdDettaglio}
    \begin{itemize}
        \item \textbf{Attributi}:
        \begin{itemize}
            \item \code{id: int}.
        \end{itemize}
    \end{itemize}
    
    \subsubsubsection{Message}
    \label{MessageDettaglio}
    \begin{itemize}
        \item \textbf{Attributi}:
        \begin{itemize}
            \item \code{content: string};
            \item \code{timestamp: timestamp};
            \item \code{relevantDocument: List<string>};
            \item \code{sender: MessageSender}.
        \end{itemize}
    \end{itemize}
    
    \subsubsubsection{MessageSender (Enumeration)}
    \label{MessageSenderDettaglio}
    \begin{itemize}
        \item \textbf{Valori}:
        \begin{itemize}
            \item \code{Chatbot};
            \item \code{User};
        \end{itemize}
    \end{itemize}
    
    \subsubsubsection{AskChatbotUseCase}
    \label{AskChatbotUseCaseDettaglio}
    \begin{itemize}
        \item \textbf{Metodi}:
        \begin{itemize}
            \item \code{askChatbot(message:Message, chatId:ChatId): Message}\\
            Metodo astratto per ottenere una risposta dal chatbot ad un messaggio appartenente ad una chat identificata da un ChatId. Nel caso in cui il chatId sia vuoto e venga inoltre generata correttamente una risposta, viene creata una nuova chat.
        \end{itemize}
    \end{itemize}
    
    \subsubsubsection{AskChatbotService}
    \label{AskChatbotServiceDettaglio}
    \begin{itemize}
        \item \textbf{Attributi}:
        \begin{itemize}
            \item \code{outPort: GetChatMessagesPort}.
        \end{itemize}
        \item \textbf{Metodi}:
        \begin{itemize}
            \item \code{askChatbot(message:Message, chatId:ChatId): Message}\\
            Implementazione del metodo astratto di AskChatbotUseCase per ottenere tramite outPort una risposta dal chatbot ad un messaggio appartenente ad una chat identificata da un ChatId. Nel caso in cui il chatId sia vuoto e venga inoltre generata correttamente una risposta, viene creata una nuova chat.
        \end{itemize}
    \end{itemize}
    
    \subsubsubsection{AskChatbotPort}
    \label{AskChatbotPortDettaglio}
    \begin{itemize}
        \item \textbf{Metodi}:
        \begin{itemize}
            \item \code{askChatbot(message: Message, chatId: ChatId): Message}\\
            Metodo astratto per ottenere una risposta dal chatbot ad un messaggio appartenente ad una chat identificata da un ChatId. Nel caso in cui il chatId sia vuoto e venga inoltre generata correttamente una risposta, viene creata una nuova chat.
        \end{itemize}
    \end{itemize}
    
    \subsubsubsection{AskChatbotLangchain}
    \label{AskChatbotLangchainDettaglio}
    \begin{itemize}
        \item \textbf{Attributi}:
        \begin{itemize}
            \item \code{chatbot: ChatbotLangchain};
            \item \code{chatHistoryManager: ChatHistoryManager};
            \item \code{postgresORM: PostgresORM}.
        \end{itemize}
        \item \textbf{Metodi}:
        \begin{itemize}
            \item \code{askChatbot(message:Message, chatId:ChatId): Message}\\
            Implementazione del metodo astratto di AskChatbotPort per ottenere una risposta dal chatbot ad un messaggio appartenente ad una chat identificata da un ChatId. Nel caso in cui il chatId sia vuoto e venga inoltre generata correttamente una risposta, viene creata una nuova chat tramite postgresORM;
            \item \code{toMessageFrom(message: BaseMessage): Message}\\
            Metodo per ottenere un Message a partire da un BaseMessage;
            \item \code{toBaseMessageFrom(message: Message): BaseMessage}\\
            Metodo per ottenere un BaseMessage a partire da un Message;
            \item \code{createChat(): ChatId}\\
            Metodo per creare una chat tramite postgresORM, ritornando il suo ChatId;
            \item \code{createMemory(chatId:ChatId): langchain.Memory}\\
            Metodo per ottenere una langchain.Memory a partire da un ChatId tramite chatHistoryManager.
        \end{itemize}
    \end{itemize}
    
    \subsubsubsection{ChatbotLangchain}
    \label{ChatbotLangchainDettaglio}
    \begin{itemize}
        \item \textbf{Attributi}:
        \begin{itemize}
            \item \code{chain: langchain.Chain}.
        \end{itemize}
        \item \textbf{Metodi}:
        \begin{itemize}
            \item \code{ask(userMessage:BaseMessage, memory:langchain.Memory): langchain.BaseMessage}\\
            Metodo per ottenere una risposta di tipo langchain.BaseMessage dal chatbot tramite chain ad un userMessage di tipo BaseMessage, richiedendo inoltre il contesto della chat attraverso la memory di tipo langchain.Memory.
        \end{itemize}
    \end{itemize}
    
    \subsubsubsection{LangchainLLM}
    \label{LangchainLLMDettaglio}
    \begin{itemize}
        \item \textbf{Attributi}:
        \begin{itemize}
            \item \code{llm: langchain.BaseLanguageModel}.
        \end{itemize}
    \end{itemize}
    
    \subsubsubsection{OpenAILLM}
    \label{OpenAILLMDettaglio}
    \begin{itemize}
        \item \textbf{Attributi}:
        \begin{itemize}
            \item \code{llm: langchain.BaseLanguageModel}.
        \end{itemize}
    \end{itemize}
    
    \subsubsubsection{HugginFaceLLM}
    \label{HugginFaceLLMDettaglio}
    \begin{itemize}
        \item \textbf{Attributi}:
        \begin{itemize}
            \item \code{llm: langchain.BaseLanguageModel}.
        \end{itemize}
    \end{itemize}
    
    \subsubsubsection{LangchainVectorStore}
    \label{LangchainVectorStoreDettaglio}
    \begin{itemize}
        \item \textbf{Attributi}:
        \begin{itemize}
            \item \code{vectorStore: langchain.VectorStore}.
        \end{itemize}
        \item \textbf{Metodi}:
        \begin{itemize}
            \item \code{getRetriever(): BaseRetriever}\\
            Metodo astratto per ottenere un langchain.BaseRetriever.
        \end{itemize}
    \end{itemize}
    
    \subsubsubsection{PineconeVectorStore}
    \label{PineconeVectorStoreDettaglio}
    \begin{itemize}
        \item \textbf{Attributi}:
        \begin{itemize}
            \item \code{vectorStore: langchain.VectorStore}.
        \end{itemize}
        \item \textbf{Metodi}:
        \begin{itemize}
            \item \code{getRetriever(): BaseRetriever}\\
            Implementazione del metodo astratto di LangchainVectorStore per ottenere un langchain.BaseRetriever da un vector store Pinecone.
        \end{itemize}
    \end{itemize}
    
    \subsubsubsection{ChromaDBVectorStore}
    \label{ChromaDBVectorStoreDettaglio}
    \begin{itemize}
        \item \textbf{Attributi}:
        \begin{itemize}
            \item \code{vectorStore: langchain.VectorStore}.
        \end{itemize}
        \item \textbf{Metodi}:
        \begin{itemize}
            \item \code{getRetriever(): BaseRetriever}\\
            Implementazione del metodo astratto di LangchainVectorStore per ottenere un langchain.BaseRetriever da un vector store ChromaDB.
        \end{itemize}
    \end{itemize}
    
    \subsubsubsection{LangchainEmbeddingModel}
    \label{LangchainEmbeddingModelDettaglio}
    \begin{itemize}
        \item \textbf{Attributi}:
        \begin{itemize}
            \item \code{embeddingModel: Embeddings}.
        \end{itemize}
        \item \textbf{Metodi}:
        \begin{itemize}
            \item \code{embedDocument(documentChunks: List<string>): List<List<float>>}\\
            Metodo astratto per generare gli embeddings di un insieme di chunks sotto forma di lista di stringhe: per ogni chunk in lista viene generata una lista di float che rappresenta gli embeddings.
        \end{itemize}
    \end{itemize}
    
    \subsubsubsection{OpenAIEmbeddingModel}
    \label{OpenAIEmbeddingModelDettaglio}
    \begin{itemize}
        \item \textbf{Metodi}:
        \begin{itemize}
            \item \code{embedDocument(documentChunks:List<string>): List<List<float>>}\\
            Implementazione del metodo astratto di LangchainEmbeddingModel per generare gli embeddings di un insieme di chunks di stringhe tramite un modello di embeddings OpenAI: per ogni chunk in lista viene generata una lista di float che rappresenta gli embeddings.
        \end{itemize}
    \end{itemize}
    
    \subsubsubsection{HuggingFaceEmbeddingModel}
    \label{HuggingFaceEmbeddingModelDettaglio}
    \begin{itemize}
        \item \textbf{Metodi}:
        \begin{itemize}
            \item \code{embedDocument(documentChunks:List<string>): List<List<float>>}\\
            Implementazione del metodo astratto di LangchainEmbeddingModel per generare gli embeddings di un insieme di chunks di stringhe tramite un modello di embeddings di HuggingFace: per ogni chunk in lista viene generata una lista di float che rappresenta gli embeddings.
        \end{itemize}
    \end{itemize}
    
    \subsubsubsection{ChatHistoryManager}
    \label{ChatHistoryManagerDettaglio}
    \begin{itemize}
        \item \textbf{Metodi}:
        \begin{itemize}
            \item \code{getChatHistory(chatId:ChatId): langchain.PostgresChatMessageHistory}\\
            Metodo per ottenere una langchain.PostgresChatMessageHistory rappresentante il contesto di una chat identificata da un ChatId;
            \item \code{saveMessage(message: langchain.BaseMessage, memory:langchain.Memory): void}\\
            Metodo per salvare un messaggio di tipo lanchain.BaseMessage in una memory di tipo lanchain.Memory rappresentante il contesto di una chat. 
        \end{itemize}
    \end{itemize}
    
    \subsubsubsection{PostgresORM}
    \label{PostgresORMDettaglio}
    \begin{itemize}
        \item \textbf{Metodi}:
        \begin{itemize}
            \item \code{getChats(chatFilter:string): List<PostgresChatPreview>}\\
            Metodo per ottenere una lista di PostgresChatPreview dal database Postgres utilizzato per la storicizzazione delle chat, eventualmente filtrando la ricerca attraverso chatFilter;
            \item \code{getChatMessages(chatId:int): PostgresChat}\\
            Metodo per ottenere una PostgresChat dal database Postgres utilizzato per la storicizzazione delle chat a partire da un intero rappresentante l'id della chat;
            \item \code{renameChat(chatId:int, title:string): boolean}\\
            Metodo per rinominare con title una chat identificata tramite chatId sul database Postgres utilizzato per la storicizzazione delle chat. L'esito dell'operazione viene comunicato ritornando un boolean;  
            \item \code{deleteChats(chatId:int): boolean}\\
            Metodo per eliminare una PostgresChat sul database Postgres utilizzato per la storicizazzione delle chat. L'esito dell'operazione viene comunicato ritornando un boolean;        
            \item \code{createChat(): PostgresChat}\\
            Metodo per creare una nuova PostgresChat sul database Postgres utilizzato per la storicizzazione della chat. L'istanza della chat creata viene ritornata dal metodo.
        \end{itemize}
    \end{itemize}
    
    \subsubsubsection{PostgresChat}
    \label{PostgresChatDettaglio}
    \begin{itemize}
        \item \textbf{Attributi}:
        \begin{itemize}
            \item \code{id: int}
            \item \code{title: string};
            \item \code{timestamp: timestamp};
            \item \code{messages: List<PostgresMessage>}.
        \end{itemize}
    \end{itemize}
    
    \subsubsubsection{PostgresMessage}
    \label{PostgresMessageDettaglio}
    \begin{itemize}
        \item \textbf{Attributi}:
        \begin{itemize}
            \item \code{content: string};
            \item \code{timestamp: timestamp};
            \item \code{relevantDocument: List<string>};
            \item \code{sender: string}.
        \end{itemize}
    \end{itemize}

    \subsection{ConcealDocuments}
    \subsubsection{Diagramma delle classi}
    \subsubsection{Lista delle sottocomponenti}
    
    \subsubsubsection{ConcealDocumentsController}
    \label{ConcealDocumentsControllerDettaglio}
    \begin{itemize}
        \item \textbf{Attributi}:
        \begin{itemize}
            \item \code{useCase: ConcealDocumentsUseCase}.
        \end{itemize}
        \item \textbf{Metodi}:
        \begin{itemize}
            \item \code{concealDocuments(documentIds:List<string>):}\\ \code{List<DocumentOperationResponse>}\\
            Metodo che si occupa di trasformare le stringhe di id in DocumentId e inoltrare l'occultamento dei documenti a ConcealDocumentsUseCase;
        \end{itemize}
    \end{itemize}
    
    \subsubsubsection{ConcealDocumentsUseCase}
    \label{ConcealDocumentsUseCaseDettaglio}
    \begin{itemize}
        \item \textbf{Metodi}:
        \begin{itemize}
            \item \code{concealDocuments(documentIds:List<DocumentId>):}\\ \code{List<DocumentOperationResponse>}\\
            Metodo astratto per occultare una lista di documenti a partire dal loro DocumentId. Ritorna una lista di DocumentOperationResponse, che indica l'esito dell'operazione per ogni documento.
        \end{itemize}
    \end{itemize}
    
    \subsubsubsection{ConcealDocumentsService}
    \label{ConcealDocumentsServiceDettaglio}
    \begin{itemize}
        \item \textbf{Attributi}:
        \begin{itemize}
            \item \code{outPort: ConcealDocumentsPort}.  
        \end{itemize}
        \item \textbf{Metodi}:
        \begin{itemize}
            \item \code{concealDocuments(documentIds:List<DocumentId>):}\\ \code{List<DocumentOperationResponse>}\\
            Implementazione del metodo astratto di ConcealDocumentsUseCase per occultare una lista di documenti a partire dal loro DocumentId. Ritorna una lista di DocumentOperationResponse, che indica l'esito dell'operazione per ogni documento.
        \end{itemize}
    \end{itemize}
    
    \subsubsubsection{ConcealDocumentsPort}
    \label{ConcealDocumentsPortDettaglio}
    \begin{itemize}
        \item \textbf{Metodi}:
        \begin{itemize}
            \item \code{concealDocuments(documentIds:List<DocumentId>):}\\ \code{List<DocumentOperationResponse>}\\
            Metodo astratto per occultare una lista di documenti a partire dal loro DocumentId, dialogando con il vector store. Ritorna una lista di DocumentOperationResponse, che indica l'esito dell'operazione per ogni documento.
        \end{itemize}
    \end{itemize}
    
    \subsubsubsection{ConcealDocumentsVectorStore}
    \label{ConcealDocumentsVectorStoreDettaglio}
    \begin{itemize}
        \item \textbf{Attributi}:
        \begin{itemize}
            \item 
        \end{itemize}
        \item \textbf{Metodi}:
        \begin{itemize}
            \item \code{concealDocuments(documentIds:List<DocumentId>):}\\ \code{List<DocumentOperationResponse>}\\
            Implementazione del metodo astratto di ConcealDocumentsPort per occultare una lista di documenti a partire dal loro DocumentId, dialogando con il vector store. Ritorna una lista di DocumentOperationResponse, che indica l'esito dell'operazione per ogni documento.
        \end{itemize}
    \end{itemize}
    
    \subsubsubsection{VectorStoreManager}
    \label{VectorStoreManagerDettaglio}
    \begin{itemize}
        \item \textbf{Metodi}:
        \begin{itemize}
            \item \code{getDocumentsStatus(documentIds:List<string>):}\\ \code{List<VectorStoreDocumentStatusResponse>}\\
            Metodo astratto per ottenere gli status di una lista di documenti dai loro metadati a partire da una lista di stringhe che rappresentano i documentIds dei documenti, ritornandoli in una lista di VectorStoreDocumentStatusResponse;
            \item \code{deleteDocumentsEmbeddings(documentsIds:List<string>):}\\ \code{List<VectorStoreDocumentOperationResponse>}\\
            Metodo astratto per eliminare gli embeddings di una lista di documenti a partire da una lista di stringhe che rappresentano i documentIds dei documenti, ritornando una lista di VectorStoreDocumentOperationResponse;
            \item \code{concealDocuments(documentsId:List<string>):}\\ \code{List<VectorStoreDocumentOperationResponse>}\\
            Metodo astratto per occultare gli embeddings di una lista di documenti a partire da una lista di stringhe che rappresentano i documentIds dei documenti, ritornando una lista di VectorStoreDocumentOperationResponse;
            \item \code{enableDocuments(documentsId:List<string>):}\\ \code{List<VectorStoreDocumentOperationResponse>}\\
            Metodo astratto per abilitare gli embeddings di una lista di documenti a partire da una lista di stringhe che rappresentano i documentIds dei documenti, ritornando una lista di VectorStoreDocumentOperationResponse;
            \item \code{uploadEmbeddings(documentEmbeddings:}\\ \code{List<Tuple<string; List<float>; Dict<string; Any>>>):}\\ \code{List<VectorStoreDocumentOperationResponse>}\\
            Metodo astratto per effettuare l'upload degli embeddings di un documento a partire da una lista di tuple, ciascuna formata da una stringa (documentId), una lista di float (embeddings del documento) e un dizionario con coppie string: Any (metadata del documento). Ritorna un VectorStoreDocumentOperationResponse.
        \end{itemize}
    \end{itemize}
    
    \subsubsubsection{VectorStorePineconeManager}
    \label{VectorStorePineconeManagerDettaglio}
    \begin{itemize}
        \item \textbf{Metodi}:
        \begin{itemize}
            \item \code{getDocumentsStatus(documentIds:List<string>):}\\ \code{List<VectorStoreDocumentStatusResponse>}\\
            Implementazione del metodo astratto di VectorStoreManager per ottenere da Pinecone gli status di una lista di documenti dai loro metadati a partire da una lista di stringhe che rappresentano i documentIds dei documenti, ritornandoli in una lista di VectorStoreDocumentStatusResponse;
            \item \code{deleteDocumentsEmbeddings(documentsIds:List<string>):}\\ \code{List<VectorStoreDocumentOperationResponse>}\\
            Implementazione del metodo astratto di VectorStoreManager per eliminare da Pinecone gli embeddings di una lista di documenti a partire da una lista di stringhe che rappresentano i documentIds dei documenti, ritornando una lista di VectorStoreDocumentOperationResponse;
            \item \code{concealDocuments(documentsId:List<string>):}\\ \code{List<VectorStoreDocumentOperationResponse>}\\
            Implementazione del metodo astratto di VectorStoreManager per occultare in Pinecone gli embeddings di una lista di documenti a partire da una lista di stringhe che rappresentano i documentIds dei documenti, ritornando una lista di VectorStoreDocumentOperationResponse;
            \item \code{enableDocuments(documentsId:List<string>):}\\ \code{List<VectorStoreDocumentOperationResponse>}\\
            Implementazione del metodo astratto di VectorStoreManager per abilitare in Pinecone gli embeddings di una lista di documenti a partire da una lista di stringhe che rappresentano i documentIds dei documenti, ritornando una lista di VectorStoreDocumentOperationResponse;
            \item \code{uploadEmbeddings(documentEmbeddings:}\\ \code{List<Tuple<string; List<float>; Dict<string; Any>>>):}\\ \code{List<VectorStoreDocumentOperationResponse>}\\
            Implementazione del metodo astratto di VectorStoreManager per effettuare in Pinecone l'upload degli embeddings di un documento a partire da una lista di tuple, ciascuna formata da una stringa (documentId), una lista di float (embeddings del documento) e un dizionario con coppie string: Any (metadata del documento). Ritorna un VectorStoreDocumentOperationResponse.
        \end{itemize}
    \end{itemize}
    
    \subsubsubsection{VectorStoreChromaDBManager}
    \label{VectorStoreChromaDBManagerDettaglio}
    \begin{itemize}
        \item \textbf{Metodi}:
        \begin{itemize}
            \item \code{getDocumentsStatus(documentIds:List<string>):}\\ \code{List<VectorStoreDocumentStatusResponse>}\\
            Implementazione del metodo astratto di VectorStoreManager per ottenere da ChromaDB gli status di una lista di documenti dai loro metadati a partire da una lista di stringhe che rappresentano i documentIds dei documenti, ritornandoli in una lista di VectorStoreDocumentStatusResponse;
            \item \code{deleteDocumentsEmbeddings(documentsIds:List<string>):}\\ \code{List<VectorStoreDocumentOperationResponse>}\\
            Implementazione del metodo astratto di VectorStoreManager per eliminare da ChromaDB gli embeddings di una lista di documenti a partire da una lista di stringhe che rappresentano i documentIds dei documenti, ritornando una lista di VectorStoreDocumentOperationResponse;
            \item \code{concealDocuments(documentsId:List<string>):}\\ \code{List<VectorStoreDocumentOperationResponse>}\\
            Implementazione del metodo astratto di VectorStoreManager per occultare in ChromaDB gli embeddings di una lista di documenti a partire da una lista di stringhe che rappresentano i documentIds dei documenti, ritornando una lista di VectorStoreDocumentOperationResponse;
            \item \code{enableDocuments(documentsId:List<string>):}\\ \code{List<VectorStoreDocumentOperationResponse>}\\
            Implementazione del metodo astratto di VectorStoreManager per abilitare in ChromaDB gli embeddings di una lista di documenti a partire da una lista di stringhe che rappresentano i documentIds dei documenti, ritornando una lista di VectorStoreDocumentOperationResponse;
            \item \code{uploadEmbeddings(documentEmbeddings:}\\ \code{List<Tuple<string; List<float>; Dict<string; Any>>>):}\\ \code{List<VectorStoreDocumentOperationResponse>}\\
            Implementazione del metodo astratto di VectorStoreManager per effettuare in ChromaDB l'upload degli embeddings di un documento a partire da una lista di tuple, ciascuna formata da una stringa (documentId), una lista di float (embeddings del documento) e un dizionario con coppie string: Any (metadata del documento). Ritorna un VectorStoreDocumentOperationResponse.
        \end{itemize}
    \end{itemize}
    
    \subsubsubsection{VectorStoreDocumentOperationResponse}
    \label{VectorStoreDocumentOperationResponseDettaglio}
    \begin{itemize}
        \item \textbf{Attributi}:
        \begin{itemize}
            \item \code{documentId: string};
            \item \code{responseStatus: boolean};
            \item \code{responseMessage: string}.
        \end{itemize}
    \end{itemize}
    
    
    \subsection{DeleteChats}
    \subsubsection{Diagramma delle classi}
    \subsubsection{Lista delle sottocomponenti}
    
    \subsubsubsection{ChatId}
    Vedi \vedi{ChatIdDettaglio}.
    
    \subsubsubsection{DeleteChatsController}
    \label{DeleteChatsControllerDettaglio}
    \begin{itemize}
        \item \textbf{Attributi}:
        \begin{itemize}
            \item \code{useCase: DeleteChatsUseCase}.
        \end{itemize}
        \item \textbf{Metodi}:
        \begin{itemize}
            \item \code{deleteChats(chatIdList:List<int>):}\\ \code {List<ChatOperationResponse>}\\
            Metodo che elimina tramite useCase una lista di chat identificate da una lista di interi, ritornando una lista di ChatOperationResponse;
            \item \code{toChatIdFrom(chatIdInt:int): ChatId}\\
            Metodo che crea e ritorna un ChatId a partire da un intero. 
        \end{itemize}
    \end{itemize}
    
    \subsubsubsection{DeleteChatsUseCase}
    \label{DeleteChatsUseCaseDettaglio}
    \begin{itemize}
        \item \textbf{Metodi}:
        \begin{itemize}
            \item \code{deleteChats(chatIdList:List<ChatId>):}\\ \code{List<ChatOperationResponse>}\\
            Metodo astratto per che eliminare una lista di chat identificate da una lista di ChatId, ritornando una lista di ChatOperationResponse.
        \end{itemize}
    \end{itemize}
    
    \subsubsubsection{DeleteChatsService}
    \label{DeleteChatsServiceDettaglio}
    \begin{itemize}
        \item \textbf{Attributi}:
        \begin{itemize}
            \item \code{outPort: DeleteChatsPort}.
        \end{itemize}
        \item \textbf{Metodi}:
        \begin{itemize}
            \item \code{deleteChats(chatIdList:List<ChatId>):}\\ \code{ List<ChatOperationResponse>}\\
            Implementazione del metodo astratto di DeleteChatsUseCase per eliminare tramite outPort una lista di chat identificare da una lista di ChatId, ritornando una lista di ChatOperationResponse.
        \end{itemize}
    \end{itemize}
    
    \subsubsubsection{DeleteChatsPort}
    \label{DeleteChatsPortDettaglio}
    \begin{itemize}
        \item \textbf{Metodi}:
        \begin{itemize}
            \item \code{deleteChats(chatIdList:List<ChatId>):}\\ \code{ List<ChatOperationResponse>}\\
            Metodo astratto per per eliminare una lista di chat identificare da una lista di ChatId, ritornando una lista di ChatOperationResponse.
        \end{itemize}
    \end{itemize}
    
    \subsubsubsection{DeleteChatsPostgres}
    \label{DeleteChatsPostgresDettaglio}
    \begin{itemize}
        \item \textbf{Attributi}:
        \begin{itemize}
            \item \code{postgresORM: PostgresORM}.
        \end{itemize}
        \item \textbf{Metodi}:
        \begin{itemize}
            \item \code{deleteChats(chatIdList:List<ChatId>):}\\ \code{ List<ChatOperationResponse>}\\
            Implementazione del metodo astratto di DeleteChatsPort per eliminare una lista di chat identificare da una lista di ChatId, ritornando una lista di ChatOperationResponse.
        \end{itemize}
    \end{itemize}
    
    \subsubsubsection{ChatOperationResponse}
    \label{ChatOperationResponseDettaglio}
    \begin{itemize}
        \item \textbf{Attributi}:
        \begin{itemize}
            \item \code{chatId: ChatId};
            \item \code{response: boolean}.
        \end{itemize}
    \end{itemize}
    
    \subsubsubsection{PostgresORM}
    Vedi \vedi{PostgresORMDettaglio}.
    
\subsection{DeleteDocuments}
\subsubsection{Diagramma delle classi}
\subsubsection{Lista delle sottocomponenti}

\subsubsubsection{DeleteDocumentsController}
\label{DeleteDocumentsControllerDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{useCase: DeleteDocumentsUseCase}.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{deleteDocuments(documentIds:List<string>):}\\ \code{List<DocumentOperationResponse>}\\
        Metodo che si occupa di trasformare la lista di stringhe in lista di DocumentId e inoltrare la richiesta di eliminazione dei documenti a DeleteDocumentsUseCase.
    \end{itemize}
\end{itemize}

\subsubsubsection{DeleteDocumentsUseCase}
\label{DeleteDocumentsUseCaseDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{deleteDocuments(documentsIds:List<DocumentId>):}\\ \code{List<DocumentOperationResponse>}\\
        Metodo astratto per eliminare una lista di documenti a partire dai loro id.
    \end{itemize}
\end{itemize}

\subsubsubsection{DeleteDocumentsService}
\label{DeleteDocumentsServiceDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{deleteDocuments: DeleteDocuments};
        \item \code{deleteDocumentsEmbeddings: DeleteDocumentsEmbeddings}. 
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{deleteDocuments(documentsIds:List<DocumentId>):}\\ \code{List<DocumentOperationResponse>}\\
        Implementazione del metodo astratto di DeleteDocumentsUseCase per eliminare una lista di documenti e i loro embeddings a partire dai loro id.
    \end{itemize}
\end{itemize}

\subsubsubsection{DeleteDocuments}
\label{DeleteDocumentsDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{outPort: DeleteDocumentsPort}. 
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{deleteDocuments(documentsIds:List<DocumentId>):}\\ \code{List<DocumentOperationResponse>}\\
        Metodo per eliminare una lista di documenti tramite outPort dal sistema di archiviazione a partire dai loro id.
    \end{itemize}
\end{itemize}

\subsubsubsection{DeleteDocumentsEmbeddings}
\label{DeleteDocumentsEmbeddingsDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{outPort: DeleteEmbeddingsPort}. 
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{deleteDocumentsEmbeddings(documentIds:List<DocumentId>):}\\ \code{List<DocumentOperationResponse>}\\
        Metodo per eliminare gli embeddings di una lista di documenti tramite outPort dal vector store a partire dai loro id.
    \end{itemize}
\end{itemize}

\subsubsubsection{DeleteDocumentsPort}
\label{DeleteDocumentsPortDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{deleteDocuments(documentIds:List<DocumentId>):}\\ \code{List<DocumentOperationResponse>}\\
        Metodo astratto per eliminare una lista di documenti dal sistema di embeddings a partire dai loro id.
    \end{itemize}
\end{itemize}

\subsubsubsection{DeleteEmbeddingsPort}
\label{DeleteEmbeddingsPortDettaglio}
\begin{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{deleteDocumentsEmbeddings(documentIds:List<DocumentId>):}\\ \code{List<DocumentOperationResponse>}\\
        Metodo astratto per eliminare gli embeddings di una lista di documenti dal vector store a partire dai loro id.
    \end{itemize}
\end{itemize}

\subsubsubsection{DocumentOperationResponse}
\label{DocumentOperationResponseDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{documentId: DocumentId};
        \item \code{status: boolean};
        \item \code{message: string}.
    \end{itemize}
\end{itemize}

\subsubsubsection{DeleteDocumentsAWSS3}
\label{DeleteDocumentsAWSS3Dettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item awsS3Manager: AWSS3Manager.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{deleteDocuments(documentIds:List<DocumentId>):}\\ \code{List<DocumentOperationResponse>}\\
        Implementazione del metodo astratto di DeleteDocumentsPort per eliminare una lista di documenti da AWS S3 a partire dai loro id.
    \end{itemize}
\end{itemize}

\subsubsubsection{AWSS3Manager}
\label{AWSS3ManagerDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{boto3: boto3.session.Session};
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{getDocumentById(documentId:string): AWSDocument}\\
        Metodo per ottenere un AWSDocument a partire da una stringa corrispondente al documentId del documento tramite boto3;
        \item \code{deleteDocuments(documentsId:List<string>):}\\ \code{ List<AWSDocumentOperationResponse>}\\
        Metodo per eliminare un documento a partire da una stringa corrispondente al documentId del documento tramite boto3, ritornando un AWSDocumentOperationResponse;
        \item \code{getDocumentsMetadata(documentFilter:string): List<AWSDocumentMetadata>}\\
        Metodo per ottenere una lista di AWSDocumentMetaData a partire da una eventuale filtro stringa tramite boto3; 
        \item \code{uploadDocuments(documents:List<AWSDocument>, forceUpload:boolean):}\\ \code{ List<AWSDocumentOperationResponse>} \\ 
        Metodo per caricare una lista di AWSDocument tramite boto3, con flag forceUpload per forzare il caricamento di documenti già presenti nel sistema attraverso sostituzione, ritornando una lista di AWSDocumentOperationResponse.
    \end{itemize}
\end{itemize}

\subsubsubsection{AWSDocumentOperationResponse}
\label{AWSDocumentOperationResponseDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item \code{documentId: string};
        \item \code{status: boolean};
        \item \code{message: string}.
    \end{itemize}
\end{itemize}

\subsubsubsection{DeleteEmbeddingsVectorStore}
\label{DeleteEmbeddingsVectorStoreDettaglio}
\begin{itemize}
    \item \textbf{Attributi}:
    \begin{itemize}
        \item vectorStoreManager: VectorStoreManager.
    \end{itemize}
    \item \textbf{Metodi}:
    \begin{itemize}
        \item \code{deleteDocumentsEmbeddings(documentIds:List<DocumentId>):}\\ \code{List<DocumentOperationResponse>}\\
        Implementazione del metodo astratto di DeleteEmbeddingsPort per eliminare gli embeddings di una lista di documenti dal vector store a partire dai loro id.
    \end{itemize}
\end{itemize}

\subsubsubsection{VectorStoreManager}
Vedi \vedi{VectorStoreManagerDettaglio}.

\subsubsubsection{VectorStorePineconeManager}
Vedi \vedi{VectorStorePineconeManagerDettaglio}.

\subsubsubsection{VectorStoreChromaDBManager}
Vedi \vedi{VectorStoreChromaDBManagerDettaglio}.

\subsubsubsection{VectorStoreDocumentOperationResponse}
Vedi \vedi{VectorStoreDocumentOperationResponseDettaglio}.


\end{document}